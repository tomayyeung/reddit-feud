import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { PostSubmit, PostCreate, PostUpdate, PostReport, PostFlairUpdate, PostDelete, PostApprove, CommentSubmit, CommentCreate, CommentUpdate, CommentReport, CommentDelete, CommentApprove, SubredditSubscribe, AppInstall, AppUpgrade, AccountDelete, PostNsfwUpdate, PostSpoilerUpdate, AutomoderatorFilterPost, AutomoderatorFilterComment, } from '../../../events/v1alpha/events.js';
import { HandlerResult } from './event_handlers.js';
import { ModAction } from '../../../reddit/v2alpha/modaction.js';
import { ModMail } from '../../../reddit/v2alpha/modmail.js';
export var OnPostSubmitMethod;
(function (OnPostSubmitMethod) {
    OnPostSubmitMethod["OnPostSubmit"] = "OnPostSubmit";
})(OnPostSubmitMethod || (OnPostSubmitMethod = {}));
export const OnPostSubmitMethodList = [OnPostSubmitMethod.OnPostSubmit];
export function createOnPostSubmitServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostSubmit',
        methodList: OnPostSubmitMethodList,
        matchRoute: matchOnPostSubmitRoute,
    });
}
function matchOnPostSubmitRoute(method, events) {
    switch (method) {
        case 'OnPostSubmit':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostSubmit' };
                await events.onMatch(ctx);
                return handleOnPostSubmitOnPostSubmitRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostSubmitOnPostSubmitRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostSubmitOnPostSubmitJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostSubmitOnPostSubmitProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostSubmitOnPostSubmitJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostSubmit.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostSubmit(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostSubmit(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostSubmitOnPostSubmitProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostSubmit.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostSubmit(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostSubmit(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostCreateMethod;
(function (OnPostCreateMethod) {
    OnPostCreateMethod["OnPostCreate"] = "OnPostCreate";
})(OnPostCreateMethod || (OnPostCreateMethod = {}));
export const OnPostCreateMethodList = [OnPostCreateMethod.OnPostCreate];
export function createOnPostCreateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostCreate',
        methodList: OnPostCreateMethodList,
        matchRoute: matchOnPostCreateRoute,
    });
}
function matchOnPostCreateRoute(method, events) {
    switch (method) {
        case 'OnPostCreate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostCreate' };
                await events.onMatch(ctx);
                return handleOnPostCreateOnPostCreateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostCreateOnPostCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostCreateOnPostCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostCreateOnPostCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostCreateOnPostCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostCreate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostCreate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostCreate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostCreateOnPostCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostCreate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostCreate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostCreate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostUpdateMethod;
(function (OnPostUpdateMethod) {
    OnPostUpdateMethod["OnPostUpdate"] = "OnPostUpdate";
})(OnPostUpdateMethod || (OnPostUpdateMethod = {}));
export const OnPostUpdateMethodList = [OnPostUpdateMethod.OnPostUpdate];
export function createOnPostUpdateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostUpdate',
        methodList: OnPostUpdateMethodList,
        matchRoute: matchOnPostUpdateRoute,
    });
}
function matchOnPostUpdateRoute(method, events) {
    switch (method) {
        case 'OnPostUpdate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostUpdate' };
                await events.onMatch(ctx);
                return handleOnPostUpdateOnPostUpdateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostUpdateOnPostUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostUpdateOnPostUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostUpdateOnPostUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostUpdateOnPostUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostUpdate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostUpdate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostUpdateOnPostUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostUpdate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostUpdate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostReportMethod;
(function (OnPostReportMethod) {
    OnPostReportMethod["OnPostReport"] = "OnPostReport";
})(OnPostReportMethod || (OnPostReportMethod = {}));
export const OnPostReportMethodList = [OnPostReportMethod.OnPostReport];
export function createOnPostReportServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostReport',
        methodList: OnPostReportMethodList,
        matchRoute: matchOnPostReportRoute,
    });
}
function matchOnPostReportRoute(method, events) {
    switch (method) {
        case 'OnPostReport':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostReport' };
                await events.onMatch(ctx);
                return handleOnPostReportOnPostReportRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostReportOnPostReportRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostReportOnPostReportJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostReportOnPostReportProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostReportOnPostReportJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostReport.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostReport(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostReport(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostReportOnPostReportProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostReport.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostReport(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostReport(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostFlairUpdateMethod;
(function (OnPostFlairUpdateMethod) {
    OnPostFlairUpdateMethod["OnPostFlairUpdate"] = "OnPostFlairUpdate";
})(OnPostFlairUpdateMethod || (OnPostFlairUpdateMethod = {}));
export const OnPostFlairUpdateMethodList = [
    OnPostFlairUpdateMethod.OnPostFlairUpdate,
];
export function createOnPostFlairUpdateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostFlairUpdate',
        methodList: OnPostFlairUpdateMethodList,
        matchRoute: matchOnPostFlairUpdateRoute,
    });
}
function matchOnPostFlairUpdateRoute(method, events) {
    switch (method) {
        case 'OnPostFlairUpdate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostFlairUpdate' };
                await events.onMatch(ctx);
                return handleOnPostFlairUpdateOnPostFlairUpdateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostFlairUpdateOnPostFlairUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostFlairUpdateOnPostFlairUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostFlairUpdateOnPostFlairUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostFlairUpdateOnPostFlairUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostFlairUpdate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostFlairUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostFlairUpdate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostFlairUpdateOnPostFlairUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostFlairUpdate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostFlairUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostFlairUpdate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostDeleteMethod;
(function (OnPostDeleteMethod) {
    OnPostDeleteMethod["OnPostDelete"] = "OnPostDelete";
})(OnPostDeleteMethod || (OnPostDeleteMethod = {}));
export const OnPostDeleteMethodList = [OnPostDeleteMethod.OnPostDelete];
export function createOnPostDeleteServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostDelete',
        methodList: OnPostDeleteMethodList,
        matchRoute: matchOnPostDeleteRoute,
    });
}
function matchOnPostDeleteRoute(method, events) {
    switch (method) {
        case 'OnPostDelete':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostDelete' };
                await events.onMatch(ctx);
                return handleOnPostDeleteOnPostDeleteRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostDeleteOnPostDeleteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostDeleteOnPostDeleteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostDeleteOnPostDeleteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostDeleteOnPostDeleteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostDelete.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostDelete(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostDeleteOnPostDeleteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostDelete.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostDelete(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostApproveMethod;
(function (OnPostApproveMethod) {
    OnPostApproveMethod["OnPostApprove"] = "OnPostApprove";
})(OnPostApproveMethod || (OnPostApproveMethod = {}));
export const OnPostApproveMethodList = [OnPostApproveMethod.OnPostApprove];
export function createOnPostApproveServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostApprove',
        methodList: OnPostApproveMethodList,
        matchRoute: matchOnPostApproveRoute,
    });
}
function matchOnPostApproveRoute(method, events) {
    switch (method) {
        case 'OnPostApprove':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostApprove' };
                await events.onMatch(ctx);
                return handleOnPostApproveOnPostApproveRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostApproveOnPostApproveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostApproveOnPostApproveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostApproveOnPostApproveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostApproveOnPostApproveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostApprove.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostApprove(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostApprove(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostApproveOnPostApproveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostApprove.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostApprove(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostApprove(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentSubmitMethod;
(function (OnCommentSubmitMethod) {
    OnCommentSubmitMethod["OnCommentSubmit"] = "OnCommentSubmit";
})(OnCommentSubmitMethod || (OnCommentSubmitMethod = {}));
export const OnCommentSubmitMethodList = [
    OnCommentSubmitMethod.OnCommentSubmit,
];
export function createOnCommentSubmitServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentSubmit',
        methodList: OnCommentSubmitMethodList,
        matchRoute: matchOnCommentSubmitRoute,
    });
}
function matchOnCommentSubmitRoute(method, events) {
    switch (method) {
        case 'OnCommentSubmit':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentSubmit' };
                await events.onMatch(ctx);
                return handleOnCommentSubmitOnCommentSubmitRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentSubmitOnCommentSubmitRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentSubmitOnCommentSubmitJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentSubmitOnCommentSubmitProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentSubmitOnCommentSubmitJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentSubmit.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentSubmit(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentSubmit(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentSubmitOnCommentSubmitProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentSubmit.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentSubmit(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentSubmit(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentCreateMethod;
(function (OnCommentCreateMethod) {
    OnCommentCreateMethod["OnCommentCreate"] = "OnCommentCreate";
})(OnCommentCreateMethod || (OnCommentCreateMethod = {}));
export const OnCommentCreateMethodList = [
    OnCommentCreateMethod.OnCommentCreate,
];
export function createOnCommentCreateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentCreate',
        methodList: OnCommentCreateMethodList,
        matchRoute: matchOnCommentCreateRoute,
    });
}
function matchOnCommentCreateRoute(method, events) {
    switch (method) {
        case 'OnCommentCreate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentCreate' };
                await events.onMatch(ctx);
                return handleOnCommentCreateOnCommentCreateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentCreateOnCommentCreateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentCreateOnCommentCreateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentCreateOnCommentCreateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentCreateOnCommentCreateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentCreate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentCreate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentCreate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentCreateOnCommentCreateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentCreate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentCreate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentCreate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentUpdateMethod;
(function (OnCommentUpdateMethod) {
    OnCommentUpdateMethod["OnCommentUpdate"] = "OnCommentUpdate";
})(OnCommentUpdateMethod || (OnCommentUpdateMethod = {}));
export const OnCommentUpdateMethodList = [
    OnCommentUpdateMethod.OnCommentUpdate,
];
export function createOnCommentUpdateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentUpdate',
        methodList: OnCommentUpdateMethodList,
        matchRoute: matchOnCommentUpdateRoute,
    });
}
function matchOnCommentUpdateRoute(method, events) {
    switch (method) {
        case 'OnCommentUpdate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentUpdate' };
                await events.onMatch(ctx);
                return handleOnCommentUpdateOnCommentUpdateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentUpdateOnCommentUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentUpdateOnCommentUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentUpdateOnCommentUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentUpdateOnCommentUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentUpdate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentUpdate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentUpdateOnCommentUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentUpdate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentUpdate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentReportMethod;
(function (OnCommentReportMethod) {
    OnCommentReportMethod["OnCommentReport"] = "OnCommentReport";
})(OnCommentReportMethod || (OnCommentReportMethod = {}));
export const OnCommentReportMethodList = [
    OnCommentReportMethod.OnCommentReport,
];
export function createOnCommentReportServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentReport',
        methodList: OnCommentReportMethodList,
        matchRoute: matchOnCommentReportRoute,
    });
}
function matchOnCommentReportRoute(method, events) {
    switch (method) {
        case 'OnCommentReport':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentReport' };
                await events.onMatch(ctx);
                return handleOnCommentReportOnCommentReportRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentReportOnCommentReportRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentReportOnCommentReportJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentReportOnCommentReportProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentReportOnCommentReportJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentReport.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentReport(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentReport(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentReportOnCommentReportProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentReport.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentReport(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentReport(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentDeleteMethod;
(function (OnCommentDeleteMethod) {
    OnCommentDeleteMethod["OnCommentDelete"] = "OnCommentDelete";
})(OnCommentDeleteMethod || (OnCommentDeleteMethod = {}));
export const OnCommentDeleteMethodList = [
    OnCommentDeleteMethod.OnCommentDelete,
];
export function createOnCommentDeleteServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentDelete',
        methodList: OnCommentDeleteMethodList,
        matchRoute: matchOnCommentDeleteRoute,
    });
}
function matchOnCommentDeleteRoute(method, events) {
    switch (method) {
        case 'OnCommentDelete':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentDelete' };
                await events.onMatch(ctx);
                return handleOnCommentDeleteOnCommentDeleteRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentDeleteOnCommentDeleteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentDeleteOnCommentDeleteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentDeleteOnCommentDeleteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentDeleteOnCommentDeleteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentDelete.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentDelete(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentDeleteOnCommentDeleteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentDelete.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentDelete(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnCommentApproveMethod;
(function (OnCommentApproveMethod) {
    OnCommentApproveMethod["OnCommentApprove"] = "OnCommentApprove";
})(OnCommentApproveMethod || (OnCommentApproveMethod = {}));
export const OnCommentApproveMethodList = [
    OnCommentApproveMethod.OnCommentApprove,
];
export function createOnCommentApproveServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnCommentApprove',
        methodList: OnCommentApproveMethodList,
        matchRoute: matchOnCommentApproveRoute,
    });
}
function matchOnCommentApproveRoute(method, events) {
    switch (method) {
        case 'OnCommentApprove':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnCommentApprove' };
                await events.onMatch(ctx);
                return handleOnCommentApproveOnCommentApproveRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnCommentApproveOnCommentApproveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnCommentApproveOnCommentApproveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnCommentApproveOnCommentApproveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnCommentApproveOnCommentApproveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentApprove.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentApprove(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentApprove(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnCommentApproveOnCommentApproveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentApprove.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnCommentApprove(ctx, inputReq);
        });
    }
    else {
        response = await service.OnCommentApprove(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnSubredditSubscribeMethod;
(function (OnSubredditSubscribeMethod) {
    OnSubredditSubscribeMethod["OnSubredditSubscribe"] = "OnSubredditSubscribe";
})(OnSubredditSubscribeMethod || (OnSubredditSubscribeMethod = {}));
export const OnSubredditSubscribeMethodList = [
    OnSubredditSubscribeMethod.OnSubredditSubscribe,
];
export function createOnSubredditSubscribeServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnSubredditSubscribe',
        methodList: OnSubredditSubscribeMethodList,
        matchRoute: matchOnSubredditSubscribeRoute,
    });
}
function matchOnSubredditSubscribeRoute(method, events) {
    switch (method) {
        case 'OnSubredditSubscribe':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnSubredditSubscribe' };
                await events.onMatch(ctx);
                return handleOnSubredditSubscribeOnSubredditSubscribeRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnSubredditSubscribeOnSubredditSubscribeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnSubredditSubscribeOnSubredditSubscribeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnSubredditSubscribeOnSubredditSubscribeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnSubredditSubscribeOnSubredditSubscribeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubredditSubscribe.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnSubredditSubscribe(ctx, inputReq);
        });
    }
    else {
        response = await service.OnSubredditSubscribe(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnSubredditSubscribeOnSubredditSubscribeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubredditSubscribe.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnSubredditSubscribe(ctx, inputReq);
        });
    }
    else {
        response = await service.OnSubredditSubscribe(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnAppInstallMethod;
(function (OnAppInstallMethod) {
    OnAppInstallMethod["OnAppInstall"] = "OnAppInstall";
})(OnAppInstallMethod || (OnAppInstallMethod = {}));
export const OnAppInstallMethodList = [OnAppInstallMethod.OnAppInstall];
export function createOnAppInstallServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnAppInstall',
        methodList: OnAppInstallMethodList,
        matchRoute: matchOnAppInstallRoute,
    });
}
function matchOnAppInstallRoute(method, events) {
    switch (method) {
        case 'OnAppInstall':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnAppInstall' };
                await events.onMatch(ctx);
                return handleOnAppInstallOnAppInstallRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnAppInstallOnAppInstallRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnAppInstallOnAppInstallJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnAppInstallOnAppInstallProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnAppInstallOnAppInstallJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppInstall.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAppInstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAppInstall(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnAppInstallOnAppInstallProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppInstall.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAppInstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAppInstall(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnAppUpgradeMethod;
(function (OnAppUpgradeMethod) {
    OnAppUpgradeMethod["OnAppUpgrade"] = "OnAppUpgrade";
})(OnAppUpgradeMethod || (OnAppUpgradeMethod = {}));
export const OnAppUpgradeMethodList = [OnAppUpgradeMethod.OnAppUpgrade];
export function createOnAppUpgradeServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnAppUpgrade',
        methodList: OnAppUpgradeMethodList,
        matchRoute: matchOnAppUpgradeRoute,
    });
}
function matchOnAppUpgradeRoute(method, events) {
    switch (method) {
        case 'OnAppUpgrade':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnAppUpgrade' };
                await events.onMatch(ctx);
                return handleOnAppUpgradeOnAppUpgradeRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnAppUpgradeOnAppUpgradeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnAppUpgradeOnAppUpgradeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnAppUpgradeOnAppUpgradeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnAppUpgradeOnAppUpgradeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppUpgrade.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAppUpgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAppUpgrade(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnAppUpgradeOnAppUpgradeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppUpgrade.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAppUpgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAppUpgrade(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnModActionMethod;
(function (OnModActionMethod) {
    OnModActionMethod["OnModAction"] = "OnModAction";
})(OnModActionMethod || (OnModActionMethod = {}));
export const OnModActionMethodList = [OnModActionMethod.OnModAction];
export function createOnModActionServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnModAction',
        methodList: OnModActionMethodList,
        matchRoute: matchOnModActionRoute,
    });
}
function matchOnModActionRoute(method, events) {
    switch (method) {
        case 'OnModAction':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnModAction' };
                await events.onMatch(ctx);
                return handleOnModActionOnModActionRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnModActionOnModActionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnModActionOnModActionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnModActionOnModActionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnModActionOnModActionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ModAction.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnModAction(ctx, inputReq);
        });
    }
    else {
        response = await service.OnModAction(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnModActionOnModActionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ModAction.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnModAction(ctx, inputReq);
        });
    }
    else {
        response = await service.OnModAction(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnModMailMethod;
(function (OnModMailMethod) {
    OnModMailMethod["OnModMail"] = "OnModMail";
})(OnModMailMethod || (OnModMailMethod = {}));
export const OnModMailMethodList = [OnModMailMethod.OnModMail];
export function createOnModMailServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnModMail',
        methodList: OnModMailMethodList,
        matchRoute: matchOnModMailRoute,
    });
}
function matchOnModMailRoute(method, events) {
    switch (method) {
        case 'OnModMail':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnModMail' };
                await events.onMatch(ctx);
                return handleOnModMailOnModMailRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnModMailOnModMailRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnModMailOnModMailJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnModMailOnModMailProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnModMailOnModMailJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ModMail.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnModMail(ctx, inputReq);
        });
    }
    else {
        response = await service.OnModMail(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnModMailOnModMailProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ModMail.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnModMail(ctx, inputReq);
        });
    }
    else {
        response = await service.OnModMail(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnAccountDeleteMethod;
(function (OnAccountDeleteMethod) {
    OnAccountDeleteMethod["OnAccountDelete"] = "OnAccountDelete";
})(OnAccountDeleteMethod || (OnAccountDeleteMethod = {}));
export const OnAccountDeleteMethodList = [
    OnAccountDeleteMethod.OnAccountDelete,
];
export function createOnAccountDeleteServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnAccountDelete',
        methodList: OnAccountDeleteMethodList,
        matchRoute: matchOnAccountDeleteRoute,
    });
}
function matchOnAccountDeleteRoute(method, events) {
    switch (method) {
        case 'OnAccountDelete':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnAccountDelete' };
                await events.onMatch(ctx);
                return handleOnAccountDeleteOnAccountDeleteRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnAccountDeleteOnAccountDeleteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnAccountDeleteOnAccountDeleteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnAccountDeleteOnAccountDeleteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnAccountDeleteOnAccountDeleteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AccountDelete.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAccountDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAccountDelete(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnAccountDeleteOnAccountDeleteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AccountDelete.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAccountDelete(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAccountDelete(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostNsfwUpdateMethod;
(function (OnPostNsfwUpdateMethod) {
    OnPostNsfwUpdateMethod["OnPostNsfwUpdate"] = "OnPostNsfwUpdate";
})(OnPostNsfwUpdateMethod || (OnPostNsfwUpdateMethod = {}));
export const OnPostNsfwUpdateMethodList = [
    OnPostNsfwUpdateMethod.OnPostNsfwUpdate,
];
export function createOnPostNsfwUpdateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostNsfwUpdate',
        methodList: OnPostNsfwUpdateMethodList,
        matchRoute: matchOnPostNsfwUpdateRoute,
    });
}
function matchOnPostNsfwUpdateRoute(method, events) {
    switch (method) {
        case 'OnPostNsfwUpdate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostNsfwUpdate' };
                await events.onMatch(ctx);
                return handleOnPostNsfwUpdateOnPostNsfwUpdateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostNsfwUpdateOnPostNsfwUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostNsfwUpdateOnPostNsfwUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostNsfwUpdateOnPostNsfwUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostNsfwUpdateOnPostNsfwUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostNsfwUpdate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostNsfwUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostNsfwUpdate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostNsfwUpdateOnPostNsfwUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostNsfwUpdate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostNsfwUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostNsfwUpdate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnPostSpoilerUpdateMethod;
(function (OnPostSpoilerUpdateMethod) {
    OnPostSpoilerUpdateMethod["OnPostSpoilerUpdate"] = "OnPostSpoilerUpdate";
})(OnPostSpoilerUpdateMethod || (OnPostSpoilerUpdateMethod = {}));
export const OnPostSpoilerUpdateMethodList = [
    OnPostSpoilerUpdateMethod.OnPostSpoilerUpdate,
];
export function createOnPostSpoilerUpdateServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnPostSpoilerUpdate',
        methodList: OnPostSpoilerUpdateMethodList,
        matchRoute: matchOnPostSpoilerUpdateRoute,
    });
}
function matchOnPostSpoilerUpdateRoute(method, events) {
    switch (method) {
        case 'OnPostSpoilerUpdate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnPostSpoilerUpdate' };
                await events.onMatch(ctx);
                return handleOnPostSpoilerUpdateOnPostSpoilerUpdateRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnPostSpoilerUpdateOnPostSpoilerUpdateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnPostSpoilerUpdateOnPostSpoilerUpdateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnPostSpoilerUpdateOnPostSpoilerUpdateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnPostSpoilerUpdateOnPostSpoilerUpdateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostSpoilerUpdate.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostSpoilerUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostSpoilerUpdate(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnPostSpoilerUpdateOnPostSpoilerUpdateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostSpoilerUpdate.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnPostSpoilerUpdate(ctx, inputReq);
        });
    }
    else {
        response = await service.OnPostSpoilerUpdate(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnAutomoderatorFilterPostMethod;
(function (OnAutomoderatorFilterPostMethod) {
    OnAutomoderatorFilterPostMethod["OnAutomoderatorFilterPost"] = "OnAutomoderatorFilterPost";
})(OnAutomoderatorFilterPostMethod || (OnAutomoderatorFilterPostMethod = {}));
export const OnAutomoderatorFilterPostMethodList = [
    OnAutomoderatorFilterPostMethod.OnAutomoderatorFilterPost,
];
export function createOnAutomoderatorFilterPostServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnAutomoderatorFilterPost',
        methodList: OnAutomoderatorFilterPostMethodList,
        matchRoute: matchOnAutomoderatorFilterPostRoute,
    });
}
function matchOnAutomoderatorFilterPostRoute(method, events) {
    switch (method) {
        case 'OnAutomoderatorFilterPost':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnAutomoderatorFilterPost' };
                await events.onMatch(ctx);
                return handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AutomoderatorFilterPost.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAutomoderatorFilterPost(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAutomoderatorFilterPost(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnAutomoderatorFilterPostOnAutomoderatorFilterPostProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AutomoderatorFilterPost.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAutomoderatorFilterPost(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAutomoderatorFilterPost(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
export var OnAutomoderatorFilterCommentMethod;
(function (OnAutomoderatorFilterCommentMethod) {
    OnAutomoderatorFilterCommentMethod["OnAutomoderatorFilterComment"] = "OnAutomoderatorFilterComment";
})(OnAutomoderatorFilterCommentMethod || (OnAutomoderatorFilterCommentMethod = {}));
export const OnAutomoderatorFilterCommentMethodList = [
    OnAutomoderatorFilterCommentMethod.OnAutomoderatorFilterComment,
];
export function createOnAutomoderatorFilterCommentServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.automation.v1alpha',
        serviceName: 'OnAutomoderatorFilterComment',
        methodList: OnAutomoderatorFilterCommentMethodList,
        matchRoute: matchOnAutomoderatorFilterCommentRoute,
    });
}
function matchOnAutomoderatorFilterCommentRoute(method, events) {
    switch (method) {
        case 'OnAutomoderatorFilterComment':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnAutomoderatorFilterComment' };
                await events.onMatch(ctx);
                return handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AutomoderatorFilterComment.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAutomoderatorFilterComment(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAutomoderatorFilterComment(ctx, request);
    }
    return JSON.stringify(HandlerResult.toJSON(response));
}
async function handleOnAutomoderatorFilterCommentOnAutomoderatorFilterCommentProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AutomoderatorFilterComment.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnAutomoderatorFilterComment(ctx, inputReq);
        });
    }
    else {
        response = await service.OnAutomoderatorFilterComment(ctx, request);
    }
    return Buffer.from(HandlerResult.encode(response).finish());
}
