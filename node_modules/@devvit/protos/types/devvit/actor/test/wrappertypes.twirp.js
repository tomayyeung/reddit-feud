import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { StringValue, BoolValue, Int32Value, UInt32Value, Int64Value, UInt64Value, FloatValue, DoubleValue, } from '../../../google/protobuf/wrappers.js';
export var WrapperTypesMethod;
(function (WrapperTypesMethod) {
    WrapperTypesMethod["StringRequest"] = "StringRequest";
    WrapperTypesMethod["BoolRequest"] = "BoolRequest";
    WrapperTypesMethod["Int32Request"] = "Int32Request";
    WrapperTypesMethod["UInt32Request"] = "UInt32Request";
    WrapperTypesMethod["Int64Request"] = "Int64Request";
    WrapperTypesMethod["UInt64Request"] = "UInt64Request";
    WrapperTypesMethod["FloatRequest"] = "FloatRequest";
    WrapperTypesMethod["DoubleRequest"] = "DoubleRequest";
})(WrapperTypesMethod || (WrapperTypesMethod = {}));
export const WrapperTypesMethodList = [
    WrapperTypesMethod.StringRequest,
    WrapperTypesMethod.BoolRequest,
    WrapperTypesMethod.Int32Request,
    WrapperTypesMethod.UInt32Request,
    WrapperTypesMethod.Int64Request,
    WrapperTypesMethod.UInt64Request,
    WrapperTypesMethod.FloatRequest,
    WrapperTypesMethod.DoubleRequest,
];
export function createWrapperTypesServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.test',
        serviceName: 'WrapperTypes',
        methodList: WrapperTypesMethodList,
        matchRoute: matchWrapperTypesRoute,
    });
}
function matchWrapperTypesRoute(method, events) {
    switch (method) {
        case 'StringRequest':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'StringRequest' };
                await events.onMatch(ctx);
                return handleWrapperTypesStringRequestRequest(ctx, service, data, interceptors);
            };
        case 'BoolRequest':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'BoolRequest' };
                await events.onMatch(ctx);
                return handleWrapperTypesBoolRequestRequest(ctx, service, data, interceptors);
            };
        case 'Int32Request':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Int32Request' };
                await events.onMatch(ctx);
                return handleWrapperTypesInt32RequestRequest(ctx, service, data, interceptors);
            };
        case 'UInt32Request':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UInt32Request' };
                await events.onMatch(ctx);
                return handleWrapperTypesUInt32RequestRequest(ctx, service, data, interceptors);
            };
        case 'Int64Request':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Int64Request' };
                await events.onMatch(ctx);
                return handleWrapperTypesInt64RequestRequest(ctx, service, data, interceptors);
            };
        case 'UInt64Request':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UInt64Request' };
                await events.onMatch(ctx);
                return handleWrapperTypesUInt64RequestRequest(ctx, service, data, interceptors);
            };
        case 'FloatRequest':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FloatRequest' };
                await events.onMatch(ctx);
                return handleWrapperTypesFloatRequestRequest(ctx, service, data, interceptors);
            };
        case 'DoubleRequest':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DoubleRequest' };
                await events.onMatch(ctx);
                return handleWrapperTypesDoubleRequestRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesStringRequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesStringRequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesStringRequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesBoolRequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesBoolRequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesBoolRequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesInt32RequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesInt32RequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesInt32RequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesUInt32RequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesUInt32RequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesUInt32RequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesInt64RequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesInt64RequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesInt64RequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesUInt64RequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesUInt64RequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesUInt64RequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesFloatRequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesFloatRequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesFloatRequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleWrapperTypesDoubleRequestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleWrapperTypesDoubleRequestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleWrapperTypesDoubleRequestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleWrapperTypesStringRequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = StringValue.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.StringRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.StringRequest(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleWrapperTypesBoolRequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BoolValue.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BoolRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.BoolRequest(ctx, request);
    }
    return JSON.stringify(BoolValue.toJSON(response));
}
async function handleWrapperTypesInt32RequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Int32Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Int32Request(ctx, inputReq);
        });
    }
    else {
        response = await service.Int32Request(ctx, request);
    }
    return JSON.stringify(Int32Value.toJSON(response));
}
async function handleWrapperTypesUInt32RequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UInt32Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UInt32Request(ctx, inputReq);
        });
    }
    else {
        response = await service.UInt32Request(ctx, request);
    }
    return JSON.stringify(UInt32Value.toJSON(response));
}
async function handleWrapperTypesInt64RequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Int64Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Int64Request(ctx, inputReq);
        });
    }
    else {
        response = await service.Int64Request(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleWrapperTypesUInt64RequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UInt64Value.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UInt64Request(ctx, inputReq);
        });
    }
    else {
        response = await service.UInt64Request(ctx, request);
    }
    return JSON.stringify(UInt64Value.toJSON(response));
}
async function handleWrapperTypesFloatRequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FloatValue.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FloatRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.FloatRequest(ctx, request);
    }
    return JSON.stringify(FloatValue.toJSON(response));
}
async function handleWrapperTypesDoubleRequestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DoubleValue.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DoubleRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.DoubleRequest(ctx, request);
    }
    return JSON.stringify(DoubleValue.toJSON(response));
}
async function handleWrapperTypesStringRequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = StringValue.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.StringRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.StringRequest(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleWrapperTypesBoolRequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BoolValue.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BoolRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.BoolRequest(ctx, request);
    }
    return Buffer.from(BoolValue.encode(response).finish());
}
async function handleWrapperTypesInt32RequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Int32Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Int32Request(ctx, inputReq);
        });
    }
    else {
        response = await service.Int32Request(ctx, request);
    }
    return Buffer.from(Int32Value.encode(response).finish());
}
async function handleWrapperTypesUInt32RequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UInt32Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UInt32Request(ctx, inputReq);
        });
    }
    else {
        response = await service.UInt32Request(ctx, request);
    }
    return Buffer.from(UInt32Value.encode(response).finish());
}
async function handleWrapperTypesInt64RequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Int64Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Int64Request(ctx, inputReq);
        });
    }
    else {
        response = await service.Int64Request(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleWrapperTypesUInt64RequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UInt64Value.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UInt64Request(ctx, inputReq);
        });
    }
    else {
        response = await service.UInt64Request(ctx, request);
    }
    return Buffer.from(UInt64Value.encode(response).finish());
}
async function handleWrapperTypesFloatRequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FloatValue.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FloatRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.FloatRequest(ctx, request);
    }
    return Buffer.from(FloatValue.encode(response).finish());
}
async function handleWrapperTypesDoubleRequestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DoubleValue.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DoubleRequest(ctx, inputReq);
        });
    }
    else {
        response = await service.DoubleRequest(ctx, request);
    }
    return Buffer.from(DoubleValue.encode(response).finish());
}
