import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { Empty } from '../../../google/protobuf/empty.js';
import { ConfigForm, FormResponse } from './user_configurable.js';
export var UserConfigurableMethod;
(function (UserConfigurableMethod) {
    UserConfigurableMethod["RenderForm"] = "RenderForm";
    UserConfigurableMethod["HandleFormResponse"] = "HandleFormResponse";
})(UserConfigurableMethod || (UserConfigurableMethod = {}));
export const UserConfigurableMethodList = [
    UserConfigurableMethod.RenderForm,
    UserConfigurableMethod.HandleFormResponse,
];
export function createUserConfigurableServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.actor.user_configurable',
        serviceName: 'UserConfigurable',
        methodList: UserConfigurableMethodList,
        matchRoute: matchUserConfigurableRoute,
    });
}
function matchUserConfigurableRoute(method, events) {
    switch (method) {
        case 'RenderForm':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'RenderForm' };
                await events.onMatch(ctx);
                return handleUserConfigurableRenderFormRequest(ctx, service, data, interceptors);
            };
        case 'HandleFormResponse':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HandleFormResponse' };
                await events.onMatch(ctx);
                return handleUserConfigurableHandleFormResponseRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUserConfigurableRenderFormRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUserConfigurableRenderFormJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUserConfigurableRenderFormProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUserConfigurableHandleFormResponseRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUserConfigurableHandleFormResponseJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUserConfigurableHandleFormResponseProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleUserConfigurableRenderFormJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RenderForm(ctx, inputReq);
        });
    }
    else {
        response = await service.RenderForm(ctx, request);
    }
    return JSON.stringify(ConfigForm.toJSON(response));
}
async function handleUserConfigurableHandleFormResponseJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ConfigForm.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HandleFormResponse(ctx, inputReq);
        });
    }
    else {
        response = await service.HandleFormResponse(ctx, request);
    }
    return JSON.stringify(FormResponse.toJSON(response));
}
async function handleUserConfigurableRenderFormProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RenderForm(ctx, inputReq);
        });
    }
    else {
        response = await service.RenderForm(ctx, request);
    }
    return Buffer.from(ConfigForm.encode(response).finish());
}
async function handleUserConfigurableHandleFormResponseProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ConfigForm.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HandleFormResponse(ctx, inputReq);
        });
    }
    else {
        response = await service.HandleFormResponse(ctx, request);
    }
    return Buffer.from(FormResponse.encode(response).finish());
}
