/**
 * #waitlist_admin.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Empty } from "../../../google/protobuf/empty.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
import { StringValue } from "../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
export var WaitlistStatus;
(function (WaitlistStatus) {
    WaitlistStatus[WaitlistStatus["PENDING"] = 0] = "PENDING";
    WaitlistStatus[WaitlistStatus["ACCEPTED"] = 1] = "ACCEPTED";
    WaitlistStatus[WaitlistStatus["REJECTED"] = 2] = "REJECTED";
    WaitlistStatus[WaitlistStatus["REVOKED"] = 3] = "REVOKED";
    WaitlistStatus[WaitlistStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WaitlistStatus || (WaitlistStatus = {}));
export function waitlistStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "PENDING":
            return WaitlistStatus.PENDING;
        case 1:
        case "ACCEPTED":
            return WaitlistStatus.ACCEPTED;
        case 2:
        case "REJECTED":
            return WaitlistStatus.REJECTED;
        case 3:
        case "REVOKED":
            return WaitlistStatus.REVOKED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WaitlistStatus.UNRECOGNIZED;
    }
}
export function waitlistStatusToJSON(object) {
    switch (object) {
        case WaitlistStatus.PENDING:
            return 0;
        case WaitlistStatus.ACCEPTED:
            return 1;
        case WaitlistStatus.REJECTED:
            return 2;
        case WaitlistStatus.REVOKED:
            return 3;
        case WaitlistStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseSubmission() {
    return {
        id: "",
        userId: "",
        userName: "",
        whatToBuild: "",
        botsBuilt: "",
        createdAt: undefined,
        updatedAt: undefined,
        status: 0,
        acceptedTermsVersion: 0,
    };
}
export const Submission = {
    $type: "devvit.dev_portal.admin.Submission",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.userId !== "") {
            writer.uint32(18).string(message.userId);
        }
        if (message.userName !== "") {
            writer.uint32(26).string(message.userName);
        }
        if (message.whatToBuild !== "") {
            writer.uint32(34).string(message.whatToBuild);
        }
        if (message.botsBuilt !== "") {
            writer.uint32(42).string(message.botsBuilt);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).ldelim();
        }
        if (message.updatedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).ldelim();
        }
        if (message.status !== 0) {
            writer.uint32(64).int32(message.status);
        }
        if (message.acceptedTermsVersion !== 0) {
            writer.uint32(72).int32(message.acceptedTermsVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.userName = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.whatToBuild = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.botsBuilt = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.acceptedTermsVersion = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
            whatToBuild: isSet(object.whatToBuild) ? globalThis.String(object.whatToBuild) : "",
            botsBuilt: isSet(object.botsBuilt) ? globalThis.String(object.botsBuilt) : "",
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
            status: isSet(object.status) ? waitlistStatusFromJSON(object.status) : 0,
            acceptedTermsVersion: isSet(object.acceptedTermsVersion) ? globalThis.Number(object.acceptedTermsVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.userName !== "") {
            obj.userName = message.userName;
        }
        if (message.whatToBuild !== "") {
            obj.whatToBuild = message.whatToBuild;
        }
        if (message.botsBuilt !== "") {
            obj.botsBuilt = message.botsBuilt;
        }
        if (message.createdAt !== undefined) {
            obj.createdAt = message.createdAt.toISOString();
        }
        if (message.updatedAt !== undefined) {
            obj.updatedAt = message.updatedAt.toISOString();
        }
        if (message.status !== 0) {
            obj.status = waitlistStatusToJSON(message.status);
        }
        if (message.acceptedTermsVersion !== 0) {
            obj.acceptedTermsVersion = Math.round(message.acceptedTermsVersion);
        }
        return obj;
    },
    create(base) {
        return Submission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmission();
        message.id = object.id ?? "";
        message.userId = object.userId ?? "";
        message.userName = object.userName ?? "";
        message.whatToBuild = object.whatToBuild ?? "";
        message.botsBuilt = object.botsBuilt ?? "";
        message.createdAt = object.createdAt ?? undefined;
        message.updatedAt = object.updatedAt ?? undefined;
        message.status = object.status ?? 0;
        message.acceptedTermsVersion = object.acceptedTermsVersion ?? 0;
        return message;
    },
};
messageTypeRegistry.set(Submission.$type, Submission);
function createBaseSubmissionsRequest() {
    return { limit: 0, after: undefined, before: undefined, username: undefined };
}
export const SubmissionsRequest = {
    $type: "devvit.dev_portal.admin.SubmissionsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        if (message.after !== undefined) {
            Timestamp.encode(toTimestamp(message.after), writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            Timestamp.encode(toTimestamp(message.before), writer.uint32(26).fork()).ldelim();
        }
        if (message.username !== undefined) {
            writer.uint32(34).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.after = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.before = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
            after: isSet(object.after) ? fromJsonTimestamp(object.after) : undefined,
            before: isSet(object.before) ? fromJsonTimestamp(object.before) : undefined,
            username: isSet(object.username) ? globalThis.String(object.username) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        if (message.after !== undefined) {
            obj.after = message.after.toISOString();
        }
        if (message.before !== undefined) {
            obj.before = message.before.toISOString();
        }
        if (message.username !== undefined) {
            obj.username = message.username;
        }
        return obj;
    },
    create(base) {
        return SubmissionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionsRequest();
        message.limit = object.limit ?? 0;
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.username = object.username ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubmissionsRequest.$type, SubmissionsRequest);
function createBaseSubmissionsResponse() {
    return { submissions: [], totalSubmissions: 0, count: 0, first: undefined, last: undefined };
}
export const SubmissionsResponse = {
    $type: "devvit.dev_portal.admin.SubmissionsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.submissions) {
            Submission.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.totalSubmissions !== 0) {
            writer.uint32(16).int32(message.totalSubmissions);
        }
        if (message.count !== 0) {
            writer.uint32(24).int32(message.count);
        }
        if (message.first !== undefined) {
            Timestamp.encode(toTimestamp(message.first), writer.uint32(34).fork()).ldelim();
        }
        if (message.last !== undefined) {
            Timestamp.encode(toTimestamp(message.last), writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.submissions.push(Submission.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.totalSubmissions = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.count = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.first = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.last = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            submissions: globalThis.Array.isArray(object?.submissions)
                ? object.submissions.map((e) => Submission.fromJSON(e))
                : [],
            totalSubmissions: isSet(object.totalSubmissions) ? globalThis.Number(object.totalSubmissions) : 0,
            count: isSet(object.count) ? globalThis.Number(object.count) : 0,
            first: isSet(object.first) ? fromJsonTimestamp(object.first) : undefined,
            last: isSet(object.last) ? fromJsonTimestamp(object.last) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.submissions?.length) {
            obj.submissions = message.submissions.map((e) => Submission.toJSON(e));
        }
        if (message.totalSubmissions !== 0) {
            obj.totalSubmissions = Math.round(message.totalSubmissions);
        }
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        if (message.first !== undefined) {
            obj.first = message.first.toISOString();
        }
        if (message.last !== undefined) {
            obj.last = message.last.toISOString();
        }
        return obj;
    },
    create(base) {
        return SubmissionsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionsResponse();
        message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
        message.totalSubmissions = object.totalSubmissions ?? 0;
        message.count = object.count ?? 0;
        message.first = object.first ?? undefined;
        message.last = object.last ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubmissionsResponse.$type, SubmissionsResponse);
function createBaseSubmissionUpdateRequest() {
    return { id: "", status: 0 };
}
export const SubmissionUpdateRequest = {
    $type: "devvit.dev_portal.admin.SubmissionUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            status: isSet(object.status) ? waitlistStatusFromJSON(object.status) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.status !== 0) {
            obj.status = waitlistStatusToJSON(message.status);
        }
        return obj;
    },
    create(base) {
        return SubmissionUpdateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionUpdateRequest();
        message.id = object.id ?? "";
        message.status = object.status ?? 0;
        return message;
    },
};
messageTypeRegistry.set(SubmissionUpdateRequest.$type, SubmissionUpdateRequest);
function createBaseSubmissionUpdateResponse() {
    return { success: false, message: undefined };
}
export const SubmissionUpdateResponse = {
    $type: "devvit.dev_portal.admin.SubmissionUpdateResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionUpdateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return SubmissionUpdateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionUpdateResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubmissionUpdateResponse.$type, SubmissionUpdateResponse);
function createBaseSubmissionAddRequest() {
    return { userId: undefined, userName: undefined };
}
export const SubmissionAddRequest = {
    $type: "devvit.dev_portal.admin.SubmissionAddRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== undefined) {
            writer.uint32(10).string(message.userId);
        }
        if (message.userName !== undefined) {
            writer.uint32(18).string(message.userName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionAddRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.userName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
            userName: isSet(object.userName) ? globalThis.String(object.userName) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userId !== undefined) {
            obj.userId = message.userId;
        }
        if (message.userName !== undefined) {
            obj.userName = message.userName;
        }
        return obj;
    },
    create(base) {
        return SubmissionAddRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionAddRequest();
        message.userId = object.userId ?? undefined;
        message.userName = object.userName ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubmissionAddRequest.$type, SubmissionAddRequest);
function createBaseSubmissionAddResponse() {
    return { success: false, message: undefined };
}
export const SubmissionAddResponse = {
    $type: "devvit.dev_portal.admin.SubmissionAddResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionAddResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return SubmissionAddResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubmissionAddResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubmissionAddResponse.$type, SubmissionAddResponse);
export const WaitlistAdminServiceName = "devvit.dev_portal.admin.WaitlistAdmin";
export class WaitlistAdminClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || WaitlistAdminServiceName;
        this.rpc = rpc;
        this.GetSubmissions = this.GetSubmissions.bind(this);
        this.UpdateSubmission = this.UpdateSubmission.bind(this);
        this.AddSubmission = this.AddSubmission.bind(this);
        this.ExportAsCSV = this.ExportAsCSV.bind(this);
    }
    GetSubmissions(request, metadata) {
        const data = SubmissionsRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "GetSubmissions", data, metadata);
        return promise.then((data) => SubmissionsResponse.decode(_m0.Reader.create(data)));
    }
    UpdateSubmission(request, metadata) {
        const data = SubmissionUpdateRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "UpdateSubmission", data, metadata);
        return promise.then((data) => SubmissionUpdateResponse.decode(_m0.Reader.create(data)));
    }
    AddSubmission(request, metadata) {
        const data = SubmissionAddRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "AddSubmission", data, metadata);
        return promise.then((data) => SubmissionAddResponse.decode(_m0.Reader.create(data)));
    }
    ExportAsCSV(request, metadata) {
        const data = Empty.encode(request).finish();
        const promise = this.rpc.request(this.service, "ExportAsCSV", data, metadata);
        return promise.then((data) => StringValue.decode(_m0.Reader.create(data)));
    }
}
export const WaitlistAdminDefinition = {
    name: "WaitlistAdmin",
    fullName: "devvit.dev_portal.admin.WaitlistAdmin",
    methods: {
        getSubmissions: {
            name: "GetSubmissions",
            requestType: SubmissionsRequest,
            requestStream: false,
            responseType: SubmissionsResponse,
            responseStream: false,
            options: {},
        },
        updateSubmission: {
            name: "UpdateSubmission",
            requestType: SubmissionUpdateRequest,
            requestStream: false,
            responseType: SubmissionUpdateResponse,
            responseStream: false,
            options: {},
        },
        addSubmission: {
            name: "AddSubmission",
            requestType: SubmissionAddRequest,
            requestStream: false,
            responseType: SubmissionAddResponse,
            responseStream: false,
            options: {},
        },
        exportAsCSV: {
            name: "ExportAsCSV",
            requestType: Empty,
            requestStream: false,
            responseType: StringValue,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
