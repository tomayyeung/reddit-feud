/**
 * #app_info.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
import { computePoolFromJSON, computePoolToJSON } from "../../app_version/info/app_version_info.js";
import { Redditor } from "../../reddit/redditor.js";
import { categoriesFromJSON, categoriesToJSON } from "../categories/categories.js";
export var AppCapability;
(function (AppCapability) {
    AppCapability[AppCapability["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    AppCapability[AppCapability["WEBVIEW"] = 1] = "WEBVIEW";
    AppCapability[AppCapability["PAYMENTS"] = 2] = "PAYMENTS";
    AppCapability[AppCapability["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AppCapability || (AppCapability = {}));
export function appCapabilityFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSPECIFIED":
            return AppCapability.UNSPECIFIED;
        case 1:
        case "WEBVIEW":
            return AppCapability.WEBVIEW;
        case 2:
        case "PAYMENTS":
            return AppCapability.PAYMENTS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AppCapability.UNRECOGNIZED;
    }
}
export function appCapabilityToJSON(object) {
    switch (object) {
        case AppCapability.UNSPECIFIED:
            return 0;
        case AppCapability.WEBVIEW:
            return 1;
        case AppCapability.PAYMENTS:
            return 2;
        case AppCapability.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAppInfo() {
    return {
        id: "",
        slug: "",
        name: "",
        description: "",
        appAccount: undefined,
        isNsfw: false,
        isDelisted: false,
        isFirstParty: false,
        isArchived: false,
        isWebviewEnabled: false,
        createdAt: undefined,
        owner: undefined,
        categories: [],
        stats: undefined,
        termsAndConditions: "",
        privacyPolicy: "",
        defaultPool: 0,
        capabilities: [],
        isDisabled: false,
    };
}
export const AppInfo = {
    $type: "devvit.dev_portal.app.info.AppInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.slug !== "") {
            writer.uint32(18).string(message.slug);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(34).string(message.description);
        }
        if (message.appAccount !== undefined) {
            Redditor.encode(message.appAccount, writer.uint32(122).fork()).ldelim();
        }
        if (message.isNsfw !== false) {
            writer.uint32(40).bool(message.isNsfw);
        }
        if (message.isDelisted !== false) {
            writer.uint32(48).bool(message.isDelisted);
        }
        if (message.isFirstParty !== false) {
            writer.uint32(104).bool(message.isFirstParty);
        }
        if (message.isArchived !== false) {
            writer.uint32(112).bool(message.isArchived);
        }
        if (message.isWebviewEnabled !== false) {
            writer.uint32(136).bool(message.isWebviewEnabled);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
        }
        if (message.owner !== undefined) {
            Redditor.encode(message.owner, writer.uint32(66).fork()).ldelim();
        }
        writer.uint32(74).fork();
        for (const v of message.categories) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.stats !== undefined) {
            AppStats.encode(message.stats, writer.uint32(82).fork()).ldelim();
        }
        if (message.termsAndConditions !== "") {
            writer.uint32(90).string(message.termsAndConditions);
        }
        if (message.privacyPolicy !== "") {
            writer.uint32(98).string(message.privacyPolicy);
        }
        if (message.defaultPool !== 0) {
            writer.uint32(128).int32(message.defaultPool);
        }
        writer.uint32(146).fork();
        for (const v of message.capabilities) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.isDisabled !== false) {
            writer.uint32(152).bool(message.isDisabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.slug = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.appAccount = Redditor.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.isNsfw = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.isDelisted = reader.bool();
                    continue;
                case 13:
                    if (tag !== 104) {
                        break;
                    }
                    message.isFirstParty = reader.bool();
                    continue;
                case 14:
                    if (tag !== 112) {
                        break;
                    }
                    message.isArchived = reader.bool();
                    continue;
                case 17:
                    if (tag !== 136) {
                        break;
                    }
                    message.isWebviewEnabled = reader.bool();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.owner = Redditor.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag === 72) {
                        message.categories.push(reader.int32());
                        continue;
                    }
                    if (tag === 74) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.categories.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.stats = AppStats.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.termsAndConditions = reader.string();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.privacyPolicy = reader.string();
                    continue;
                case 16:
                    if (tag !== 128) {
                        break;
                    }
                    message.defaultPool = reader.int32();
                    continue;
                case 18:
                    if (tag === 144) {
                        message.capabilities.push(reader.int32());
                        continue;
                    }
                    if (tag === 146) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.capabilities.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 19:
                    if (tag !== 152) {
                        break;
                    }
                    message.isDisabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            appAccount: isSet(object.appAccount) ? Redditor.fromJSON(object.appAccount) : undefined,
            isNsfw: isSet(object.isNsfw) ? globalThis.Boolean(object.isNsfw) : false,
            isDelisted: isSet(object.isDelisted) ? globalThis.Boolean(object.isDelisted) : false,
            isFirstParty: isSet(object.isFirstParty) ? globalThis.Boolean(object.isFirstParty) : false,
            isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
            isWebviewEnabled: isSet(object.isWebviewEnabled) ? globalThis.Boolean(object.isWebviewEnabled) : false,
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            owner: isSet(object.owner) ? Redditor.fromJSON(object.owner) : undefined,
            categories: globalThis.Array.isArray(object?.categories)
                ? object.categories.map((e) => categoriesFromJSON(e))
                : [],
            stats: isSet(object.stats) ? AppStats.fromJSON(object.stats) : undefined,
            termsAndConditions: isSet(object.termsAndConditions) ? globalThis.String(object.termsAndConditions) : "",
            privacyPolicy: isSet(object.privacyPolicy) ? globalThis.String(object.privacyPolicy) : "",
            defaultPool: isSet(object.defaultPool) ? computePoolFromJSON(object.defaultPool) : 0,
            capabilities: globalThis.Array.isArray(object?.capabilities)
                ? object.capabilities.map((e) => appCapabilityFromJSON(e))
                : [],
            isDisabled: isSet(object.isDisabled) ? globalThis.Boolean(object.isDisabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.slug !== "") {
            obj.slug = message.slug;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.appAccount !== undefined) {
            obj.appAccount = Redditor.toJSON(message.appAccount);
        }
        if (message.isNsfw !== false) {
            obj.isNsfw = message.isNsfw;
        }
        if (message.isDelisted !== false) {
            obj.isDelisted = message.isDelisted;
        }
        if (message.isFirstParty !== false) {
            obj.isFirstParty = message.isFirstParty;
        }
        if (message.isArchived !== false) {
            obj.isArchived = message.isArchived;
        }
        if (message.isWebviewEnabled !== false) {
            obj.isWebviewEnabled = message.isWebviewEnabled;
        }
        if (message.createdAt !== undefined) {
            obj.createdAt = message.createdAt.toISOString();
        }
        if (message.owner !== undefined) {
            obj.owner = Redditor.toJSON(message.owner);
        }
        if (message.categories?.length) {
            obj.categories = message.categories.map((e) => categoriesToJSON(e));
        }
        if (message.stats !== undefined) {
            obj.stats = AppStats.toJSON(message.stats);
        }
        if (message.termsAndConditions !== "") {
            obj.termsAndConditions = message.termsAndConditions;
        }
        if (message.privacyPolicy !== "") {
            obj.privacyPolicy = message.privacyPolicy;
        }
        if (message.defaultPool !== 0) {
            obj.defaultPool = computePoolToJSON(message.defaultPool);
        }
        if (message.capabilities?.length) {
            obj.capabilities = message.capabilities.map((e) => appCapabilityToJSON(e));
        }
        if (message.isDisabled !== false) {
            obj.isDisabled = message.isDisabled;
        }
        return obj;
    },
    create(base) {
        return AppInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppInfo();
        message.id = object.id ?? "";
        message.slug = object.slug ?? "";
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.appAccount = (object.appAccount !== undefined && object.appAccount !== null)
            ? Redditor.fromPartial(object.appAccount)
            : undefined;
        message.isNsfw = object.isNsfw ?? false;
        message.isDelisted = object.isDelisted ?? false;
        message.isFirstParty = object.isFirstParty ?? false;
        message.isArchived = object.isArchived ?? false;
        message.isWebviewEnabled = object.isWebviewEnabled ?? false;
        message.createdAt = object.createdAt ?? undefined;
        message.owner = (object.owner !== undefined && object.owner !== null)
            ? Redditor.fromPartial(object.owner)
            : undefined;
        message.categories = object.categories?.map((e) => e) || [];
        message.stats = (object.stats !== undefined && object.stats !== null)
            ? AppStats.fromPartial(object.stats)
            : undefined;
        message.termsAndConditions = object.termsAndConditions ?? "";
        message.privacyPolicy = object.privacyPolicy ?? "";
        message.defaultPool = object.defaultPool ?? 0;
        message.capabilities = object.capabilities?.map((e) => e) || [];
        message.isDisabled = object.isDisabled ?? false;
        return message;
    },
};
messageTypeRegistry.set(AppInfo.$type, AppInfo);
function createBaseMultipleAppInfos() {
    return { apps: [] };
}
export const MultipleAppInfos = {
    $type: "devvit.dev_portal.app.info.MultipleAppInfos",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.apps) {
            AppInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMultipleAppInfos();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.apps.push(AppInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => AppInfo.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.apps?.length) {
            obj.apps = message.apps.map((e) => AppInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return MultipleAppInfos.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMultipleAppInfos();
        message.apps = object.apps?.map((e) => AppInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(MultipleAppInfos.$type, MultipleAppInfos);
function createBaseAppStats() {
    return { installCount: 0 };
}
export const AppStats = {
    $type: "devvit.dev_portal.app.info.AppStats",
    encode(message, writer = _m0.Writer.create()) {
        if (message.installCount !== 0) {
            writer.uint32(8).int32(message.installCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppStats();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.installCount = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { installCount: isSet(object.installCount) ? globalThis.Number(object.installCount) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.installCount !== 0) {
            obj.installCount = Math.round(message.installCount);
        }
        return obj;
    },
    create(base) {
        return AppStats.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppStats();
        message.installCount = object.installCount ?? 0;
        return message;
    },
};
messageTypeRegistry.set(AppStats.$type, AppStats);
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
