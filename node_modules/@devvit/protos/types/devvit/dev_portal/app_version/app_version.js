/**
 * #app_version.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Int32Value, StringValue } from "../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
import { Bundle } from "../../plugin/buildpack/buildpack_common.js";
import { LinkedBundle } from "../../runtime/bundle.js";
import { ActorTypeInfo } from "../actor/actor_type.js";
import { AppInfo } from "../app/info/app_info.js";
import { InstallationInfo } from "../installation/installation.js";
import { AppVersionInfo, computePoolFromJSON, computePoolToJSON, installationTypeFromJSON, installationTypeToJSON, OptionalVersionVisibility, versionVisibilityFromJSON, versionVisibilityToJSON, } from "./info/app_version_info.js";
function createBaseAppVersionCreationRequest() {
    return {
        appId: "",
        visibility: 0,
        validInstallTypes: [],
        majorVersion: 0,
        minorVersion: 0,
        patchVersion: 0,
        prereleaseVersion: undefined,
        actorBundles: [],
        about: "",
    };
}
export const AppVersionCreationRequest = {
    $type: "devvit.dev_portal.app_version.AppVersionCreationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appId !== "") {
            writer.uint32(10).string(message.appId);
        }
        if (message.visibility !== 0) {
            writer.uint32(16).int32(message.visibility);
        }
        writer.uint32(26).fork();
        for (const v of message.validInstallTypes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.majorVersion !== 0) {
            writer.uint32(32).int32(message.majorVersion);
        }
        if (message.minorVersion !== 0) {
            writer.uint32(40).int32(message.minorVersion);
        }
        if (message.patchVersion !== 0) {
            writer.uint32(48).int32(message.patchVersion);
        }
        if (message.prereleaseVersion !== undefined) {
            Int32Value.encode({ value: message.prereleaseVersion }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.actorBundles) {
            Bundle.encode(v, writer.uint32(66).fork()).ldelim();
        }
        if (message.about !== "") {
            writer.uint32(74).string(message.about);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppVersionCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.visibility = reader.int32();
                    continue;
                case 3:
                    if (tag === 24) {
                        message.validInstallTypes.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.validInstallTypes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.majorVersion = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.minorVersion = reader.int32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.patchVersion = reader.int32();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.prereleaseVersion = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.actorBundles.push(Bundle.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.about = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
            visibility: isSet(object.visibility) ? versionVisibilityFromJSON(object.visibility) : 0,
            validInstallTypes: globalThis.Array.isArray(object?.validInstallTypes)
                ? object.validInstallTypes.map((e) => installationTypeFromJSON(e))
                : [],
            majorVersion: isSet(object.majorVersion) ? globalThis.Number(object.majorVersion) : 0,
            minorVersion: isSet(object.minorVersion) ? globalThis.Number(object.minorVersion) : 0,
            patchVersion: isSet(object.patchVersion) ? globalThis.Number(object.patchVersion) : 0,
            prereleaseVersion: isSet(object.prereleaseVersion) ? Number(object.prereleaseVersion) : undefined,
            actorBundles: globalThis.Array.isArray(object?.actorBundles)
                ? object.actorBundles.map((e) => Bundle.fromJSON(e))
                : [],
            about: isSet(object.about) ? globalThis.String(object.about) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appId !== "") {
            obj.appId = message.appId;
        }
        if (message.visibility !== 0) {
            obj.visibility = versionVisibilityToJSON(message.visibility);
        }
        if (message.validInstallTypes?.length) {
            obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
        }
        if (message.majorVersion !== 0) {
            obj.majorVersion = Math.round(message.majorVersion);
        }
        if (message.minorVersion !== 0) {
            obj.minorVersion = Math.round(message.minorVersion);
        }
        if (message.patchVersion !== 0) {
            obj.patchVersion = Math.round(message.patchVersion);
        }
        if (message.prereleaseVersion !== undefined) {
            obj.prereleaseVersion = message.prereleaseVersion;
        }
        if (message.actorBundles?.length) {
            obj.actorBundles = message.actorBundles.map((e) => Bundle.toJSON(e));
        }
        if (message.about !== "") {
            obj.about = message.about;
        }
        return obj;
    },
    create(base) {
        return AppVersionCreationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppVersionCreationRequest();
        message.appId = object.appId ?? "";
        message.visibility = object.visibility ?? 0;
        message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
        message.majorVersion = object.majorVersion ?? 0;
        message.minorVersion = object.minorVersion ?? 0;
        message.patchVersion = object.patchVersion ?? 0;
        message.prereleaseVersion = object.prereleaseVersion ?? undefined;
        message.actorBundles = object.actorBundles?.map((e) => Bundle.fromPartial(e)) || [];
        message.about = object.about ?? "";
        return message;
    },
};
messageTypeRegistry.set(AppVersionCreationRequest.$type, AppVersionCreationRequest);
function createBaseAppSlugAndVersion() {
    return { slug: "", version: "" };
}
export const AppSlugAndVersion = {
    $type: "devvit.dev_portal.app_version.AppSlugAndVersion",
    encode(message, writer = _m0.Writer.create()) {
        if (message.slug !== "") {
            writer.uint32(10).string(message.slug);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppSlugAndVersion();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.slug = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.slug !== "") {
            obj.slug = message.slug;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        return obj;
    },
    create(base) {
        return AppSlugAndVersion.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppSlugAndVersion();
        message.slug = object.slug ?? "";
        message.version = object.version ?? "";
        return message;
    },
};
messageTypeRegistry.set(AppSlugAndVersion.$type, AppSlugAndVersion);
function createBaseAppVersionUpdateRequest() {
    return { id: "", visibility: undefined, validInstallTypes: [], about: undefined, pool: 0 };
}
export const AppVersionUpdateRequest = {
    $type: "devvit.dev_portal.app_version.AppVersionUpdateRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.visibility !== undefined) {
            OptionalVersionVisibility.encode(message.visibility, writer.uint32(18).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.validInstallTypes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.about !== undefined) {
            StringValue.encode({ value: message.about }, writer.uint32(42).fork()).ldelim();
        }
        if (message.pool !== 0) {
            writer.uint32(48).int32(message.pool);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppVersionUpdateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.visibility = OptionalVersionVisibility.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag === 32) {
                        message.validInstallTypes.push(reader.int32());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.validInstallTypes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.about = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.pool = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            visibility: isSet(object.visibility) ? OptionalVersionVisibility.fromJSON(object.visibility) : undefined,
            validInstallTypes: globalThis.Array.isArray(object?.validInstallTypes)
                ? object.validInstallTypes.map((e) => installationTypeFromJSON(e))
                : [],
            about: isSet(object.about) ? String(object.about) : undefined,
            pool: isSet(object.pool) ? computePoolFromJSON(object.pool) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.visibility !== undefined) {
            obj.visibility = OptionalVersionVisibility.toJSON(message.visibility);
        }
        if (message.validInstallTypes?.length) {
            obj.validInstallTypes = message.validInstallTypes.map((e) => installationTypeToJSON(e));
        }
        if (message.about !== undefined) {
            obj.about = message.about;
        }
        if (message.pool !== 0) {
            obj.pool = computePoolToJSON(message.pool);
        }
        return obj;
    },
    create(base) {
        return AppVersionUpdateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppVersionUpdateRequest();
        message.id = object.id ?? "";
        message.visibility = (object.visibility !== undefined && object.visibility !== null)
            ? OptionalVersionVisibility.fromPartial(object.visibility)
            : undefined;
        message.validInstallTypes = object.validInstallTypes?.map((e) => e) || [];
        message.about = object.about ?? undefined;
        message.pool = object.pool ?? 0;
        return message;
    },
};
messageTypeRegistry.set(AppVersionUpdateRequest.$type, AppVersionUpdateRequest);
function createBaseValidInstallLocationsRequest() {
    return { id: "", pageInfo: [] };
}
export const ValidInstallLocationsRequest = {
    $type: "devvit.dev_portal.app_version.ValidInstallLocationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (const v of message.pageInfo) {
            InstallLocationPageInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidInstallLocationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pageInfo.push(InstallLocationPageInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            pageInfo: globalThis.Array.isArray(object?.pageInfo)
                ? object.pageInfo.map((e) => InstallLocationPageInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.pageInfo?.length) {
            obj.pageInfo = message.pageInfo.map((e) => InstallLocationPageInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ValidInstallLocationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidInstallLocationsRequest();
        message.id = object.id ?? "";
        message.pageInfo = object.pageInfo?.map((e) => InstallLocationPageInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ValidInstallLocationsRequest.$type, ValidInstallLocationsRequest);
function createBaseInstallLocationPageInfo() {
    return { type: 0, before: undefined, after: undefined };
}
export const InstallLocationPageInfo = {
    $type: "devvit.dev_portal.app_version.InstallLocationPageInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.before !== undefined) {
            writer.uint32(18).string(message.before);
        }
        if (message.after !== undefined) {
            writer.uint32(26).string(message.after);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationPageInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.after = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            before: isSet(object.before) ? globalThis.String(object.before) : undefined,
            after: isSet(object.after) ? globalThis.String(object.after) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = installationTypeToJSON(message.type);
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        return obj;
    },
    create(base) {
        return InstallLocationPageInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallLocationPageInfo();
        message.type = object.type ?? 0;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(InstallLocationPageInfo.$type, InstallLocationPageInfo);
function createBaseFullAppVersionInfo() {
    return { appVersion: undefined, app: undefined, actorTypes: [], installations: [] };
}
export const FullAppVersionInfo = {
    $type: "devvit.dev_portal.app_version.FullAppVersionInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appVersion !== undefined) {
            AppVersionInfo.encode(message.appVersion, writer.uint32(10).fork()).ldelim();
        }
        if (message.app !== undefined) {
            AppInfo.encode(message.app, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.actorTypes) {
            ActorTypeInfo.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.installations) {
            InstallationInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFullAppVersionInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appVersion = AppVersionInfo.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.app = AppInfo.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.actorTypes.push(ActorTypeInfo.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.installations.push(InstallationInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appVersion: isSet(object.appVersion) ? AppVersionInfo.fromJSON(object.appVersion) : undefined,
            app: isSet(object.app) ? AppInfo.fromJSON(object.app) : undefined,
            actorTypes: globalThis.Array.isArray(object?.actorTypes)
                ? object.actorTypes.map((e) => ActorTypeInfo.fromJSON(e))
                : [],
            installations: globalThis.Array.isArray(object?.installations)
                ? object.installations.map((e) => InstallationInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appVersion !== undefined) {
            obj.appVersion = AppVersionInfo.toJSON(message.appVersion);
        }
        if (message.app !== undefined) {
            obj.app = AppInfo.toJSON(message.app);
        }
        if (message.actorTypes?.length) {
            obj.actorTypes = message.actorTypes.map((e) => ActorTypeInfo.toJSON(e));
        }
        if (message.installations?.length) {
            obj.installations = message.installations.map((e) => InstallationInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FullAppVersionInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFullAppVersionInfo();
        message.appVersion = (object.appVersion !== undefined && object.appVersion !== null)
            ? AppVersionInfo.fromPartial(object.appVersion)
            : undefined;
        message.app = (object.app !== undefined && object.app !== null) ? AppInfo.fromPartial(object.app) : undefined;
        message.actorTypes = object.actorTypes?.map((e) => ActorTypeInfo.fromPartial(e)) || [];
        message.installations = object.installations?.map((e) => InstallationInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(FullAppVersionInfo.$type, FullAppVersionInfo);
function createBaseValidInstallLocationsResponse() {
    return { locations: [] };
}
export const ValidInstallLocationsResponse = {
    $type: "devvit.dev_portal.app_version.ValidInstallLocationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.locations) {
            InstallLocationInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidInstallLocationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.locations.push(InstallLocationInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            locations: globalThis.Array.isArray(object?.locations)
                ? object.locations.map((e) => InstallLocationInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.locations?.length) {
            obj.locations = message.locations.map((e) => InstallLocationInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ValidInstallLocationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidInstallLocationsResponse();
        message.locations = object.locations?.map((e) => InstallLocationInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ValidInstallLocationsResponse.$type, ValidInstallLocationsResponse);
function createBaseInstallLocationInfo() {
    return { type: 0, locations: [], pageInfo: undefined };
}
export const InstallLocationInfo = {
    $type: "devvit.dev_portal.app_version.InstallLocationInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        for (const v of message.locations) {
            InstallLocationDetails.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pageInfo !== undefined) {
            PageInfo.encode(message.pageInfo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.locations.push(InstallLocationDetails.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.pageInfo = PageInfo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? installationTypeFromJSON(object.type) : 0,
            locations: globalThis.Array.isArray(object?.locations)
                ? object.locations.map((e) => InstallLocationDetails.fromJSON(e))
                : [],
            pageInfo: isSet(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = installationTypeToJSON(message.type);
        }
        if (message.locations?.length) {
            obj.locations = message.locations.map((e) => InstallLocationDetails.toJSON(e));
        }
        if (message.pageInfo !== undefined) {
            obj.pageInfo = PageInfo.toJSON(message.pageInfo);
        }
        return obj;
    },
    create(base) {
        return InstallLocationInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallLocationInfo();
        message.type = object.type ?? 0;
        message.locations = object.locations?.map((e) => InstallLocationDetails.fromPartial(e)) || [];
        message.pageInfo = (object.pageInfo !== undefined && object.pageInfo !== null)
            ? PageInfo.fromPartial(object.pageInfo)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(InstallLocationInfo.$type, InstallLocationInfo);
function createBaseInstallLocationDetails() {
    return { thingId: "", name: "", existingInstallId: undefined, icon: undefined };
}
export const InstallLocationDetails = {
    $type: "devvit.dev_portal.app_version.InstallLocationDetails",
    encode(message, writer = _m0.Writer.create()) {
        if (message.thingId !== "") {
            writer.uint32(10).string(message.thingId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.existingInstallId !== undefined) {
            StringValue.encode({ value: message.existingInstallId }, writer.uint32(26).fork()).ldelim();
        }
        if (message.icon !== undefined) {
            StringValue.encode({ value: message.icon }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallLocationDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.thingId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.existingInstallId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.icon = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            thingId: isSet(object.thingId) ? globalThis.String(object.thingId) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            existingInstallId: isSet(object.existingInstallId) ? String(object.existingInstallId) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.thingId !== "") {
            obj.thingId = message.thingId;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.existingInstallId !== undefined) {
            obj.existingInstallId = message.existingInstallId;
        }
        if (message.icon !== undefined) {
            obj.icon = message.icon;
        }
        return obj;
    },
    create(base) {
        return InstallLocationDetails.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallLocationDetails();
        message.thingId = object.thingId ?? "";
        message.name = object.name ?? "";
        message.existingInstallId = object.existingInstallId ?? undefined;
        message.icon = object.icon ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(InstallLocationDetails.$type, InstallLocationDetails);
function createBasePageInfo() {
    return { hasNextPage: false, hasPreviousPage: false, startCursor: "", endCursor: "" };
}
export const PageInfo = {
    $type: "devvit.dev_portal.app_version.PageInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.hasNextPage !== false) {
            writer.uint32(8).bool(message.hasNextPage);
        }
        if (message.hasPreviousPage !== false) {
            writer.uint32(16).bool(message.hasPreviousPage);
        }
        if (message.startCursor !== "") {
            writer.uint32(26).string(message.startCursor);
        }
        if (message.endCursor !== "") {
            writer.uint32(34).string(message.endCursor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.hasNextPage = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.hasPreviousPage = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.startCursor = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.endCursor = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hasNextPage: isSet(object.hasNextPage) ? globalThis.Boolean(object.hasNextPage) : false,
            hasPreviousPage: isSet(object.hasPreviousPage) ? globalThis.Boolean(object.hasPreviousPage) : false,
            startCursor: isSet(object.startCursor) ? globalThis.String(object.startCursor) : "",
            endCursor: isSet(object.endCursor) ? globalThis.String(object.endCursor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hasNextPage !== false) {
            obj.hasNextPage = message.hasNextPage;
        }
        if (message.hasPreviousPage !== false) {
            obj.hasPreviousPage = message.hasPreviousPage;
        }
        if (message.startCursor !== "") {
            obj.startCursor = message.startCursor;
        }
        if (message.endCursor !== "") {
            obj.endCursor = message.endCursor;
        }
        return obj;
    },
    create(base) {
        return PageInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePageInfo();
        message.hasNextPage = object.hasNextPage ?? false;
        message.hasPreviousPage = object.hasPreviousPage ?? false;
        message.startCursor = object.startCursor ?? "";
        message.endCursor = object.endCursor ?? "";
        return message;
    },
};
messageTypeRegistry.set(PageInfo.$type, PageInfo);
function createBaseGetAppVersionBundleResponse() {
    return { actorBundles: [] };
}
export const GetAppVersionBundleResponse = {
    $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.actorBundles) {
            GetAppVersionBundleResponse_BundleInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppVersionBundleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.actorBundles.push(GetAppVersionBundleResponse_BundleInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            actorBundles: globalThis.Array.isArray(object?.actorBundles)
                ? object.actorBundles.map((e) => GetAppVersionBundleResponse_BundleInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actorBundles?.length) {
            obj.actorBundles = message.actorBundles.map((e) => GetAppVersionBundleResponse_BundleInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetAppVersionBundleResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetAppVersionBundleResponse();
        message.actorBundles = object.actorBundles?.map((e) => GetAppVersionBundleResponse_BundleInfo.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(GetAppVersionBundleResponse.$type, GetAppVersionBundleResponse);
function createBaseGetAppVersionBundleResponse_BundleInfo() {
    return { actor: "", bundle: undefined };
}
export const GetAppVersionBundleResponse_BundleInfo = {
    $type: "devvit.dev_portal.app_version.GetAppVersionBundleResponse.BundleInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.actor !== "") {
            writer.uint32(10).string(message.actor);
        }
        if (message.bundle !== undefined) {
            LinkedBundle.encode(message.bundle, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppVersionBundleResponse_BundleInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.actor = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bundle = LinkedBundle.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
            bundle: isSet(object.bundle) ? LinkedBundle.fromJSON(object.bundle) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.actor !== "") {
            obj.actor = message.actor;
        }
        if (message.bundle !== undefined) {
            obj.bundle = LinkedBundle.toJSON(message.bundle);
        }
        return obj;
    },
    create(base) {
        return GetAppVersionBundleResponse_BundleInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetAppVersionBundleResponse_BundleInfo();
        message.actor = object.actor ?? "";
        message.bundle = (object.bundle !== undefined && object.bundle !== null)
            ? LinkedBundle.fromPartial(object.bundle)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetAppVersionBundleResponse_BundleInfo.$type, GetAppVersionBundleResponse_BundleInfo);
function isSet(value) {
    return value !== null && value !== undefined;
}
