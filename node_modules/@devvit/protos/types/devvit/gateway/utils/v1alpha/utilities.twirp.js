import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { CacheContextActionsRequest, PurgeResult, AccessKeyPurgeRequest, InstallationsPurgeRequest, InstallationPurgeRequest, AppVersionPurgeRequest, AppPurgeRequest, AcceptInviteRequest, AcceptInviteResponse, } from './utilities.js';
export var CacheUtilsMethod;
(function (CacheUtilsMethod) {
    CacheUtilsMethod["CacheContextActionsInRuntimeDb"] = "CacheContextActionsInRuntimeDb";
    CacheUtilsMethod["PurgeAccessKey"] = "PurgeAccessKey";
    CacheUtilsMethod["PurgeInstallations"] = "PurgeInstallations";
    CacheUtilsMethod["PurgeInstallation"] = "PurgeInstallation";
    CacheUtilsMethod["PurgeAppVersion"] = "PurgeAppVersion";
    CacheUtilsMethod["PurgeApp"] = "PurgeApp";
})(CacheUtilsMethod || (CacheUtilsMethod = {}));
export const CacheUtilsMethodList = [
    CacheUtilsMethod.CacheContextActionsInRuntimeDb,
    CacheUtilsMethod.PurgeAccessKey,
    CacheUtilsMethod.PurgeInstallations,
    CacheUtilsMethod.PurgeInstallation,
    CacheUtilsMethod.PurgeAppVersion,
    CacheUtilsMethod.PurgeApp,
];
export function createCacheUtilsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.gateway.utils.v1alpha',
        serviceName: 'CacheUtils',
        methodList: CacheUtilsMethodList,
        matchRoute: matchCacheUtilsRoute,
    });
}
function matchCacheUtilsRoute(method, events) {
    switch (method) {
        case 'CacheContextActionsInRuntimeDb':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CacheContextActionsInRuntimeDb' };
                await events.onMatch(ctx);
                return handleCacheUtilsCacheContextActionsInRuntimeDbRequest(ctx, service, data, interceptors);
            };
        case 'PurgeAccessKey':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PurgeAccessKey' };
                await events.onMatch(ctx);
                return handleCacheUtilsPurgeAccessKeyRequest(ctx, service, data, interceptors);
            };
        case 'PurgeInstallations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PurgeInstallations' };
                await events.onMatch(ctx);
                return handleCacheUtilsPurgeInstallationsRequest(ctx, service, data, interceptors);
            };
        case 'PurgeInstallation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PurgeInstallation' };
                await events.onMatch(ctx);
                return handleCacheUtilsPurgeInstallationRequest(ctx, service, data, interceptors);
            };
        case 'PurgeAppVersion':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PurgeAppVersion' };
                await events.onMatch(ctx);
                return handleCacheUtilsPurgeAppVersionRequest(ctx, service, data, interceptors);
            };
        case 'PurgeApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PurgeApp' };
                await events.onMatch(ctx);
                return handleCacheUtilsPurgeAppRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsCacheContextActionsInRuntimeDbRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsCacheContextActionsInRuntimeDbJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsCacheContextActionsInRuntimeDbProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsPurgeAccessKeyRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsPurgeAccessKeyJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsPurgeAccessKeyProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsPurgeInstallationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsPurgeInstallationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsPurgeInstallationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsPurgeInstallationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsPurgeInstallationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsPurgeInstallationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsPurgeAppVersionRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsPurgeAppVersionJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsPurgeAppVersionProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleCacheUtilsPurgeAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleCacheUtilsPurgeAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleCacheUtilsPurgeAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleCacheUtilsCacheContextActionsInRuntimeDbJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CacheContextActionsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CacheContextActionsInRuntimeDb(ctx, inputReq);
        });
    }
    else {
        response = await service.CacheContextActionsInRuntimeDb(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsPurgeAccessKeyJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AccessKeyPurgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeAccessKey(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeAccessKey(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsPurgeInstallationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationsPurgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeInstallations(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeInstallations(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsPurgeInstallationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationPurgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeInstallation(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeInstallation(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsPurgeAppVersionJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppVersionPurgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeAppVersion(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeAppVersion(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsPurgeAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AppPurgeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeApp(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeApp(ctx, request);
    }
    return JSON.stringify(PurgeResult.toJSON(response));
}
async function handleCacheUtilsCacheContextActionsInRuntimeDbProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CacheContextActionsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CacheContextActionsInRuntimeDb(ctx, inputReq);
        });
    }
    else {
        response = await service.CacheContextActionsInRuntimeDb(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
async function handleCacheUtilsPurgeAccessKeyProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AccessKeyPurgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeAccessKey(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeAccessKey(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
async function handleCacheUtilsPurgeInstallationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationsPurgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeInstallations(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeInstallations(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
async function handleCacheUtilsPurgeInstallationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationPurgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeInstallation(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeInstallation(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
async function handleCacheUtilsPurgeAppVersionProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppVersionPurgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeAppVersion(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeAppVersion(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
async function handleCacheUtilsPurgeAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AppPurgeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PurgeApp(ctx, inputReq);
        });
    }
    else {
        response = await service.PurgeApp(ctx, request);
    }
    return Buffer.from(PurgeResult.encode(response).finish());
}
export var ModInviteUtilsMethod;
(function (ModInviteUtilsMethod) {
    ModInviteUtilsMethod["AcceptInvite"] = "AcceptInvite";
})(ModInviteUtilsMethod || (ModInviteUtilsMethod = {}));
export const ModInviteUtilsMethodList = [ModInviteUtilsMethod.AcceptInvite];
export function createModInviteUtilsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.gateway.utils.v1alpha',
        serviceName: 'ModInviteUtils',
        methodList: ModInviteUtilsMethodList,
        matchRoute: matchModInviteUtilsRoute,
    });
}
function matchModInviteUtilsRoute(method, events) {
    switch (method) {
        case 'AcceptInvite':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AcceptInvite' };
                await events.onMatch(ctx);
                return handleModInviteUtilsAcceptInviteRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModInviteUtilsAcceptInviteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModInviteUtilsAcceptInviteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModInviteUtilsAcceptInviteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleModInviteUtilsAcceptInviteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AcceptInviteRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptInvite(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptInvite(ctx, request);
    }
    return JSON.stringify(AcceptInviteResponse.toJSON(response));
}
async function handleModInviteUtilsAcceptInviteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AcceptInviteRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptInvite(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptInvite(ctx, request);
    }
    return Buffer.from(AcceptInviteResponse.encode(response).finish());
}
