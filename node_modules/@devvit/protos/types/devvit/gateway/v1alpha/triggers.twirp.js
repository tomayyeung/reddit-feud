import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { TriggerEvent } from '../../triggers/v1alpha/triggers.js';
import { TriggerResponse, TriggerFanOutResponse, TriggerInvocation, } from './triggers.js';
import { Empty } from '../../../google/protobuf/empty.js';
import { InstallationInfo } from '../../dev_portal/installation/installation.js';
export var TriggersMethod;
(function (TriggersMethod) {
    TriggersMethod["OnTrigger"] = "OnTrigger";
    TriggersMethod["OnFanOut"] = "OnFanOut";
    TriggersMethod["OnInvoke"] = "OnInvoke";
    TriggersMethod["OnInstall"] = "OnInstall";
    TriggersMethod["OnUninstall"] = "OnUninstall";
    TriggersMethod["OnInstallChanged"] = "OnInstallChanged";
})(TriggersMethod || (TriggersMethod = {}));
export const TriggersMethodList = [
    TriggersMethod.OnTrigger,
    TriggersMethod.OnFanOut,
    TriggersMethod.OnInvoke,
    TriggersMethod.OnInstall,
    TriggersMethod.OnUninstall,
    TriggersMethod.OnInstallChanged,
];
export function createTriggersServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.gateway.v1alpha',
        serviceName: 'Triggers',
        methodList: TriggersMethodList,
        matchRoute: matchTriggersRoute,
    });
}
function matchTriggersRoute(method, events) {
    switch (method) {
        case 'OnTrigger':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnTrigger' };
                await events.onMatch(ctx);
                return handleTriggersOnTriggerRequest(ctx, service, data, interceptors);
            };
        case 'OnFanOut':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnFanOut' };
                await events.onMatch(ctx);
                return handleTriggersOnFanOutRequest(ctx, service, data, interceptors);
            };
        case 'OnInvoke':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnInvoke' };
                await events.onMatch(ctx);
                return handleTriggersOnInvokeRequest(ctx, service, data, interceptors);
            };
        case 'OnInstall':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnInstall' };
                await events.onMatch(ctx);
                return handleTriggersOnInstallRequest(ctx, service, data, interceptors);
            };
        case 'OnUninstall':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnUninstall' };
                await events.onMatch(ctx);
                return handleTriggersOnUninstallRequest(ctx, service, data, interceptors);
            };
        case 'OnInstallChanged':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OnInstallChanged' };
                await events.onMatch(ctx);
                return handleTriggersOnInstallChangedRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnTriggerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnTriggerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnTriggerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnFanOutRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnFanOutJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnFanOutProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnInvokeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnInvokeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnInvokeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnInstallRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnInstallJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnInstallProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnUninstallRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnUninstallJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnUninstallProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleTriggersOnInstallChangedRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleTriggersOnInstallChangedJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleTriggersOnInstallChangedProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleTriggersOnTriggerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TriggerEvent.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnTrigger(ctx, inputReq);
        });
    }
    else {
        response = await service.OnTrigger(ctx, request);
    }
    return JSON.stringify(TriggerResponse.toJSON(response));
}
async function handleTriggersOnFanOutJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TriggerEvent.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnFanOut(ctx, inputReq);
        });
    }
    else {
        response = await service.OnFanOut(ctx, request);
    }
    return JSON.stringify(TriggerFanOutResponse.toJSON(response));
}
async function handleTriggersOnInvokeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TriggerInvocation.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInvoke(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInvoke(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleTriggersOnInstallJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationInfo.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInstall(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleTriggersOnUninstallJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationInfo.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnUninstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnUninstall(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleTriggersOnInstallChangedJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationInfo.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInstallChanged(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInstallChanged(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleTriggersOnTriggerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TriggerEvent.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnTrigger(ctx, inputReq);
        });
    }
    else {
        response = await service.OnTrigger(ctx, request);
    }
    return Buffer.from(TriggerResponse.encode(response).finish());
}
async function handleTriggersOnFanOutProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TriggerEvent.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnFanOut(ctx, inputReq);
        });
    }
    else {
        response = await service.OnFanOut(ctx, request);
    }
    return Buffer.from(TriggerFanOutResponse.encode(response).finish());
}
async function handleTriggersOnInvokeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TriggerInvocation.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInvoke(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInvoke(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleTriggersOnInstallProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationInfo.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInstall(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleTriggersOnUninstallProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationInfo.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnUninstall(ctx, inputReq);
        });
    }
    else {
        response = await service.OnUninstall(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleTriggersOnInstallChangedProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationInfo.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OnInstallChanged(ctx, inputReq);
        });
    }
    else {
        response = await service.OnInstallChanged(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
