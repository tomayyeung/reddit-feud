/**
 * #order.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
import { environmentFromJSON, environmentToJSON } from "./common.js";
import { Product } from "./product.js";
export var OrderStatus;
(function (OrderStatus) {
    OrderStatus[OrderStatus["ORDER_STATUS_UNSPECIFIED"] = 0] = "ORDER_STATUS_UNSPECIFIED";
    OrderStatus[OrderStatus["ORDER_STATUS_NEW"] = 1] = "ORDER_STATUS_NEW";
    OrderStatus[OrderStatus["ORDER_STATUS_CREATED"] = 2] = "ORDER_STATUS_CREATED";
    OrderStatus[OrderStatus["ORDER_STATUS_PAID"] = 3] = "ORDER_STATUS_PAID";
    OrderStatus[OrderStatus["ORDER_STATUS_DELIVERED"] = 4] = "ORDER_STATUS_DELIVERED";
    OrderStatus[OrderStatus["ORDER_STATUS_CANCELED"] = 5] = "ORDER_STATUS_CANCELED";
    OrderStatus[OrderStatus["ORDER_STATUS_REVERTED"] = 6] = "ORDER_STATUS_REVERTED";
    OrderStatus[OrderStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderStatus || (OrderStatus = {}));
export function orderStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "ORDER_STATUS_UNSPECIFIED":
            return OrderStatus.ORDER_STATUS_UNSPECIFIED;
        case 1:
        case "ORDER_STATUS_NEW":
            return OrderStatus.ORDER_STATUS_NEW;
        case 2:
        case "ORDER_STATUS_CREATED":
            return OrderStatus.ORDER_STATUS_CREATED;
        case 3:
        case "ORDER_STATUS_PAID":
            return OrderStatus.ORDER_STATUS_PAID;
        case 4:
        case "ORDER_STATUS_DELIVERED":
            return OrderStatus.ORDER_STATUS_DELIVERED;
        case 5:
        case "ORDER_STATUS_CANCELED":
            return OrderStatus.ORDER_STATUS_CANCELED;
        case 6:
        case "ORDER_STATUS_REVERTED":
            return OrderStatus.ORDER_STATUS_REVERTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderStatus.UNRECOGNIZED;
    }
}
export function orderStatusToJSON(object) {
    switch (object) {
        case OrderStatus.ORDER_STATUS_UNSPECIFIED:
            return 0;
        case OrderStatus.ORDER_STATUS_NEW:
            return 1;
        case OrderStatus.ORDER_STATUS_CREATED:
            return 2;
        case OrderStatus.ORDER_STATUS_PAID:
            return 3;
        case OrderStatus.ORDER_STATUS_DELIVERED:
            return 4;
        case OrderStatus.ORDER_STATUS_CANCELED:
            return 5;
        case OrderStatus.ORDER_STATUS_REVERTED:
            return 6;
        case OrderStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseOrder() {
    return { id: "", status: 0, createdAt: undefined, updatedAt: undefined, products: [], environment: 0, metadata: {} };
}
export const Order = {
    $type: "devvit.payments.v1alpha.Order",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        if (message.createdAt !== undefined) {
            Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).ldelim();
        }
        if (message.updatedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.products) {
            Product.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.environment !== 0) {
            writer.uint32(64).int32(message.environment);
        }
        Object.entries(message.metadata).forEach(([key, value]) => {
            Order_MetadataEntry.encode({ key: key, value }, writer.uint32(8010).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.products.push(Product.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.environment = reader.int32();
                    continue;
                case 1001:
                    if (tag !== 8010) {
                        break;
                    }
                    const entry1001 = Order_MetadataEntry.decode(reader, reader.uint32());
                    if (entry1001.value !== undefined) {
                        message.metadata[entry1001.key] = entry1001.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
            products: globalThis.Array.isArray(object?.products) ? object.products.map((e) => Product.fromJSON(e)) : [],
            environment: isSet(object.environment) ? environmentFromJSON(object.environment) : 0,
            metadata: isObject(object.metadata)
                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.status !== 0) {
            obj.status = orderStatusToJSON(message.status);
        }
        if (message.createdAt !== undefined) {
            obj.createdAt = message.createdAt.toISOString();
        }
        if (message.updatedAt !== undefined) {
            obj.updatedAt = message.updatedAt.toISOString();
        }
        if (message.products?.length) {
            obj.products = message.products.map((e) => Product.toJSON(e));
        }
        if (message.environment !== 0) {
            obj.environment = environmentToJSON(message.environment);
        }
        if (message.metadata) {
            const entries = Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Order.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrder();
        message.id = object.id ?? "";
        message.status = object.status ?? 0;
        message.createdAt = object.createdAt ?? undefined;
        message.updatedAt = object.updatedAt ?? undefined;
        message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
        message.environment = object.environment ?? 0;
        message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(Order.$type, Order);
function createBaseOrder_MetadataEntry() {
    return { key: "", value: "" };
}
export const Order_MetadataEntry = {
    $type: "devvit.payments.v1alpha.Order.MetadataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrder_MetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Order_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOrder_MetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(Order_MetadataEntry.$type, Order_MetadataEntry);
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
