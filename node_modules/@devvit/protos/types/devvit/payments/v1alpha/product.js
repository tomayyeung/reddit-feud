/**
 * #product.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
import { environmentFromJSON, environmentToJSON } from "./common.js";
export var Currency;
(function (Currency) {
    Currency[Currency["CURRENCY_UNSPECIFIED"] = 0] = "CURRENCY_UNSPECIFIED";
    /** GOLD - Reddit internal currency */
    Currency[Currency["GOLD"] = 200] = "GOLD";
    Currency[Currency["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Currency || (Currency = {}));
export function currencyFromJSON(object) {
    switch (object) {
        case 0:
        case "CURRENCY_UNSPECIFIED":
            return Currency.CURRENCY_UNSPECIFIED;
        case 200:
        case "GOLD":
            return Currency.GOLD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Currency.UNRECOGNIZED;
    }
}
export function currencyToJSON(object) {
    switch (object) {
        case Currency.CURRENCY_UNSPECIFIED:
            return 0;
        case Currency.GOLD:
            return 200;
        case Currency.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var AccountingType;
(function (AccountingType) {
    AccountingType[AccountingType["ACCOUNTING_TYPE_UNSPECIFIED"] = 0] = "ACCOUNTING_TYPE_UNSPECIFIED";
    /** ACCOUNTING_TYPE_INSTANT - Used immediately as it is purchased. */
    AccountingType[AccountingType["ACCOUNTING_TYPE_INSTANT"] = 1] = "ACCOUNTING_TYPE_INSTANT";
    /** ACCOUNTING_TYPE_DURABLE - It grants access indefinitely. */
    AccountingType[AccountingType["ACCOUNTING_TYPE_DURABLE"] = 2] = "ACCOUNTING_TYPE_DURABLE";
    /** ACCOUNTING_TYPE_CONSUMABLE - User can use the good at any time in the future but it is gone once it's used. */
    AccountingType[AccountingType["ACCOUNTING_TYPE_CONSUMABLE"] = 3] = "ACCOUNTING_TYPE_CONSUMABLE";
    /** ACCOUNTING_TYPE_VALID_FOR_1D - Consumed over a fixed period of time. */
    AccountingType[AccountingType["ACCOUNTING_TYPE_VALID_FOR_1D"] = 4] = "ACCOUNTING_TYPE_VALID_FOR_1D";
    AccountingType[AccountingType["ACCOUNTING_TYPE_VALID_FOR_7D"] = 5] = "ACCOUNTING_TYPE_VALID_FOR_7D";
    AccountingType[AccountingType["ACCOUNTING_TYPE_VALID_FOR_30D"] = 6] = "ACCOUNTING_TYPE_VALID_FOR_30D";
    AccountingType[AccountingType["ACCOUNTING_TYPE_VALID_FOR_1Y"] = 7] = "ACCOUNTING_TYPE_VALID_FOR_1Y";
    AccountingType[AccountingType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountingType || (AccountingType = {}));
export function accountingTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ACCOUNTING_TYPE_UNSPECIFIED":
            return AccountingType.ACCOUNTING_TYPE_UNSPECIFIED;
        case 1:
        case "ACCOUNTING_TYPE_INSTANT":
            return AccountingType.ACCOUNTING_TYPE_INSTANT;
        case 2:
        case "ACCOUNTING_TYPE_DURABLE":
            return AccountingType.ACCOUNTING_TYPE_DURABLE;
        case 3:
        case "ACCOUNTING_TYPE_CONSUMABLE":
            return AccountingType.ACCOUNTING_TYPE_CONSUMABLE;
        case 4:
        case "ACCOUNTING_TYPE_VALID_FOR_1D":
            return AccountingType.ACCOUNTING_TYPE_VALID_FOR_1D;
        case 5:
        case "ACCOUNTING_TYPE_VALID_FOR_7D":
            return AccountingType.ACCOUNTING_TYPE_VALID_FOR_7D;
        case 6:
        case "ACCOUNTING_TYPE_VALID_FOR_30D":
            return AccountingType.ACCOUNTING_TYPE_VALID_FOR_30D;
        case 7:
        case "ACCOUNTING_TYPE_VALID_FOR_1Y":
            return AccountingType.ACCOUNTING_TYPE_VALID_FOR_1Y;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AccountingType.UNRECOGNIZED;
    }
}
export function accountingTypeToJSON(object) {
    switch (object) {
        case AccountingType.ACCOUNTING_TYPE_UNSPECIFIED:
            return 0;
        case AccountingType.ACCOUNTING_TYPE_INSTANT:
            return 1;
        case AccountingType.ACCOUNTING_TYPE_DURABLE:
            return 2;
        case AccountingType.ACCOUNTING_TYPE_CONSUMABLE:
            return 3;
        case AccountingType.ACCOUNTING_TYPE_VALID_FOR_1D:
            return 4;
        case AccountingType.ACCOUNTING_TYPE_VALID_FOR_7D:
            return 5;
        case AccountingType.ACCOUNTING_TYPE_VALID_FOR_30D:
            return 6;
        case AccountingType.ACCOUNTING_TYPE_VALID_FOR_1Y:
            return 7;
        case AccountingType.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseProduct() {
    return {
        sku: "",
        name: "",
        price: undefined,
        environment: 0,
        description: "",
        accountingType: 0,
        productMetadata: {},
        images: {},
    };
}
export const Product = {
    $type: "devvit.payments.v1alpha.Product",
    encode(message, writer = _m0.Writer.create()) {
        if (message.sku !== "") {
            writer.uint32(8010).string(message.sku);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.price !== undefined) {
            ProductPrice.encode(message.price, writer.uint32(42).fork()).ldelim();
        }
        if (message.environment !== 0) {
            writer.uint32(160).int32(message.environment);
        }
        if (message.description !== "") {
            writer.uint32(170).string(message.description);
        }
        if (message.accountingType !== 0) {
            writer.uint32(184).int32(message.accountingType);
        }
        Object.entries(message.productMetadata).forEach(([key, value]) => {
            Product_ProductMetadataEntry.encode({ key: key, value }, writer.uint32(8018).fork()).ldelim();
        });
        Object.entries(message.images).forEach(([key, value]) => {
            Product_ImagesEntry.encode({ key: key, value }, writer.uint32(8026).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProduct();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1001:
                    if (tag !== 8010) {
                        break;
                    }
                    message.sku = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.price = ProductPrice.decode(reader, reader.uint32());
                    continue;
                case 20:
                    if (tag !== 160) {
                        break;
                    }
                    message.environment = reader.int32();
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 23:
                    if (tag !== 184) {
                        break;
                    }
                    message.accountingType = reader.int32();
                    continue;
                case 1002:
                    if (tag !== 8018) {
                        break;
                    }
                    const entry1002 = Product_ProductMetadataEntry.decode(reader, reader.uint32());
                    if (entry1002.value !== undefined) {
                        message.productMetadata[entry1002.key] = entry1002.value;
                    }
                    continue;
                case 1003:
                    if (tag !== 8026) {
                        break;
                    }
                    const entry1003 = Product_ImagesEntry.decode(reader, reader.uint32());
                    if (entry1003.value !== undefined) {
                        message.images[entry1003.key] = entry1003.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            price: isSet(object.price) ? ProductPrice.fromJSON(object.price) : undefined,
            environment: isSet(object.environment) ? environmentFromJSON(object.environment) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            accountingType: isSet(object.accountingType) ? accountingTypeFromJSON(object.accountingType) : 0,
            productMetadata: isObject(object.productMetadata)
                ? Object.entries(object.productMetadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            images: isObject(object.images)
                ? Object.entries(object.images).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sku !== "") {
            obj.sku = message.sku;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.price !== undefined) {
            obj.price = ProductPrice.toJSON(message.price);
        }
        if (message.environment !== 0) {
            obj.environment = environmentToJSON(message.environment);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.accountingType !== 0) {
            obj.accountingType = accountingTypeToJSON(message.accountingType);
        }
        if (message.productMetadata) {
            const entries = Object.entries(message.productMetadata);
            if (entries.length > 0) {
                obj.productMetadata = {};
                entries.forEach(([k, v]) => {
                    obj.productMetadata[k] = v;
                });
            }
        }
        if (message.images) {
            const entries = Object.entries(message.images);
            if (entries.length > 0) {
                obj.images = {};
                entries.forEach(([k, v]) => {
                    obj.images[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Product.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProduct();
        message.sku = object.sku ?? "";
        message.name = object.name ?? "";
        message.price = (object.price !== undefined && object.price !== null)
            ? ProductPrice.fromPartial(object.price)
            : undefined;
        message.environment = object.environment ?? 0;
        message.description = object.description ?? "";
        message.accountingType = object.accountingType ?? 0;
        message.productMetadata = Object.entries(object.productMetadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.images = Object.entries(object.images ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(Product.$type, Product);
function createBaseProduct_ProductMetadataEntry() {
    return { key: "", value: "" };
}
export const Product_ProductMetadataEntry = {
    $type: "devvit.payments.v1alpha.Product.ProductMetadataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProduct_ProductMetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Product_ProductMetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProduct_ProductMetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(Product_ProductMetadataEntry.$type, Product_ProductMetadataEntry);
function createBaseProduct_ImagesEntry() {
    return { key: "", value: "" };
}
export const Product_ImagesEntry = {
    $type: "devvit.payments.v1alpha.Product.ImagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProduct_ImagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Product_ImagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProduct_ImagesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(Product_ImagesEntry.$type, Product_ImagesEntry);
function createBaseProductPrice() {
    return { amount: 0, currency: 0 };
}
export const ProductPrice = {
    $type: "devvit.payments.v1alpha.ProductPrice",
    encode(message, writer = _m0.Writer.create()) {
        if (message.amount !== 0) {
            writer.uint32(8).int32(message.amount);
        }
        if (message.currency !== 0) {
            writer.uint32(16).int32(message.currency);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProductPrice();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.amount = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.currency = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
            currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.amount !== 0) {
            obj.amount = Math.round(message.amount);
        }
        if (message.currency !== 0) {
            obj.currency = currencyToJSON(message.currency);
        }
        return obj;
    },
    create(base) {
        return ProductPrice.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProductPrice();
        message.amount = object.amount ?? 0;
        message.currency = object.currency ?? 0;
        return message;
    },
};
messageTypeRegistry.set(ProductPrice.$type, ProductPrice);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
