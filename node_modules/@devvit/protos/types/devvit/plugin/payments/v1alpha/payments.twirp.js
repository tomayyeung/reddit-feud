import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { GetProductsRequest, GetProductsResponse, GetOrdersRequest, GetOrdersResponse, AcknowledgeOrderDeliveryRequest, AcknowledgeOrderDeliveryResponse, } from './payments.js';
export var PaymentsServiceMethod;
(function (PaymentsServiceMethod) {
    PaymentsServiceMethod["GetProducts"] = "GetProducts";
    PaymentsServiceMethod["GetOrders"] = "GetOrders";
    PaymentsServiceMethod["AcknowledgeOrderDelivery"] = "AcknowledgeOrderDelivery";
})(PaymentsServiceMethod || (PaymentsServiceMethod = {}));
export const PaymentsServiceMethodList = [
    PaymentsServiceMethod.GetProducts,
    PaymentsServiceMethod.GetOrders,
    PaymentsServiceMethod.AcknowledgeOrderDelivery,
];
export function createPaymentsServiceServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.payments.v1alpha',
        serviceName: 'PaymentsService',
        methodList: PaymentsServiceMethodList,
        matchRoute: matchPaymentsServiceRoute,
    });
}
function matchPaymentsServiceRoute(method, events) {
    switch (method) {
        case 'GetProducts':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetProducts' };
                await events.onMatch(ctx);
                return handlePaymentsServiceGetProductsRequest(ctx, service, data, interceptors);
            };
        case 'GetOrders':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetOrders' };
                await events.onMatch(ctx);
                return handlePaymentsServiceGetOrdersRequest(ctx, service, data, interceptors);
            };
        case 'AcknowledgeOrderDelivery':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AcknowledgeOrderDelivery' };
                await events.onMatch(ctx);
                return handlePaymentsServiceAcknowledgeOrderDeliveryRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePaymentsServiceGetProductsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePaymentsServiceGetProductsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePaymentsServiceGetProductsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePaymentsServiceGetOrdersRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePaymentsServiceGetOrdersJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePaymentsServiceGetOrdersProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePaymentsServiceAcknowledgeOrderDeliveryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePaymentsServiceAcknowledgeOrderDeliveryJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePaymentsServiceAcknowledgeOrderDeliveryProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handlePaymentsServiceGetProductsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetProductsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetProducts(ctx, inputReq);
        });
    }
    else {
        response = await service.GetProducts(ctx, request);
    }
    return JSON.stringify(GetProductsResponse.toJSON(response));
}
async function handlePaymentsServiceGetOrdersJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetOrdersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrders(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrders(ctx, request);
    }
    return JSON.stringify(GetOrdersResponse.toJSON(response));
}
async function handlePaymentsServiceAcknowledgeOrderDeliveryJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AcknowledgeOrderDeliveryRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcknowledgeOrderDelivery(ctx, inputReq);
        });
    }
    else {
        response = await service.AcknowledgeOrderDelivery(ctx, request);
    }
    return JSON.stringify(AcknowledgeOrderDeliveryResponse.toJSON(response));
}
async function handlePaymentsServiceGetProductsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetProductsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetProducts(ctx, inputReq);
        });
    }
    else {
        response = await service.GetProducts(ctx, request);
    }
    return Buffer.from(GetProductsResponse.encode(response).finish());
}
async function handlePaymentsServiceGetOrdersProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetOrdersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetOrders(ctx, inputReq);
        });
    }
    else {
        response = await service.GetOrders(ctx, request);
    }
    return Buffer.from(GetOrdersResponse.encode(response).finish());
}
async function handlePaymentsServiceAcknowledgeOrderDeliveryProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AcknowledgeOrderDeliveryRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcknowledgeOrderDelivery(ctx, inputReq);
        });
    }
    else {
        response = await service.AcknowledgeOrderDelivery(ctx, request);
    }
    return Buffer.from(AcknowledgeOrderDeliveryResponse.encode(response).finish());
}
