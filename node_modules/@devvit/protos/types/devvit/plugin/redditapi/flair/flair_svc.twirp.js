import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { ClearFlairTemplatesRequest, DeleteFlairRequest, DeleteFlairTemplateRequest, FlairRequest, FlairTemplateOrderRequest, FlairConfigRequest, FlairCsvRequest, FlairCsvResponse, FlairListRequest, FlairListResponse, FlairSelectorRequest, FlairSelectorResponse, FlairTemplateRequest, FlairObject, LinkFlairRequest, FlairArray, SelectFlairRequest, SetFlairEnabledRequest, } from './flair_msg.js';
import { JsonStatus } from '../common/common_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
export var FlairMethod;
(function (FlairMethod) {
    FlairMethod["ClearFlairTemplates"] = "ClearFlairTemplates";
    FlairMethod["DeleteFlair"] = "DeleteFlair";
    FlairMethod["DeleteFlairTemplate"] = "DeleteFlairTemplate";
    FlairMethod["Flair"] = "Flair";
    FlairMethod["FlairTemplateOrder"] = "FlairTemplateOrder";
    FlairMethod["FlairConfig"] = "FlairConfig";
    FlairMethod["FlairCsv"] = "FlairCsv";
    FlairMethod["FlairList"] = "FlairList";
    FlairMethod["FlairSelector"] = "FlairSelector";
    FlairMethod["FlairTemplate"] = "FlairTemplate";
    FlairMethod["LinkFlair"] = "LinkFlair";
    FlairMethod["SelectFlair"] = "SelectFlair";
    FlairMethod["SetFlairEnabled"] = "SetFlairEnabled";
    FlairMethod["UserFlair"] = "UserFlair";
})(FlairMethod || (FlairMethod = {}));
export const FlairMethodList = [
    FlairMethod.ClearFlairTemplates,
    FlairMethod.DeleteFlair,
    FlairMethod.DeleteFlairTemplate,
    FlairMethod.Flair,
    FlairMethod.FlairTemplateOrder,
    FlairMethod.FlairConfig,
    FlairMethod.FlairCsv,
    FlairMethod.FlairList,
    FlairMethod.FlairSelector,
    FlairMethod.FlairTemplate,
    FlairMethod.LinkFlair,
    FlairMethod.SelectFlair,
    FlairMethod.SetFlairEnabled,
    FlairMethod.UserFlair,
];
export function createFlairServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.flair',
        serviceName: 'Flair',
        methodList: FlairMethodList,
        matchRoute: matchFlairRoute,
    });
}
function matchFlairRoute(method, events) {
    switch (method) {
        case 'ClearFlairTemplates':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ClearFlairTemplates' };
                await events.onMatch(ctx);
                return handleFlairClearFlairTemplatesRequest(ctx, service, data, interceptors);
            };
        case 'DeleteFlair':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DeleteFlair' };
                await events.onMatch(ctx);
                return handleFlairDeleteFlairRequest(ctx, service, data, interceptors);
            };
        case 'DeleteFlairTemplate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DeleteFlairTemplate' };
                await events.onMatch(ctx);
                return handleFlairDeleteFlairTemplateRequest(ctx, service, data, interceptors);
            };
        case 'Flair':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Flair' };
                await events.onMatch(ctx);
                return handleFlairFlairRequest(ctx, service, data, interceptors);
            };
        case 'FlairTemplateOrder':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairTemplateOrder' };
                await events.onMatch(ctx);
                return handleFlairFlairTemplateOrderRequest(ctx, service, data, interceptors);
            };
        case 'FlairConfig':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairConfig' };
                await events.onMatch(ctx);
                return handleFlairFlairConfigRequest(ctx, service, data, interceptors);
            };
        case 'FlairCsv':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairCsv' };
                await events.onMatch(ctx);
                return handleFlairFlairCsvRequest(ctx, service, data, interceptors);
            };
        case 'FlairList':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairList' };
                await events.onMatch(ctx);
                return handleFlairFlairListRequest(ctx, service, data, interceptors);
            };
        case 'FlairSelector':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairSelector' };
                await events.onMatch(ctx);
                return handleFlairFlairSelectorRequest(ctx, service, data, interceptors);
            };
        case 'FlairTemplate':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FlairTemplate' };
                await events.onMatch(ctx);
                return handleFlairFlairTemplateRequest(ctx, service, data, interceptors);
            };
        case 'LinkFlair':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'LinkFlair' };
                await events.onMatch(ctx);
                return handleFlairLinkFlairRequest(ctx, service, data, interceptors);
            };
        case 'SelectFlair':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SelectFlair' };
                await events.onMatch(ctx);
                return handleFlairSelectFlairRequest(ctx, service, data, interceptors);
            };
        case 'SetFlairEnabled':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetFlairEnabled' };
                await events.onMatch(ctx);
                return handleFlairSetFlairEnabledRequest(ctx, service, data, interceptors);
            };
        case 'UserFlair':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserFlair' };
                await events.onMatch(ctx);
                return handleFlairUserFlairRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairClearFlairTemplatesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairClearFlairTemplatesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairClearFlairTemplatesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairDeleteFlairRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairDeleteFlairJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairDeleteFlairProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairDeleteFlairTemplateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairDeleteFlairTemplateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairDeleteFlairTemplateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairTemplateOrderRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairTemplateOrderJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairTemplateOrderProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairConfigRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairConfigJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairConfigProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairCsvRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairCsvJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairCsvProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairListRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairListJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairListProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairSelectorRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairSelectorJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairSelectorProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairFlairTemplateRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairFlairTemplateJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairFlairTemplateProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairLinkFlairRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairLinkFlairJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairLinkFlairProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairSelectFlairRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairSelectFlairJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairSelectFlairProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairSetFlairEnabledRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairSetFlairEnabledJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairSetFlairEnabledProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleFlairUserFlairRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleFlairUserFlairJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleFlairUserFlairProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleFlairClearFlairTemplatesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ClearFlairTemplatesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ClearFlairTemplates(ctx, inputReq);
        });
    }
    else {
        response = await service.ClearFlairTemplates(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairDeleteFlairJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DeleteFlairRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteFlair(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairDeleteFlairTemplateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DeleteFlairTemplateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteFlairTemplate(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteFlairTemplate(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairFlairJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Flair(ctx, inputReq);
        });
    }
    else {
        response = await service.Flair(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairFlairTemplateOrderJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairTemplateOrderRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairTemplateOrder(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairTemplateOrder(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleFlairFlairConfigJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairConfigRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairConfig(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairConfig(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairFlairCsvJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairCsvRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairCsv(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairCsv(ctx, request);
    }
    return JSON.stringify(FlairCsvResponse.toJSON(response));
}
async function handleFlairFlairListJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairListRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairList(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairList(ctx, request);
    }
    return JSON.stringify(FlairListResponse.toJSON(response));
}
async function handleFlairFlairSelectorJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairSelectorRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairSelector(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairSelector(ctx, request);
    }
    return JSON.stringify(FlairSelectorResponse.toJSON(response));
}
async function handleFlairFlairTemplateJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FlairTemplateRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairTemplate(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairTemplate(ctx, request);
    }
    return JSON.stringify(FlairObject.toJSON(response));
}
async function handleFlairLinkFlairJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = LinkFlairRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LinkFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.LinkFlair(ctx, request);
    }
    return JSON.stringify(FlairArray.toJSON(response));
}
async function handleFlairSelectFlairJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SelectFlairRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SelectFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.SelectFlair(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairSetFlairEnabledJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetFlairEnabledRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetFlairEnabled(ctx, inputReq);
        });
    }
    else {
        response = await service.SetFlairEnabled(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleFlairUserFlairJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = LinkFlairRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.UserFlair(ctx, request);
    }
    return JSON.stringify(FlairArray.toJSON(response));
}
async function handleFlairClearFlairTemplatesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ClearFlairTemplatesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ClearFlairTemplates(ctx, inputReq);
        });
    }
    else {
        response = await service.ClearFlairTemplates(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairDeleteFlairProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DeleteFlairRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteFlair(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairDeleteFlairTemplateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DeleteFlairTemplateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteFlairTemplate(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteFlairTemplate(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairFlairProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Flair(ctx, inputReq);
        });
    }
    else {
        response = await service.Flair(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairFlairTemplateOrderProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairTemplateOrderRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairTemplateOrder(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairTemplateOrder(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleFlairFlairConfigProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairConfigRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairConfig(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairConfig(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairFlairCsvProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairCsvRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairCsv(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairCsv(ctx, request);
    }
    return Buffer.from(FlairCsvResponse.encode(response).finish());
}
async function handleFlairFlairListProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairListRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairList(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairList(ctx, request);
    }
    return Buffer.from(FlairListResponse.encode(response).finish());
}
async function handleFlairFlairSelectorProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairSelectorRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairSelector(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairSelector(ctx, request);
    }
    return Buffer.from(FlairSelectorResponse.encode(response).finish());
}
async function handleFlairFlairTemplateProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FlairTemplateRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FlairTemplate(ctx, inputReq);
        });
    }
    else {
        response = await service.FlairTemplate(ctx, request);
    }
    return Buffer.from(FlairObject.encode(response).finish());
}
async function handleFlairLinkFlairProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = LinkFlairRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LinkFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.LinkFlair(ctx, request);
    }
    return Buffer.from(FlairArray.encode(response).finish());
}
async function handleFlairSelectFlairProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SelectFlairRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SelectFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.SelectFlair(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairSetFlairEnabledProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetFlairEnabledRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetFlairEnabled(ctx, inputReq);
        });
    }
    else {
        response = await service.SetFlairEnabled(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleFlairUserFlairProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = LinkFlairRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserFlair(ctx, inputReq);
        });
    }
    else {
        response = await service.UserFlair(ctx, request);
    }
    return Buffer.from(FlairArray.encode(response).finish());
}
