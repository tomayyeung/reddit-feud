import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { CommentRequest, JsonWrappedComment, BasicIdRequest, FollowPostRequest, InfoRequest, MoreChildrenRequest, ReportRequest, ReportAwardRequest, SaveRequest, SendRepliesRequest, SetContestModeRequest, EditCustomPostRequest, SetSubredditStickyRequest, SetSuggestedSortRequest, SubmitRequest, SubmitResponse, VoteRequest, } from './linksandcomments_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
import { Listing, JsonStatus, JsonRedditObjects } from '../common/common_msg.js';
export var LinksAndCommentsMethod;
(function (LinksAndCommentsMethod) {
    LinksAndCommentsMethod["Comment"] = "Comment";
    LinksAndCommentsMethod["Del"] = "Del";
    LinksAndCommentsMethod["EditUserText"] = "EditUserText";
    LinksAndCommentsMethod["FollowPost"] = "FollowPost";
    LinksAndCommentsMethod["Hide"] = "Hide";
    LinksAndCommentsMethod["Info"] = "Info";
    LinksAndCommentsMethod["Lock"] = "Lock";
    LinksAndCommentsMethod["MarkNSFW"] = "MarkNSFW";
    LinksAndCommentsMethod["MoreChildren"] = "MoreChildren";
    LinksAndCommentsMethod["Report"] = "Report";
    LinksAndCommentsMethod["ReportAward"] = "ReportAward";
    LinksAndCommentsMethod["Save"] = "Save";
    LinksAndCommentsMethod["SendReplies"] = "SendReplies";
    LinksAndCommentsMethod["SetContestMode"] = "SetContestMode";
    LinksAndCommentsMethod["EditCustomPost"] = "EditCustomPost";
    LinksAndCommentsMethod["SetSubredditSticky"] = "SetSubredditSticky";
    LinksAndCommentsMethod["SetSuggestedSort"] = "SetSuggestedSort";
    LinksAndCommentsMethod["Spoiler"] = "Spoiler";
    LinksAndCommentsMethod["Submit"] = "Submit";
    LinksAndCommentsMethod["SubmitCustomPost"] = "SubmitCustomPost";
    LinksAndCommentsMethod["Unhide"] = "Unhide";
    LinksAndCommentsMethod["Unlock"] = "Unlock";
    LinksAndCommentsMethod["UnmarkNSFW"] = "UnmarkNSFW";
    LinksAndCommentsMethod["Unsave"] = "Unsave";
    LinksAndCommentsMethod["Unspoiler"] = "Unspoiler";
    LinksAndCommentsMethod["Vote"] = "Vote";
})(LinksAndCommentsMethod || (LinksAndCommentsMethod = {}));
export const LinksAndCommentsMethodList = [
    LinksAndCommentsMethod.Comment,
    LinksAndCommentsMethod.Del,
    LinksAndCommentsMethod.EditUserText,
    LinksAndCommentsMethod.FollowPost,
    LinksAndCommentsMethod.Hide,
    LinksAndCommentsMethod.Info,
    LinksAndCommentsMethod.Lock,
    LinksAndCommentsMethod.MarkNSFW,
    LinksAndCommentsMethod.MoreChildren,
    LinksAndCommentsMethod.Report,
    LinksAndCommentsMethod.ReportAward,
    LinksAndCommentsMethod.Save,
    LinksAndCommentsMethod.SendReplies,
    LinksAndCommentsMethod.SetContestMode,
    LinksAndCommentsMethod.EditCustomPost,
    LinksAndCommentsMethod.SetSubredditSticky,
    LinksAndCommentsMethod.SetSuggestedSort,
    LinksAndCommentsMethod.Spoiler,
    LinksAndCommentsMethod.Submit,
    LinksAndCommentsMethod.SubmitCustomPost,
    LinksAndCommentsMethod.Unhide,
    LinksAndCommentsMethod.Unlock,
    LinksAndCommentsMethod.UnmarkNSFW,
    LinksAndCommentsMethod.Unsave,
    LinksAndCommentsMethod.Unspoiler,
    LinksAndCommentsMethod.Vote,
];
export function createLinksAndCommentsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.linksandcomments',
        serviceName: 'LinksAndComments',
        methodList: LinksAndCommentsMethodList,
        matchRoute: matchLinksAndCommentsRoute,
    });
}
function matchLinksAndCommentsRoute(method, events) {
    switch (method) {
        case 'Comment':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Comment' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsCommentRequest(ctx, service, data, interceptors);
            };
        case 'Del':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Del' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsDelRequest(ctx, service, data, interceptors);
            };
        case 'EditUserText':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'EditUserText' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsEditUserTextRequest(ctx, service, data, interceptors);
            };
        case 'FollowPost':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'FollowPost' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsFollowPostRequest(ctx, service, data, interceptors);
            };
        case 'Hide':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Hide' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsHideRequest(ctx, service, data, interceptors);
            };
        case 'Info':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Info' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsInfoRequest(ctx, service, data, interceptors);
            };
        case 'Lock':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Lock' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsLockRequest(ctx, service, data, interceptors);
            };
        case 'MarkNSFW':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MarkNSFW' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsMarkNSFWRequest(ctx, service, data, interceptors);
            };
        case 'MoreChildren':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MoreChildren' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsMoreChildrenRequest(ctx, service, data, interceptors);
            };
        case 'Report':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Report' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsReportRequest(ctx, service, data, interceptors);
            };
        case 'ReportAward':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ReportAward' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsReportAwardRequest(ctx, service, data, interceptors);
            };
        case 'Save':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Save' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSaveRequest(ctx, service, data, interceptors);
            };
        case 'SendReplies':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SendReplies' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSendRepliesRequest(ctx, service, data, interceptors);
            };
        case 'SetContestMode':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetContestMode' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSetContestModeRequest(ctx, service, data, interceptors);
            };
        case 'EditCustomPost':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'EditCustomPost' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsEditCustomPostRequest(ctx, service, data, interceptors);
            };
        case 'SetSubredditSticky':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetSubredditSticky' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSetSubredditStickyRequest(ctx, service, data, interceptors);
            };
        case 'SetSuggestedSort':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetSuggestedSort' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSetSuggestedSortRequest(ctx, service, data, interceptors);
            };
        case 'Spoiler':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Spoiler' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSpoilerRequest(ctx, service, data, interceptors);
            };
        case 'Submit':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Submit' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSubmitRequest(ctx, service, data, interceptors);
            };
        case 'SubmitCustomPost':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SubmitCustomPost' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsSubmitCustomPostRequest(ctx, service, data, interceptors);
            };
        case 'Unhide':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unhide' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsUnhideRequest(ctx, service, data, interceptors);
            };
        case 'Unlock':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unlock' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsUnlockRequest(ctx, service, data, interceptors);
            };
        case 'UnmarkNSFW':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnmarkNSFW' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsUnmarkNSFWRequest(ctx, service, data, interceptors);
            };
        case 'Unsave':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unsave' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsUnsaveRequest(ctx, service, data, interceptors);
            };
        case 'Unspoiler':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unspoiler' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsUnspoilerRequest(ctx, service, data, interceptors);
            };
        case 'Vote':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Vote' };
                await events.onMatch(ctx);
                return handleLinksAndCommentsVoteRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsCommentRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsCommentJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsCommentProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsDelRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsDelJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsDelProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsEditUserTextRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsEditUserTextJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsEditUserTextProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsFollowPostRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsFollowPostJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsFollowPostProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsHideRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsHideJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsHideProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsInfoRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsInfoJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsInfoProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsLockRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsLockJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsLockProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsMarkNSFWRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsMarkNSFWJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsMarkNSFWProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsMoreChildrenRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsMoreChildrenJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsMoreChildrenProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsReportRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsReportJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsReportProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsReportAwardRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsReportAwardJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsReportAwardProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSaveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSaveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSaveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSendRepliesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSendRepliesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSendRepliesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSetContestModeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSetContestModeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSetContestModeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsEditCustomPostRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsEditCustomPostJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsEditCustomPostProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSetSubredditStickyRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSetSubredditStickyJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSetSubredditStickyProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSetSuggestedSortRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSetSuggestedSortJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSetSuggestedSortProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSpoilerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSpoilerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSpoilerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSubmitRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSubmitJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSubmitProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsSubmitCustomPostRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsSubmitCustomPostJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsSubmitCustomPostProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsUnhideRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsUnhideJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsUnhideProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsUnlockRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsUnlockJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsUnlockProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsUnmarkNSFWRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsUnmarkNSFWJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsUnmarkNSFWProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsUnsaveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsUnsaveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsUnsaveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsUnspoilerRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsUnspoilerJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsUnspoilerProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleLinksAndCommentsVoteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleLinksAndCommentsVoteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleLinksAndCommentsVoteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleLinksAndCommentsCommentJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Comment(ctx, inputReq);
        });
    }
    else {
        response = await service.Comment(ctx, request);
    }
    return JSON.stringify(JsonWrappedComment.toJSON(response));
}
async function handleLinksAndCommentsDelJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Del(ctx, inputReq);
        });
    }
    else {
        response = await service.Del(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsEditUserTextJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CommentRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EditUserText(ctx, inputReq);
        });
    }
    else {
        response = await service.EditUserText(ctx, request);
    }
    return JSON.stringify(JsonWrappedComment.toJSON(response));
}
async function handleLinksAndCommentsFollowPostJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FollowPostRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FollowPost(ctx, inputReq);
        });
    }
    else {
        response = await service.FollowPost(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsHideJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Hide(ctx, inputReq);
        });
    }
    else {
        response = await service.Hide(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsInfoJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InfoRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Info(ctx, inputReq);
        });
    }
    else {
        response = await service.Info(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleLinksAndCommentsLockJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Lock(ctx, inputReq);
        });
    }
    else {
        response = await service.Lock(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsMarkNSFWJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MarkNSFW(ctx, inputReq);
        });
    }
    else {
        response = await service.MarkNSFW(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsMoreChildrenJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = MoreChildrenRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MoreChildren(ctx, inputReq);
        });
    }
    else {
        response = await service.MoreChildren(ctx, request);
    }
    return JSON.stringify(JsonWrappedComment.toJSON(response));
}
async function handleLinksAndCommentsReportJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ReportRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Report(ctx, inputReq);
        });
    }
    else {
        response = await service.Report(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleLinksAndCommentsReportAwardJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ReportAwardRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ReportAward(ctx, inputReq);
        });
    }
    else {
        response = await service.ReportAward(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsSaveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SaveRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Save(ctx, inputReq);
        });
    }
    else {
        response = await service.Save(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsSendRepliesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SendRepliesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendReplies(ctx, inputReq);
        });
    }
    else {
        response = await service.SendReplies(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsSetContestModeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetContestModeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetContestMode(ctx, inputReq);
        });
    }
    else {
        response = await service.SetContestMode(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleLinksAndCommentsEditCustomPostJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = EditCustomPostRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EditCustomPost(ctx, inputReq);
        });
    }
    else {
        response = await service.EditCustomPost(ctx, request);
    }
    return JSON.stringify(JsonRedditObjects.toJSON(response));
}
async function handleLinksAndCommentsSetSubredditStickyJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetSubredditStickyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetSubredditSticky(ctx, inputReq);
        });
    }
    else {
        response = await service.SetSubredditSticky(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleLinksAndCommentsSetSuggestedSortJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetSuggestedSortRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetSuggestedSort(ctx, inputReq);
        });
    }
    else {
        response = await service.SetSuggestedSort(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleLinksAndCommentsSpoilerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Spoiler(ctx, inputReq);
        });
    }
    else {
        response = await service.Spoiler(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsSubmitJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubmitRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Submit(ctx, inputReq);
        });
    }
    else {
        response = await service.Submit(ctx, request);
    }
    return JSON.stringify(SubmitResponse.toJSON(response));
}
async function handleLinksAndCommentsSubmitCustomPostJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SubmitRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SubmitCustomPost(ctx, inputReq);
        });
    }
    else {
        response = await service.SubmitCustomPost(ctx, request);
    }
    return JSON.stringify(SubmitResponse.toJSON(response));
}
async function handleLinksAndCommentsUnhideJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unhide(ctx, inputReq);
        });
    }
    else {
        response = await service.Unhide(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsUnlockJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unlock(ctx, inputReq);
        });
    }
    else {
        response = await service.Unlock(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsUnmarkNSFWJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmarkNSFW(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmarkNSFW(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsUnsaveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unsave(ctx, inputReq);
        });
    }
    else {
        response = await service.Unsave(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsUnspoilerJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unspoiler(ctx, inputReq);
        });
    }
    else {
        response = await service.Unspoiler(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsVoteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = VoteRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Vote(ctx, inputReq);
        });
    }
    else {
        response = await service.Vote(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleLinksAndCommentsCommentProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Comment(ctx, inputReq);
        });
    }
    else {
        response = await service.Comment(ctx, request);
    }
    return Buffer.from(JsonWrappedComment.encode(response).finish());
}
async function handleLinksAndCommentsDelProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Del(ctx, inputReq);
        });
    }
    else {
        response = await service.Del(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsEditUserTextProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CommentRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EditUserText(ctx, inputReq);
        });
    }
    else {
        response = await service.EditUserText(ctx, request);
    }
    return Buffer.from(JsonWrappedComment.encode(response).finish());
}
async function handleLinksAndCommentsFollowPostProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FollowPostRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.FollowPost(ctx, inputReq);
        });
    }
    else {
        response = await service.FollowPost(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsHideProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Hide(ctx, inputReq);
        });
    }
    else {
        response = await service.Hide(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsInfoProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InfoRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Info(ctx, inputReq);
        });
    }
    else {
        response = await service.Info(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleLinksAndCommentsLockProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Lock(ctx, inputReq);
        });
    }
    else {
        response = await service.Lock(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsMarkNSFWProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MarkNSFW(ctx, inputReq);
        });
    }
    else {
        response = await service.MarkNSFW(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsMoreChildrenProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = MoreChildrenRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MoreChildren(ctx, inputReq);
        });
    }
    else {
        response = await service.MoreChildren(ctx, request);
    }
    return Buffer.from(JsonWrappedComment.encode(response).finish());
}
async function handleLinksAndCommentsReportProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ReportRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Report(ctx, inputReq);
        });
    }
    else {
        response = await service.Report(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleLinksAndCommentsReportAwardProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ReportAwardRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ReportAward(ctx, inputReq);
        });
    }
    else {
        response = await service.ReportAward(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsSaveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SaveRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Save(ctx, inputReq);
        });
    }
    else {
        response = await service.Save(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsSendRepliesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SendRepliesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SendReplies(ctx, inputReq);
        });
    }
    else {
        response = await service.SendReplies(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsSetContestModeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetContestModeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetContestMode(ctx, inputReq);
        });
    }
    else {
        response = await service.SetContestMode(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleLinksAndCommentsEditCustomPostProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = EditCustomPostRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.EditCustomPost(ctx, inputReq);
        });
    }
    else {
        response = await service.EditCustomPost(ctx, request);
    }
    return Buffer.from(JsonRedditObjects.encode(response).finish());
}
async function handleLinksAndCommentsSetSubredditStickyProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetSubredditStickyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetSubredditSticky(ctx, inputReq);
        });
    }
    else {
        response = await service.SetSubredditSticky(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleLinksAndCommentsSetSuggestedSortProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetSuggestedSortRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetSuggestedSort(ctx, inputReq);
        });
    }
    else {
        response = await service.SetSuggestedSort(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleLinksAndCommentsSpoilerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Spoiler(ctx, inputReq);
        });
    }
    else {
        response = await service.Spoiler(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsSubmitProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubmitRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Submit(ctx, inputReq);
        });
    }
    else {
        response = await service.Submit(ctx, request);
    }
    return Buffer.from(SubmitResponse.encode(response).finish());
}
async function handleLinksAndCommentsSubmitCustomPostProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SubmitRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SubmitCustomPost(ctx, inputReq);
        });
    }
    else {
        response = await service.SubmitCustomPost(ctx, request);
    }
    return Buffer.from(SubmitResponse.encode(response).finish());
}
async function handleLinksAndCommentsUnhideProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unhide(ctx, inputReq);
        });
    }
    else {
        response = await service.Unhide(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsUnlockProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unlock(ctx, inputReq);
        });
    }
    else {
        response = await service.Unlock(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsUnmarkNSFWProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmarkNSFW(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmarkNSFW(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsUnsaveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unsave(ctx, inputReq);
        });
    }
    else {
        response = await service.Unsave(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsUnspoilerProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unspoiler(ctx, inputReq);
        });
    }
    else {
        response = await service.Unspoiler(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleLinksAndCommentsVoteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = VoteRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Vote(ctx, inputReq);
        });
    }
    else {
        response = await service.Vote(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
