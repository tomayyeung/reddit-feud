/**
 * #listings_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { BoolValue, Int64Value, StringValue } from "../../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
import { Listing } from "../common/common_msg.js";
function createBaseGetBestRequest() {
    return { after: undefined, before: undefined, count: undefined, limit: undefined, show: undefined };
}
export const GetBestRequest = {
    $type: "devvit.plugin.redditapi.listings.GetBestRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetBestRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        return obj;
    },
    create(base) {
        return GetBestRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetBestRequest();
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetBestRequest.$type, GetBestRequest);
function createBaseGetSortRequest() {
    return {
        subreddit: undefined,
        sort: "",
        after: undefined,
        before: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        t: undefined,
    };
}
export const GetSortRequest = {
    $type: "devvit.plugin.redditapi.listings.GetSortRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.sort !== "") {
            writer.uint32(18).string(message.sort);
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(50).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(58).fork()).ldelim();
        }
        if (message.t !== undefined) {
            StringValue.encode({ value: message.t }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSortRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.sort = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.t = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            t: isSet(object.t) ? String(object.t) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.sort !== "") {
            obj.sort = message.sort;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        if (message.t !== undefined) {
            obj.t = message.t;
        }
        return obj;
    },
    create(base) {
        return GetSortRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSortRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.sort = object.sort ?? "";
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.t = object.t ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetSortRequest.$type, GetSortRequest);
function createBaseGetCommentsRequest() {
    return {
        article: "",
        comment: undefined,
        context: undefined,
        depth: undefined,
        limit: undefined,
        sort: undefined,
        threaded: undefined,
        truncate: undefined,
    };
}
export const GetCommentsRequest = {
    $type: "devvit.plugin.redditapi.listings.GetCommentsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.article !== "") {
            writer.uint32(10).string(message.article);
        }
        if (message.comment !== undefined) {
            StringValue.encode({ value: message.comment }, writer.uint32(18).fork()).ldelim();
        }
        if (message.context !== undefined) {
            Int64Value.encode({ value: message.context }, writer.uint32(26).fork()).ldelim();
        }
        if (message.depth !== undefined) {
            Int64Value.encode({ value: message.depth }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(50).fork()).ldelim();
        }
        if (message.threaded !== undefined) {
            BoolValue.encode({ value: message.threaded }, writer.uint32(58).fork()).ldelim();
        }
        if (message.truncate !== undefined) {
            Int64Value.encode({ value: message.truncate }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetCommentsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.article = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.comment = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.context = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.depth = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.threaded = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.truncate = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            article: isSet(object.article) ? globalThis.String(object.article) : "",
            comment: isSet(object.comment) ? String(object.comment) : undefined,
            context: isSet(object.context) ? Number(object.context) : undefined,
            depth: isSet(object.depth) ? Number(object.depth) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            threaded: isSet(object.threaded) ? Boolean(object.threaded) : undefined,
            truncate: isSet(object.truncate) ? Number(object.truncate) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.article !== "") {
            obj.article = message.article;
        }
        if (message.comment !== undefined) {
            obj.comment = message.comment;
        }
        if (message.context !== undefined) {
            obj.context = message.context;
        }
        if (message.depth !== undefined) {
            obj.depth = message.depth;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.sort !== undefined) {
            obj.sort = message.sort;
        }
        if (message.threaded !== undefined) {
            obj.threaded = message.threaded;
        }
        if (message.truncate !== undefined) {
            obj.truncate = message.truncate;
        }
        return obj;
    },
    create(base) {
        return GetCommentsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetCommentsRequest();
        message.article = object.article ?? "";
        message.comment = object.comment ?? undefined;
        message.context = object.context ?? undefined;
        message.depth = object.depth ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.threaded = object.threaded ?? undefined;
        message.truncate = object.truncate ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetCommentsRequest.$type, GetCommentsRequest);
function createBaseGetByIdRequest() {
    return { postIds: "" };
}
export const GetByIdRequest = {
    $type: "devvit.plugin.redditapi.listings.GetByIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.postIds !== "") {
            writer.uint32(10).string(message.postIds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetByIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.postIds = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { postIds: isSet(object.postIds) ? globalThis.String(object.postIds) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.postIds !== "") {
            obj.postIds = message.postIds;
        }
        return obj;
    },
    create(base) {
        return GetByIdRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetByIdRequest();
        message.postIds = object.postIds ?? "";
        return message;
    },
};
messageTypeRegistry.set(GetByIdRequest.$type, GetByIdRequest);
function createBaseGetDuplicatesRequest() {
    return {
        article: "",
        before: undefined,
        after: undefined,
        limit: undefined,
        sort: undefined,
        sr: undefined,
        count: undefined,
        crosspostsOnly: undefined,
        show: undefined,
    };
}
export const GetDuplicatesRequest = {
    $type: "devvit.plugin.redditapi.listings.GetDuplicatesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.article !== "") {
            writer.uint32(10).string(message.article);
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(42).fork()).ldelim();
        }
        if (message.sr !== undefined) {
            StringValue.encode({ value: message.sr }, writer.uint32(50).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(58).fork()).ldelim();
        }
        if (message.crosspostsOnly !== undefined) {
            BoolValue.encode({ value: message.crosspostsOnly }, writer.uint32(66).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetDuplicatesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.article = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.sr = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.crosspostsOnly = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            article: isSet(object.article) ? globalThis.String(object.article) : "",
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            sr: isSet(object.sr) ? String(object.sr) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            crosspostsOnly: isSet(object.crosspostsOnly) ? Boolean(object.crosspostsOnly) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.article !== "") {
            obj.article = message.article;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.sort !== undefined) {
            obj.sort = message.sort;
        }
        if (message.sr !== undefined) {
            obj.sr = message.sr;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.crosspostsOnly !== undefined) {
            obj.crosspostsOnly = message.crosspostsOnly;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        return obj;
    },
    create(base) {
        return GetDuplicatesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetDuplicatesRequest();
        message.article = object.article ?? "";
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.sr = object.sr ?? undefined;
        message.count = object.count ?? undefined;
        message.crosspostsOnly = object.crosspostsOnly ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetDuplicatesRequest.$type, GetDuplicatesRequest);
function createBaseGetHotRequest() {
    return {
        subreddit: undefined,
        before: undefined,
        after: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
        g: undefined,
    };
}
export const GetHotRequest = {
    $type: "devvit.plugin.redditapi.listings.GetHotRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        if (message.g !== undefined) {
            StringValue.encode({ value: message.g }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetHotRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.g = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
            g: isSet(object.g) ? String(object.g) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        if (message.g !== undefined) {
            obj.g = message.g;
        }
        return obj;
    },
    create(base) {
        return GetHotRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetHotRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        message.g = object.g ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetHotRequest.$type, GetHotRequest);
function createBaseGetNewRequest() {
    return {
        subreddit: undefined,
        before: undefined,
        after: undefined,
        limit: undefined,
        count: undefined,
        show: undefined,
    };
}
export const GetNewRequest = {
    $type: "devvit.plugin.redditapi.listings.GetNewRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetNewRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        return obj;
    },
    create(base) {
        return GetNewRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetNewRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.before = object.before ?? undefined;
        message.after = object.after ?? undefined;
        message.limit = object.limit ?? undefined;
        message.count = object.count ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetNewRequest.$type, GetNewRequest);
function createBaseGetRisingRequest() {
    return {
        subreddit: undefined,
        after: undefined,
        before: undefined,
        count: undefined,
        limit: undefined,
        show: undefined,
    };
}
export const GetRisingRequest = {
    $type: "devvit.plugin.redditapi.listings.GetRisingRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(10).fork()).ldelim();
        }
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(18).fork()).ldelim();
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(26).fork()).ldelim();
        }
        if (message.count !== undefined) {
            Int64Value.encode({ value: message.count }, writer.uint32(34).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.show !== undefined) {
            StringValue.encode({ value: message.show }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRisingRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.count = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.show = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            after: isSet(object.after) ? String(object.after) : undefined,
            before: isSet(object.before) ? String(object.before) : undefined,
            count: isSet(object.count) ? Number(object.count) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            show: isSet(object.show) ? String(object.show) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.count !== undefined) {
            obj.count = message.count;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.show !== undefined) {
            obj.show = message.show;
        }
        return obj;
    },
    create(base) {
        return GetRisingRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetRisingRequest();
        message.subreddit = object.subreddit ?? undefined;
        message.after = object.after ?? undefined;
        message.before = object.before ?? undefined;
        message.count = object.count ?? undefined;
        message.limit = object.limit ?? undefined;
        message.show = object.show ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetRisingRequest.$type, GetRisingRequest);
function createBaseListingResponse() {
    return { listings: [] };
}
export const ListingResponse = {
    $type: "devvit.plugin.redditapi.listings.ListingResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.listings) {
            Listing.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListingResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.listings.push(Listing.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            listings: globalThis.Array.isArray(object?.listings) ? object.listings.map((e) => Listing.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.listings?.length) {
            obj.listings = message.listings.map((e) => Listing.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ListingResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListingResponse();
        message.listings = object.listings?.map((e) => Listing.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(ListingResponse.$type, ListingResponse);
function isSet(value) {
    return value !== null && value !== undefined;
}
