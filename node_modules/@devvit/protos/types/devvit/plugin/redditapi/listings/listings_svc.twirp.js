import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { GetBestRequest, GetByIdRequest, GetCommentsRequest, ListingResponse, GetDuplicatesRequest, GetHotRequest, GetNewRequest, GetRisingRequest, GetSortRequest, } from './listings_msg.js';
import { Listing } from '../common/common_msg.js';
export var ListingsMethod;
(function (ListingsMethod) {
    ListingsMethod["Best"] = "Best";
    ListingsMethod["ById"] = "ById";
    ListingsMethod["Comments"] = "Comments";
    ListingsMethod["Duplicates"] = "Duplicates";
    ListingsMethod["Hot"] = "Hot";
    ListingsMethod["New"] = "New";
    ListingsMethod["Rising"] = "Rising";
    ListingsMethod["Sort"] = "Sort";
})(ListingsMethod || (ListingsMethod = {}));
export const ListingsMethodList = [
    ListingsMethod.Best,
    ListingsMethod.ById,
    ListingsMethod.Comments,
    ListingsMethod.Duplicates,
    ListingsMethod.Hot,
    ListingsMethod.New,
    ListingsMethod.Rising,
    ListingsMethod.Sort,
];
export function createListingsServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.listings',
        serviceName: 'Listings',
        methodList: ListingsMethodList,
        matchRoute: matchListingsRoute,
    });
}
function matchListingsRoute(method, events) {
    switch (method) {
        case 'Best':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Best' };
                await events.onMatch(ctx);
                return handleListingsBestRequest(ctx, service, data, interceptors);
            };
        case 'ById':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ById' };
                await events.onMatch(ctx);
                return handleListingsByIdRequest(ctx, service, data, interceptors);
            };
        case 'Comments':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Comments' };
                await events.onMatch(ctx);
                return handleListingsCommentsRequest(ctx, service, data, interceptors);
            };
        case 'Duplicates':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Duplicates' };
                await events.onMatch(ctx);
                return handleListingsDuplicatesRequest(ctx, service, data, interceptors);
            };
        case 'Hot':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Hot' };
                await events.onMatch(ctx);
                return handleListingsHotRequest(ctx, service, data, interceptors);
            };
        case 'New':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'New' };
                await events.onMatch(ctx);
                return handleListingsNewRequest(ctx, service, data, interceptors);
            };
        case 'Rising':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Rising' };
                await events.onMatch(ctx);
                return handleListingsRisingRequest(ctx, service, data, interceptors);
            };
        case 'Sort':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Sort' };
                await events.onMatch(ctx);
                return handleListingsSortRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsBestRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsBestJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsBestProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsByIdRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsByIdJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsByIdProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsCommentsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsCommentsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsCommentsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsDuplicatesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsDuplicatesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsDuplicatesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsHotRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsHotJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsHotProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsNewRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsNewJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsNewProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsRisingRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsRisingJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsRisingProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleListingsSortRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleListingsSortJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleListingsSortProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleListingsBestJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetBestRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Best(ctx, inputReq);
        });
    }
    else {
        response = await service.Best(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsByIdJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetByIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ById(ctx, inputReq);
        });
    }
    else {
        response = await service.ById(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsCommentsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetCommentsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Comments(ctx, inputReq);
        });
    }
    else {
        response = await service.Comments(ctx, request);
    }
    return JSON.stringify(ListingResponse.toJSON(response));
}
async function handleListingsDuplicatesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetDuplicatesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Duplicates(ctx, inputReq);
        });
    }
    else {
        response = await service.Duplicates(ctx, request);
    }
    return JSON.stringify(ListingResponse.toJSON(response));
}
async function handleListingsHotJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetHotRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Hot(ctx, inputReq);
        });
    }
    else {
        response = await service.Hot(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsNewJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetNewRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.New(ctx, inputReq);
        });
    }
    else {
        response = await service.New(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsRisingJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetRisingRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Rising(ctx, inputReq);
        });
    }
    else {
        response = await service.Rising(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsSortJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetSortRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Sort(ctx, inputReq);
        });
    }
    else {
        response = await service.Sort(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleListingsBestProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetBestRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Best(ctx, inputReq);
        });
    }
    else {
        response = await service.Best(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleListingsByIdProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetByIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ById(ctx, inputReq);
        });
    }
    else {
        response = await service.ById(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleListingsCommentsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetCommentsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Comments(ctx, inputReq);
        });
    }
    else {
        response = await service.Comments(ctx, request);
    }
    return Buffer.from(ListingResponse.encode(response).finish());
}
async function handleListingsDuplicatesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetDuplicatesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Duplicates(ctx, inputReq);
        });
    }
    else {
        response = await service.Duplicates(ctx, request);
    }
    return Buffer.from(ListingResponse.encode(response).finish());
}
async function handleListingsHotProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetHotRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Hot(ctx, inputReq);
        });
    }
    else {
        response = await service.Hot(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleListingsNewProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetNewRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.New(ctx, inputReq);
        });
    }
    else {
        response = await service.New(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleListingsRisingProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetRisingRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Rising(ctx, inputReq);
        });
    }
    else {
        response = await service.Rising(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleListingsSortProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetSortRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Sort(ctx, inputReq);
        });
    }
    else {
        response = await service.Sort(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
