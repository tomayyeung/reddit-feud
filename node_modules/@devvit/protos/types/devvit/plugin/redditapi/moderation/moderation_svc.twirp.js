import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { AboutLogRequest, AboutLogResponse, AboutLocationRequest, AcceptModeratorInviteRequest, BasicModerationIdRequest, DistinguishRequest, RemoveRequest, SnoozeReportsRequest, UpdateCrowdControlLevelRequest, StylesheetRequest, } from './moderation_msg.js';
import { Listing, JsonStatus, JsonRedditObjects } from '../common/common_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
import { StringValue } from '../../../../google/protobuf/wrappers.js';
export var ModerationMethod;
(function (ModerationMethod) {
    ModerationMethod["AboutLog"] = "AboutLog";
    ModerationMethod["AboutLocation"] = "AboutLocation";
    ModerationMethod["AboutReports"] = "AboutReports";
    ModerationMethod["AboutSpam"] = "AboutSpam";
    ModerationMethod["AboutModqueue"] = "AboutModqueue";
    ModerationMethod["AboutUnmoderated"] = "AboutUnmoderated";
    ModerationMethod["AboutEdited"] = "AboutEdited";
    ModerationMethod["AcceptModeratorInvite"] = "AcceptModeratorInvite";
    ModerationMethod["Approve"] = "Approve";
    ModerationMethod["Distinguish"] = "Distinguish";
    ModerationMethod["IgnoreReports"] = "IgnoreReports";
    ModerationMethod["LeaveContributor"] = "LeaveContributor";
    ModerationMethod["LeaveModerator"] = "LeaveModerator";
    ModerationMethod["MuteMessageAuthor"] = "MuteMessageAuthor";
    ModerationMethod["Remove"] = "Remove";
    ModerationMethod["ShowComment"] = "ShowComment";
    ModerationMethod["SnoozeReports"] = "SnoozeReports";
    ModerationMethod["UnignoreReports"] = "UnignoreReports";
    ModerationMethod["UnmuteMessageAuthor"] = "UnmuteMessageAuthor";
    ModerationMethod["UnsnoozeReports"] = "UnsnoozeReports";
    ModerationMethod["UpdateCrowdControlLevel"] = "UpdateCrowdControlLevel";
    ModerationMethod["Stylesheet"] = "Stylesheet";
})(ModerationMethod || (ModerationMethod = {}));
export const ModerationMethodList = [
    ModerationMethod.AboutLog,
    ModerationMethod.AboutLocation,
    ModerationMethod.AboutReports,
    ModerationMethod.AboutSpam,
    ModerationMethod.AboutModqueue,
    ModerationMethod.AboutUnmoderated,
    ModerationMethod.AboutEdited,
    ModerationMethod.AcceptModeratorInvite,
    ModerationMethod.Approve,
    ModerationMethod.Distinguish,
    ModerationMethod.IgnoreReports,
    ModerationMethod.LeaveContributor,
    ModerationMethod.LeaveModerator,
    ModerationMethod.MuteMessageAuthor,
    ModerationMethod.Remove,
    ModerationMethod.ShowComment,
    ModerationMethod.SnoozeReports,
    ModerationMethod.UnignoreReports,
    ModerationMethod.UnmuteMessageAuthor,
    ModerationMethod.UnsnoozeReports,
    ModerationMethod.UpdateCrowdControlLevel,
    ModerationMethod.Stylesheet,
];
export function createModerationServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.moderation',
        serviceName: 'Moderation',
        methodList: ModerationMethodList,
        matchRoute: matchModerationRoute,
    });
}
function matchModerationRoute(method, events) {
    switch (method) {
        case 'AboutLog':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutLog' };
                await events.onMatch(ctx);
                return handleModerationAboutLogRequest(ctx, service, data, interceptors);
            };
        case 'AboutLocation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutLocation' };
                await events.onMatch(ctx);
                return handleModerationAboutLocationRequest(ctx, service, data, interceptors);
            };
        case 'AboutReports':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutReports' };
                await events.onMatch(ctx);
                return handleModerationAboutReportsRequest(ctx, service, data, interceptors);
            };
        case 'AboutSpam':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutSpam' };
                await events.onMatch(ctx);
                return handleModerationAboutSpamRequest(ctx, service, data, interceptors);
            };
        case 'AboutModqueue':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutModqueue' };
                await events.onMatch(ctx);
                return handleModerationAboutModqueueRequest(ctx, service, data, interceptors);
            };
        case 'AboutUnmoderated':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutUnmoderated' };
                await events.onMatch(ctx);
                return handleModerationAboutUnmoderatedRequest(ctx, service, data, interceptors);
            };
        case 'AboutEdited':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AboutEdited' };
                await events.onMatch(ctx);
                return handleModerationAboutEditedRequest(ctx, service, data, interceptors);
            };
        case 'AcceptModeratorInvite':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AcceptModeratorInvite' };
                await events.onMatch(ctx);
                return handleModerationAcceptModeratorInviteRequest(ctx, service, data, interceptors);
            };
        case 'Approve':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Approve' };
                await events.onMatch(ctx);
                return handleModerationApproveRequest(ctx, service, data, interceptors);
            };
        case 'Distinguish':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Distinguish' };
                await events.onMatch(ctx);
                return handleModerationDistinguishRequest(ctx, service, data, interceptors);
            };
        case 'IgnoreReports':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'IgnoreReports' };
                await events.onMatch(ctx);
                return handleModerationIgnoreReportsRequest(ctx, service, data, interceptors);
            };
        case 'LeaveContributor':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'LeaveContributor' };
                await events.onMatch(ctx);
                return handleModerationLeaveContributorRequest(ctx, service, data, interceptors);
            };
        case 'LeaveModerator':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'LeaveModerator' };
                await events.onMatch(ctx);
                return handleModerationLeaveModeratorRequest(ctx, service, data, interceptors);
            };
        case 'MuteMessageAuthor':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MuteMessageAuthor' };
                await events.onMatch(ctx);
                return handleModerationMuteMessageAuthorRequest(ctx, service, data, interceptors);
            };
        case 'Remove':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Remove' };
                await events.onMatch(ctx);
                return handleModerationRemoveRequest(ctx, service, data, interceptors);
            };
        case 'ShowComment':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ShowComment' };
                await events.onMatch(ctx);
                return handleModerationShowCommentRequest(ctx, service, data, interceptors);
            };
        case 'SnoozeReports':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SnoozeReports' };
                await events.onMatch(ctx);
                return handleModerationSnoozeReportsRequest(ctx, service, data, interceptors);
            };
        case 'UnignoreReports':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnignoreReports' };
                await events.onMatch(ctx);
                return handleModerationUnignoreReportsRequest(ctx, service, data, interceptors);
            };
        case 'UnmuteMessageAuthor':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnmuteMessageAuthor' };
                await events.onMatch(ctx);
                return handleModerationUnmuteMessageAuthorRequest(ctx, service, data, interceptors);
            };
        case 'UnsnoozeReports':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnsnoozeReports' };
                await events.onMatch(ctx);
                return handleModerationUnsnoozeReportsRequest(ctx, service, data, interceptors);
            };
        case 'UpdateCrowdControlLevel':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateCrowdControlLevel' };
                await events.onMatch(ctx);
                return handleModerationUpdateCrowdControlLevelRequest(ctx, service, data, interceptors);
            };
        case 'Stylesheet':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Stylesheet' };
                await events.onMatch(ctx);
                return handleModerationStylesheetRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutLogRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutLogJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutLogProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutLocationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutLocationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutLocationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutReportsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutReportsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutReportsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutSpamRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutSpamJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutSpamProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutModqueueRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutModqueueJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutModqueueProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutUnmoderatedRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutUnmoderatedJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutUnmoderatedProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAboutEditedRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAboutEditedJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAboutEditedProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationAcceptModeratorInviteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationAcceptModeratorInviteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationAcceptModeratorInviteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationApproveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationApproveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationApproveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationDistinguishRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationDistinguishJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationDistinguishProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationIgnoreReportsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationIgnoreReportsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationIgnoreReportsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationLeaveContributorRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationLeaveContributorJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationLeaveContributorProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationLeaveModeratorRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationLeaveModeratorJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationLeaveModeratorProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationMuteMessageAuthorRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationMuteMessageAuthorJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationMuteMessageAuthorProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationRemoveRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationRemoveJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationRemoveProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationShowCommentRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationShowCommentJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationShowCommentProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationSnoozeReportsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationSnoozeReportsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationSnoozeReportsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationUnignoreReportsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationUnignoreReportsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationUnignoreReportsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationUnmuteMessageAuthorRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationUnmuteMessageAuthorJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationUnmuteMessageAuthorProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationUnsnoozeReportsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationUnsnoozeReportsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationUnsnoozeReportsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationUpdateCrowdControlLevelRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationUpdateCrowdControlLevelJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationUpdateCrowdControlLevelProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModerationStylesheetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModerationStylesheetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModerationStylesheetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleModerationAboutLogJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLogRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutLog(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutLog(ctx, request);
    }
    return JSON.stringify(AboutLogResponse.toJSON(response));
}
async function handleModerationAboutLocationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutLocation(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAboutReportsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutReports(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutReports(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAboutSpamJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutSpam(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutSpam(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAboutModqueueJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutModqueue(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutModqueue(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAboutUnmoderatedJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutUnmoderated(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutUnmoderated(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAboutEditedJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AboutLocationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutEdited(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutEdited(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleModerationAcceptModeratorInviteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AcceptModeratorInviteRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptModeratorInvite(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptModeratorInvite(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleModerationApproveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Approve(ctx, inputReq);
        });
    }
    else {
        response = await service.Approve(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationDistinguishJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DistinguishRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Distinguish(ctx, inputReq);
        });
    }
    else {
        response = await service.Distinguish(ctx, request);
    }
    return JSON.stringify(JsonRedditObjects.toJSON(response));
}
async function handleModerationIgnoreReportsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IgnoreReports(ctx, inputReq);
        });
    }
    else {
        response = await service.IgnoreReports(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationLeaveContributorJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LeaveContributor(ctx, inputReq);
        });
    }
    else {
        response = await service.LeaveContributor(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationLeaveModeratorJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LeaveModerator(ctx, inputReq);
        });
    }
    else {
        response = await service.LeaveModerator(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationMuteMessageAuthorJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MuteMessageAuthor(ctx, inputReq);
        });
    }
    else {
        response = await service.MuteMessageAuthor(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationRemoveJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = RemoveRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationShowCommentJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ShowComment(ctx, inputReq);
        });
    }
    else {
        response = await service.ShowComment(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationSnoozeReportsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SnoozeReportsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SnoozeReports(ctx, inputReq);
        });
    }
    else {
        response = await service.SnoozeReports(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationUnignoreReportsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnignoreReports(ctx, inputReq);
        });
    }
    else {
        response = await service.UnignoreReports(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationUnmuteMessageAuthorJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicModerationIdRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmuteMessageAuthor(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmuteMessageAuthor(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationUnsnoozeReportsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SnoozeReportsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnsnoozeReports(ctx, inputReq);
        });
    }
    else {
        response = await service.UnsnoozeReports(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationUpdateCrowdControlLevelJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateCrowdControlLevelRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateCrowdControlLevel(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateCrowdControlLevel(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModerationStylesheetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = StylesheetRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Stylesheet(ctx, inputReq);
        });
    }
    else {
        response = await service.Stylesheet(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleModerationAboutLogProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLogRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutLog(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutLog(ctx, request);
    }
    return Buffer.from(AboutLogResponse.encode(response).finish());
}
async function handleModerationAboutLocationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutLocation(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutLocation(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAboutReportsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutReports(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutReports(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAboutSpamProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutSpam(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutSpam(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAboutModqueueProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutModqueue(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutModqueue(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAboutUnmoderatedProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutUnmoderated(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutUnmoderated(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAboutEditedProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AboutLocationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AboutEdited(ctx, inputReq);
        });
    }
    else {
        response = await service.AboutEdited(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
async function handleModerationAcceptModeratorInviteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AcceptModeratorInviteRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AcceptModeratorInvite(ctx, inputReq);
        });
    }
    else {
        response = await service.AcceptModeratorInvite(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleModerationApproveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Approve(ctx, inputReq);
        });
    }
    else {
        response = await service.Approve(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationDistinguishProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DistinguishRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Distinguish(ctx, inputReq);
        });
    }
    else {
        response = await service.Distinguish(ctx, request);
    }
    return Buffer.from(JsonRedditObjects.encode(response).finish());
}
async function handleModerationIgnoreReportsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IgnoreReports(ctx, inputReq);
        });
    }
    else {
        response = await service.IgnoreReports(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationLeaveContributorProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LeaveContributor(ctx, inputReq);
        });
    }
    else {
        response = await service.LeaveContributor(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationLeaveModeratorProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.LeaveModerator(ctx, inputReq);
        });
    }
    else {
        response = await service.LeaveModerator(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationMuteMessageAuthorProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MuteMessageAuthor(ctx, inputReq);
        });
    }
    else {
        response = await service.MuteMessageAuthor(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationRemoveProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = RemoveRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Remove(ctx, inputReq);
        });
    }
    else {
        response = await service.Remove(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationShowCommentProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ShowComment(ctx, inputReq);
        });
    }
    else {
        response = await service.ShowComment(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationSnoozeReportsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SnoozeReportsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SnoozeReports(ctx, inputReq);
        });
    }
    else {
        response = await service.SnoozeReports(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationUnignoreReportsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnignoreReports(ctx, inputReq);
        });
    }
    else {
        response = await service.UnignoreReports(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationUnmuteMessageAuthorProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicModerationIdRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmuteMessageAuthor(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmuteMessageAuthor(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationUnsnoozeReportsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SnoozeReportsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnsnoozeReports(ctx, inputReq);
        });
    }
    else {
        response = await service.UnsnoozeReports(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationUpdateCrowdControlLevelProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateCrowdControlLevelRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateCrowdControlLevel(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateCrowdControlLevel(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModerationStylesheetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = StylesheetRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Stylesheet(ctx, inputReq);
        });
    }
    else {
        response = await service.Stylesheet(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
