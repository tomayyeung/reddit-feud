/**
 * #modnote_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { BoolValue, Int64Value, StringValue } from "../../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
function createBaseDeleteNotesRequest() {
    return { subreddit: "", noteId: "", user: "" };
}
export const DeleteNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.noteId !== "") {
            writer.uint32(18).string(message.noteId);
        }
        if (message.user !== "") {
            writer.uint32(26).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.noteId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            noteId: isSet(object.noteId) ? globalThis.String(object.noteId) : "",
            user: isSet(object.user) ? globalThis.String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.noteId !== "") {
            obj.noteId = message.noteId;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return DeleteNotesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.noteId = object.noteId ?? "";
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set(DeleteNotesRequest.$type, DeleteNotesRequest);
function createBaseGetNotesRequest() {
    return { subreddit: "", before: undefined, filter: undefined, limit: undefined, user: "" };
}
export const GetNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.GetNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.before !== undefined) {
            StringValue.encode({ value: message.before }, writer.uint32(18).fork()).ldelim();
        }
        if (message.filter !== undefined) {
            StringValue.encode({ value: message.filter }, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int64Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== "") {
            writer.uint32(42).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.before = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.filter = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.limit = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            before: isSet(object.before) ? String(object.before) : undefined,
            filter: isSet(object.filter) ? String(object.filter) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            user: isSet(object.user) ? globalThis.String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.before !== undefined) {
            obj.before = message.before;
        }
        if (message.filter !== undefined) {
            obj.filter = message.filter;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return GetNotesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.before = object.before ?? undefined;
        message.filter = object.filter ?? undefined;
        message.limit = object.limit ?? undefined;
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set(GetNotesRequest.$type, GetNotesRequest);
function createBasePostNotesRequest() {
    return { subreddit: "", label: undefined, note: "", redditId: undefined, user: "" };
}
export const PostNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.PostNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddit !== "") {
            writer.uint32(10).string(message.subreddit);
        }
        if (message.label !== undefined) {
            writer.uint32(18).string(message.label);
        }
        if (message.note !== "") {
            writer.uint32(26).string(message.note);
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== "") {
            writer.uint32(42).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddit = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.label = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.note = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddit: isSet(object.subreddit) ? globalThis.String(object.subreddit) : "",
            label: isSet(object.label) ? globalThis.String(object.label) : undefined,
            note: isSet(object.note) ? globalThis.String(object.note) : "",
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            user: isSet(object.user) ? globalThis.String(object.user) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddit !== "") {
            obj.subreddit = message.subreddit;
        }
        if (message.label !== undefined) {
            obj.label = message.label;
        }
        if (message.note !== "") {
            obj.note = message.note;
        }
        if (message.redditId !== undefined) {
            obj.redditId = message.redditId;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        return obj;
    },
    create(base) {
        return PostNotesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostNotesRequest();
        message.subreddit = object.subreddit ?? "";
        message.label = object.label ?? undefined;
        message.note = object.note ?? "";
        message.redditId = object.redditId ?? undefined;
        message.user = object.user ?? "";
        return message;
    },
};
messageTypeRegistry.set(PostNotesRequest.$type, PostNotesRequest);
function createBaseRecentNotesRequest() {
    return { subreddits: "", users: "" };
}
export const RecentNotesRequest = {
    $type: "devvit.plugin.redditapi.modnote.RecentNotesRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subreddits !== "") {
            writer.uint32(10).string(message.subreddits);
        }
        if (message.users !== "") {
            writer.uint32(18).string(message.users);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecentNotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subreddits = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.users = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: isSet(object.subreddits) ? globalThis.String(object.subreddits) : "",
            users: isSet(object.users) ? globalThis.String(object.users) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddits !== "") {
            obj.subreddits = message.subreddits;
        }
        if (message.users !== "") {
            obj.users = message.users;
        }
        return obj;
    },
    create(base) {
        return RecentNotesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecentNotesRequest();
        message.subreddits = object.subreddits ?? "";
        message.users = object.users ?? "";
        return message;
    },
};
messageTypeRegistry.set(RecentNotesRequest.$type, RecentNotesRequest);
function createBasePostRemovalNoteRequest() {
    return { itemIds: [], reasonId: "", modNote: undefined };
}
export const PostRemovalNoteRequest = {
    $type: "devvit.plugin.redditapi.modnote.PostRemovalNoteRequest",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.itemIds) {
            writer.uint32(10).string(v);
        }
        if (message.reasonId !== "") {
            writer.uint32(18).string(message.reasonId);
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostRemovalNoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.itemIds.push(reader.string());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reasonId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e) => globalThis.String(e)) : [],
            reasonId: isSet(object.reasonId) ? globalThis.String(object.reasonId) : "",
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.itemIds?.length) {
            obj.itemIds = message.itemIds;
        }
        if (message.reasonId !== "") {
            obj.reasonId = message.reasonId;
        }
        if (message.modNote !== undefined) {
            obj.modNote = message.modNote;
        }
        return obj;
    },
    create(base) {
        return PostRemovalNoteRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostRemovalNoteRequest();
        message.itemIds = object.itemIds?.map((e) => e) || [];
        message.reasonId = object.reasonId ?? "";
        message.modNote = object.modNote ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(PostRemovalNoteRequest.$type, PostRemovalNoteRequest);
function createBaseModNotesResponse() {
    return { modNotes: [], startCursor: undefined, endCursor: undefined, hasNextPage: undefined };
}
export const ModNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.ModNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.modNotes) {
            ModNoteObject.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.startCursor !== undefined) {
            StringValue.encode({ value: message.startCursor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endCursor !== undefined) {
            StringValue.encode({ value: message.endCursor }, writer.uint32(26).fork()).ldelim();
        }
        if (message.hasNextPage !== undefined) {
            BoolValue.encode({ value: message.hasNextPage }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.modNotes.push(ModNoteObject.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.startCursor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.endCursor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.hasNextPage = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            modNotes: globalThis.Array.isArray(object?.modNotes)
                ? object.modNotes.map((e) => ModNoteObject.fromJSON(e))
                : [],
            startCursor: isSet(object.startCursor) ? String(object.startCursor) : undefined,
            endCursor: isSet(object.endCursor) ? String(object.endCursor) : undefined,
            hasNextPage: isSet(object.hasNextPage) ? Boolean(object.hasNextPage) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.modNotes?.length) {
            obj.modNotes = message.modNotes.map((e) => ModNoteObject.toJSON(e));
        }
        if (message.startCursor !== undefined) {
            obj.startCursor = message.startCursor;
        }
        if (message.endCursor !== undefined) {
            obj.endCursor = message.endCursor;
        }
        if (message.hasNextPage !== undefined) {
            obj.hasNextPage = message.hasNextPage;
        }
        return obj;
    },
    create(base) {
        return ModNotesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModNotesResponse();
        message.modNotes = object.modNotes?.map((e) => ModNoteObject.fromPartial(e)) || [];
        message.startCursor = object.startCursor ?? undefined;
        message.endCursor = object.endCursor ?? undefined;
        message.hasNextPage = object.hasNextPage ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ModNotesResponse.$type, ModNotesResponse);
function createBaseDeleteNotesResponse() {
    return { deleted: undefined };
}
export const DeleteNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.DeleteNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.deleted !== undefined) {
            BoolValue.encode({ value: message.deleted }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.deleted = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { deleted: isSet(object.deleted) ? Boolean(object.deleted) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.deleted !== undefined) {
            obj.deleted = message.deleted;
        }
        return obj;
    },
    create(base) {
        return DeleteNotesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteNotesResponse();
        message.deleted = object.deleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(DeleteNotesResponse.$type, DeleteNotesResponse);
function createBaseModNoteObject() {
    return {
        subredditId: undefined,
        operatorId: undefined,
        modActionData: undefined,
        userNoteData: undefined,
        subreddit: undefined,
        user: undefined,
        operator: undefined,
        id: undefined,
        userId: undefined,
        createdAt: undefined,
        cursor: undefined,
        type: undefined,
    };
}
export const ModNoteObject = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject",
    encode(message, writer = _m0.Writer.create()) {
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(10).fork()).ldelim();
        }
        if (message.operatorId !== undefined) {
            StringValue.encode({ value: message.operatorId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.modActionData !== undefined) {
            ModNoteObject_ModActionData.encode(message.modActionData, writer.uint32(26).fork()).ldelim();
        }
        if (message.userNoteData !== undefined) {
            ModNoteObject_UserNoteData.encode(message.userNoteData, writer.uint32(34).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(42).fork()).ldelim();
        }
        if (message.user !== undefined) {
            StringValue.encode({ value: message.user }, writer.uint32(50).fork()).ldelim();
        }
        if (message.operator !== undefined) {
            StringValue.encode({ value: message.operator }, writer.uint32(58).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
        }
        if (message.userId !== undefined) {
            StringValue.encode({ value: message.userId }, writer.uint32(74).fork()).ldelim();
        }
        if (message.createdAt !== undefined) {
            Int64Value.encode({ value: message.createdAt }, writer.uint32(82).fork()).ldelim();
        }
        if (message.cursor !== undefined) {
            StringValue.encode({ value: message.cursor }, writer.uint32(90).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(98).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.operatorId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.modActionData = ModNoteObject_ModActionData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.userNoteData = ModNoteObject_UserNoteData.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.user = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.operator = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.userId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.createdAt = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.cursor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            operatorId: isSet(object.operatorId) ? String(object.operatorId) : undefined,
            modActionData: isSet(object.modActionData)
                ? ModNoteObject_ModActionData.fromJSON(object.modActionData)
                : undefined,
            userNoteData: isSet(object.userNoteData) ? ModNoteObject_UserNoteData.fromJSON(object.userNoteData) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            user: isSet(object.user) ? String(object.user) : undefined,
            operator: isSet(object.operator) ? String(object.operator) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            userId: isSet(object.userId) ? String(object.userId) : undefined,
            createdAt: isSet(object.createdAt) ? Number(object.createdAt) : undefined,
            cursor: isSet(object.cursor) ? String(object.cursor) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subredditId !== undefined) {
            obj.subredditId = message.subredditId;
        }
        if (message.operatorId !== undefined) {
            obj.operatorId = message.operatorId;
        }
        if (message.modActionData !== undefined) {
            obj.modActionData = ModNoteObject_ModActionData.toJSON(message.modActionData);
        }
        if (message.userNoteData !== undefined) {
            obj.userNoteData = ModNoteObject_UserNoteData.toJSON(message.userNoteData);
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.user !== undefined) {
            obj.user = message.user;
        }
        if (message.operator !== undefined) {
            obj.operator = message.operator;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.userId !== undefined) {
            obj.userId = message.userId;
        }
        if (message.createdAt !== undefined) {
            obj.createdAt = message.createdAt;
        }
        if (message.cursor !== undefined) {
            obj.cursor = message.cursor;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        return obj;
    },
    create(base) {
        return ModNoteObject.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModNoteObject();
        message.subredditId = object.subredditId ?? undefined;
        message.operatorId = object.operatorId ?? undefined;
        message.modActionData = (object.modActionData !== undefined && object.modActionData !== null)
            ? ModNoteObject_ModActionData.fromPartial(object.modActionData)
            : undefined;
        message.userNoteData = (object.userNoteData !== undefined && object.userNoteData !== null)
            ? ModNoteObject_UserNoteData.fromPartial(object.userNoteData)
            : undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.user = object.user ?? undefined;
        message.operator = object.operator ?? undefined;
        message.id = object.id ?? undefined;
        message.userId = object.userId ?? undefined;
        message.createdAt = object.createdAt ?? undefined;
        message.cursor = object.cursor ?? undefined;
        message.type = object.type ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ModNoteObject.$type, ModNoteObject);
function createBaseModNoteObject_ModActionData() {
    return { action: undefined, redditId: undefined, details: undefined, description: undefined };
}
export const ModNoteObject_ModActionData = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.ModActionData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.action !== undefined) {
            StringValue.encode({ value: message.action }, writer.uint32(10).fork()).ldelim();
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.details !== undefined) {
            StringValue.encode({ value: message.details }, writer.uint32(26).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject_ModActionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.action = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.details = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            action: isSet(object.action) ? String(object.action) : undefined,
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            details: isSet(object.details) ? String(object.details) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.action !== undefined) {
            obj.action = message.action;
        }
        if (message.redditId !== undefined) {
            obj.redditId = message.redditId;
        }
        if (message.details !== undefined) {
            obj.details = message.details;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return ModNoteObject_ModActionData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModNoteObject_ModActionData();
        message.action = object.action ?? undefined;
        message.redditId = object.redditId ?? undefined;
        message.details = object.details ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ModNoteObject_ModActionData.$type, ModNoteObject_ModActionData);
function createBaseModNoteObject_UserNoteData() {
    return { note: undefined, redditId: undefined, label: undefined };
}
export const ModNoteObject_UserNoteData = {
    $type: "devvit.plugin.redditapi.modnote.ModNoteObject.UserNoteData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.note !== undefined) {
            StringValue.encode({ value: message.note }, writer.uint32(10).fork()).ldelim();
        }
        if (message.redditId !== undefined) {
            StringValue.encode({ value: message.redditId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.label !== undefined) {
            StringValue.encode({ value: message.label }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModNoteObject_UserNoteData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.note = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.redditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.label = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            note: isSet(object.note) ? String(object.note) : undefined,
            redditId: isSet(object.redditId) ? String(object.redditId) : undefined,
            label: isSet(object.label) ? String(object.label) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.note !== undefined) {
            obj.note = message.note;
        }
        if (message.redditId !== undefined) {
            obj.redditId = message.redditId;
        }
        if (message.label !== undefined) {
            obj.label = message.label;
        }
        return obj;
    },
    create(base) {
        return ModNoteObject_UserNoteData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModNoteObject_UserNoteData();
        message.note = object.note ?? undefined;
        message.redditId = object.redditId ?? undefined;
        message.label = object.label ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ModNoteObject_UserNoteData.$type, ModNoteObject_UserNoteData);
function createBasePostModNotesResponse() {
    return { created: undefined };
}
export const PostModNotesResponse = {
    $type: "devvit.plugin.redditapi.modnote.PostModNotesResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.created !== undefined) {
            ModNoteObject.encode(message.created, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostModNotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.created = ModNoteObject.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { created: isSet(object.created) ? ModNoteObject.fromJSON(object.created) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.created !== undefined) {
            obj.created = ModNoteObject.toJSON(message.created);
        }
        return obj;
    },
    create(base) {
        return PostModNotesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostModNotesResponse();
        message.created = (object.created !== undefined && object.created !== null)
            ? ModNoteObject.fromPartial(object.created)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(PostModNotesResponse.$type, PostModNotesResponse);
function isSet(value) {
    return value !== null && value !== undefined;
}
