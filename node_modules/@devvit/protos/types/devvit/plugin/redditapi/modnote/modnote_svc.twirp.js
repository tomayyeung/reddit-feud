import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { GetNotesRequest, ModNotesResponse, DeleteNotesRequest, DeleteNotesResponse, PostNotesRequest, PostModNotesResponse, PostRemovalNoteRequest, RecentNotesRequest, } from './modnote_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
export var ModNoteMethod;
(function (ModNoteMethod) {
    ModNoteMethod["GetNotes"] = "GetNotes";
    ModNoteMethod["DeleteNotes"] = "DeleteNotes";
    ModNoteMethod["PostNotes"] = "PostNotes";
    ModNoteMethod["PostRemovalNote"] = "PostRemovalNote";
    ModNoteMethod["RecentNotes"] = "RecentNotes";
})(ModNoteMethod || (ModNoteMethod = {}));
export const ModNoteMethodList = [
    ModNoteMethod.GetNotes,
    ModNoteMethod.DeleteNotes,
    ModNoteMethod.PostNotes,
    ModNoteMethod.PostRemovalNote,
    ModNoteMethod.RecentNotes,
];
export function createModNoteServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.modnote',
        serviceName: 'ModNote',
        methodList: ModNoteMethodList,
        matchRoute: matchModNoteRoute,
    });
}
function matchModNoteRoute(method, events) {
    switch (method) {
        case 'GetNotes':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetNotes' };
                await events.onMatch(ctx);
                return handleModNoteGetNotesRequest(ctx, service, data, interceptors);
            };
        case 'DeleteNotes':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DeleteNotes' };
                await events.onMatch(ctx);
                return handleModNoteDeleteNotesRequest(ctx, service, data, interceptors);
            };
        case 'PostNotes':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PostNotes' };
                await events.onMatch(ctx);
                return handleModNotePostNotesRequest(ctx, service, data, interceptors);
            };
        case 'PostRemovalNote':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'PostRemovalNote' };
                await events.onMatch(ctx);
                return handleModNotePostRemovalNoteRequest(ctx, service, data, interceptors);
            };
        case 'RecentNotes':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'RecentNotes' };
                await events.onMatch(ctx);
                return handleModNoteRecentNotesRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModNoteGetNotesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModNoteGetNotesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModNoteGetNotesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModNoteDeleteNotesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModNoteDeleteNotesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModNoteDeleteNotesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModNotePostNotesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModNotePostNotesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModNotePostNotesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModNotePostRemovalNoteRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModNotePostRemovalNoteJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModNotePostRemovalNoteProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleModNoteRecentNotesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleModNoteRecentNotesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleModNoteRecentNotesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleModNoteGetNotesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetNotesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNotes(ctx, request);
    }
    return JSON.stringify(ModNotesResponse.toJSON(response));
}
async function handleModNoteDeleteNotesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = DeleteNotesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteNotes(ctx, request);
    }
    return JSON.stringify(DeleteNotesResponse.toJSON(response));
}
async function handleModNotePostNotesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostNotesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PostNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.PostNotes(ctx, request);
    }
    return JSON.stringify(PostModNotesResponse.toJSON(response));
}
async function handleModNotePostRemovalNoteJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = PostRemovalNoteRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PostRemovalNote(ctx, inputReq);
        });
    }
    else {
        response = await service.PostRemovalNote(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleModNoteRecentNotesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = RecentNotesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RecentNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.RecentNotes(ctx, request);
    }
    return JSON.stringify(ModNotesResponse.toJSON(response));
}
async function handleModNoteGetNotesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetNotesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.GetNotes(ctx, request);
    }
    return Buffer.from(ModNotesResponse.encode(response).finish());
}
async function handleModNoteDeleteNotesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = DeleteNotesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DeleteNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.DeleteNotes(ctx, request);
    }
    return Buffer.from(DeleteNotesResponse.encode(response).finish());
}
async function handleModNotePostNotesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostNotesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PostNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.PostNotes(ctx, request);
    }
    return Buffer.from(PostModNotesResponse.encode(response).finish());
}
async function handleModNotePostRemovalNoteProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = PostRemovalNoteRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.PostRemovalNote(ctx, inputReq);
        });
    }
    else {
        response = await service.PostRemovalNote(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleModNoteRecentNotesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = RecentNotesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RecentNotes(ctx, inputReq);
        });
    }
    else {
        response = await service.RecentNotes(ctx, request);
    }
    return Buffer.from(ModNotesResponse.encode(response).finish());
}
