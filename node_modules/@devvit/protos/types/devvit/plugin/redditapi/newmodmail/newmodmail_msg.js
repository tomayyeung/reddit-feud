/**
 * #newmodmail_msg.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Any } from "../../../../google/protobuf/any.js";
import { BoolValue, Int32Value, Int64Value, StringValue } from "../../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
function createBaseConversationData() {
    return {
        isAuto: undefined,
        participant: undefined,
        objIds: [],
        isRepliable: undefined,
        lastUserUpdate: undefined,
        isInternal: undefined,
        lastModUpdate: undefined,
        authors: [],
        lastUpdated: undefined,
        legacyFirstMessageId: undefined,
        state: undefined,
        conversationType: undefined,
        lastUnread: undefined,
        owner: undefined,
        subject: undefined,
        id: undefined,
        isHighlighted: undefined,
        numMessages: undefined,
        modActions: {},
    };
}
export const ConversationData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isAuto !== undefined) {
            BoolValue.encode({ value: message.isAuto }, writer.uint32(10).fork()).ldelim();
        }
        if (message.participant !== undefined) {
            Participant.encode(message.participant, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.objIds) {
            ConversationData_ObjId.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.isRepliable !== undefined) {
            BoolValue.encode({ value: message.isRepliable }, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastUserUpdate !== undefined) {
            StringValue.encode({ value: message.lastUserUpdate }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isInternal !== undefined) {
            BoolValue.encode({ value: message.isInternal }, writer.uint32(50).fork()).ldelim();
        }
        if (message.lastModUpdate !== undefined) {
            StringValue.encode({ value: message.lastModUpdate }, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.authors) {
            Participant.encode(v, writer.uint32(66).fork()).ldelim();
        }
        if (message.lastUpdated !== undefined) {
            StringValue.encode({ value: message.lastUpdated }, writer.uint32(74).fork()).ldelim();
        }
        if (message.legacyFirstMessageId !== undefined) {
            StringValue.encode({ value: message.legacyFirstMessageId }, writer.uint32(82).fork()).ldelim();
        }
        if (message.state !== undefined) {
            Int32Value.encode({ value: message.state }, writer.uint32(90).fork()).ldelim();
        }
        if (message.conversationType !== undefined) {
            StringValue.encode({ value: message.conversationType }, writer.uint32(98).fork()).ldelim();
        }
        if (message.lastUnread !== undefined) {
            StringValue.encode({ value: message.lastUnread }, writer.uint32(106).fork()).ldelim();
        }
        if (message.owner !== undefined) {
            ConversationData_Owner.encode(message.owner, writer.uint32(114).fork()).ldelim();
        }
        if (message.subject !== undefined) {
            StringValue.encode({ value: message.subject }, writer.uint32(122).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(130).fork()).ldelim();
        }
        if (message.isHighlighted !== undefined) {
            BoolValue.encode({ value: message.isHighlighted }, writer.uint32(138).fork()).ldelim();
        }
        if (message.numMessages !== undefined) {
            Int64Value.encode({ value: message.numMessages }, writer.uint32(146).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            ConversationData_ModActionsEntry.encode({ key: key, value }, writer.uint32(154).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.isAuto = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.participant = Participant.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.objIds.push(ConversationData_ObjId.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.isRepliable = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.lastUserUpdate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.lastModUpdate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.authors.push(Participant.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.legacyFirstMessageId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.state = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.conversationType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.lastUnread = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.owner = ConversationData_Owner.decode(reader, reader.uint32());
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.subject = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 17:
                    if (tag !== 138) {
                        break;
                    }
                    message.isHighlighted = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 18:
                    if (tag !== 146) {
                        break;
                    }
                    message.numMessages = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 19:
                    if (tag !== 154) {
                        break;
                    }
                    const entry19 = ConversationData_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry19.value !== undefined) {
                        message.modActions[entry19.key] = entry19.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            isAuto: isSet(object.isAuto) ? Boolean(object.isAuto) : undefined,
            participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
            objIds: globalThis.Array.isArray(object?.objIds)
                ? object.objIds.map((e) => ConversationData_ObjId.fromJSON(e))
                : [],
            isRepliable: isSet(object.isRepliable) ? Boolean(object.isRepliable) : undefined,
            lastUserUpdate: isSet(object.lastUserUpdate) ? String(object.lastUserUpdate) : undefined,
            isInternal: isSet(object.isInternal) ? Boolean(object.isInternal) : undefined,
            lastModUpdate: isSet(object.lastModUpdate) ? String(object.lastModUpdate) : undefined,
            authors: globalThis.Array.isArray(object?.authors) ? object.authors.map((e) => Participant.fromJSON(e)) : [],
            lastUpdated: isSet(object.lastUpdated) ? String(object.lastUpdated) : undefined,
            legacyFirstMessageId: isSet(object.legacyFirstMessageId) ? String(object.legacyFirstMessageId) : undefined,
            state: isSet(object.state) ? Number(object.state) : undefined,
            conversationType: isSet(object.conversationType) ? String(object.conversationType) : undefined,
            lastUnread: isSet(object.lastUnread) ? String(object.lastUnread) : undefined,
            owner: isSet(object.owner) ? ConversationData_Owner.fromJSON(object.owner) : undefined,
            subject: isSet(object.subject) ? String(object.subject) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            isHighlighted: isSet(object.isHighlighted) ? Boolean(object.isHighlighted) : undefined,
            numMessages: isSet(object.numMessages) ? Number(object.numMessages) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.isAuto !== undefined) {
            obj.isAuto = message.isAuto;
        }
        if (message.participant !== undefined) {
            obj.participant = Participant.toJSON(message.participant);
        }
        if (message.objIds?.length) {
            obj.objIds = message.objIds.map((e) => ConversationData_ObjId.toJSON(e));
        }
        if (message.isRepliable !== undefined) {
            obj.isRepliable = message.isRepliable;
        }
        if (message.lastUserUpdate !== undefined) {
            obj.lastUserUpdate = message.lastUserUpdate;
        }
        if (message.isInternal !== undefined) {
            obj.isInternal = message.isInternal;
        }
        if (message.lastModUpdate !== undefined) {
            obj.lastModUpdate = message.lastModUpdate;
        }
        if (message.authors?.length) {
            obj.authors = message.authors.map((e) => Participant.toJSON(e));
        }
        if (message.lastUpdated !== undefined) {
            obj.lastUpdated = message.lastUpdated;
        }
        if (message.legacyFirstMessageId !== undefined) {
            obj.legacyFirstMessageId = message.legacyFirstMessageId;
        }
        if (message.state !== undefined) {
            obj.state = message.state;
        }
        if (message.conversationType !== undefined) {
            obj.conversationType = message.conversationType;
        }
        if (message.lastUnread !== undefined) {
            obj.lastUnread = message.lastUnread;
        }
        if (message.owner !== undefined) {
            obj.owner = ConversationData_Owner.toJSON(message.owner);
        }
        if (message.subject !== undefined) {
            obj.subject = message.subject;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.isHighlighted !== undefined) {
            obj.isHighlighted = message.isHighlighted;
        }
        if (message.numMessages !== undefined) {
            obj.numMessages = message.numMessages;
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ConversationData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationData();
        message.isAuto = object.isAuto ?? undefined;
        message.participant = (object.participant !== undefined && object.participant !== null)
            ? Participant.fromPartial(object.participant)
            : undefined;
        message.objIds = object.objIds?.map((e) => ConversationData_ObjId.fromPartial(e)) || [];
        message.isRepliable = object.isRepliable ?? undefined;
        message.lastUserUpdate = object.lastUserUpdate ?? undefined;
        message.isInternal = object.isInternal ?? undefined;
        message.lastModUpdate = object.lastModUpdate ?? undefined;
        message.authors = object.authors?.map((e) => Participant.fromPartial(e)) || [];
        message.lastUpdated = object.lastUpdated ?? undefined;
        message.legacyFirstMessageId = object.legacyFirstMessageId ?? undefined;
        message.state = object.state ?? undefined;
        message.conversationType = object.conversationType ?? undefined;
        message.lastUnread = object.lastUnread ?? undefined;
        message.owner = (object.owner !== undefined && object.owner !== null)
            ? ConversationData_Owner.fromPartial(object.owner)
            : undefined;
        message.subject = object.subject ?? undefined;
        message.id = object.id ?? undefined;
        message.isHighlighted = object.isHighlighted ?? undefined;
        message.numMessages = object.numMessages ?? undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(ConversationData.$type, ConversationData);
function createBaseConversationData_ObjId() {
    return { id: undefined, key: undefined };
}
export const ConversationData_ObjId = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ObjId",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        if (message.key !== undefined) {
            StringValue.encode({ value: message.key }, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_ObjId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.key = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            key: isSet(object.key) ? String(object.key) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.key !== undefined) {
            obj.key = message.key;
        }
        return obj;
    },
    create(base) {
        return ConversationData_ObjId.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationData_ObjId();
        message.id = object.id ?? undefined;
        message.key = object.key ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationData_ObjId.$type, ConversationData_ObjId);
function createBaseConversationData_Owner() {
    return { displayName: undefined, type: undefined, id: undefined };
}
export const ConversationData_Owner = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.Owner",
    encode(message, writer = _m0.Writer.create()) {
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(10).fork()).ldelim();
        }
        if (message.type !== undefined) {
            StringValue.encode({ value: message.type }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_Owner();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.type = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            type: isSet(object.type) ? String(object.type) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.displayName !== undefined) {
            obj.displayName = message.displayName;
        }
        if (message.type !== undefined) {
            obj.type = message.type;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return ConversationData_Owner.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationData_Owner();
        message.displayName = object.displayName ?? undefined;
        message.type = object.type ?? undefined;
        message.id = object.id ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationData_Owner.$type, ConversationData_Owner);
function createBaseConversationData_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ConversationData_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationData.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationData_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ConversationData_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationData_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationData_ModActionsEntry.$type, ConversationData_ModActionsEntry);
function createBaseMessageData() {
    return {
        body: undefined,
        author: undefined,
        isInternal: undefined,
        date: undefined,
        bodyMarkdown: undefined,
        id: undefined,
        participatingAs: undefined,
    };
}
export const MessageData = {
    $type: "devvit.plugin.redditapi.newmodmail.MessageData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== undefined) {
            StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
        }
        if (message.author !== undefined) {
            Participant.encode(message.author, writer.uint32(18).fork()).ldelim();
        }
        if (message.isInternal !== undefined) {
            BoolValue.encode({ value: message.isInternal }, writer.uint32(26).fork()).ldelim();
        }
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(34).fork()).ldelim();
        }
        if (message.bodyMarkdown !== undefined) {
            StringValue.encode({ value: message.bodyMarkdown }, writer.uint32(42).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(50).fork()).ldelim();
        }
        if (message.participatingAs !== undefined) {
            StringValue.encode({ value: message.participatingAs }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.body = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.author = Participant.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.isInternal = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.bodyMarkdown = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.participatingAs = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? String(object.body) : undefined,
            author: isSet(object.author) ? Participant.fromJSON(object.author) : undefined,
            isInternal: isSet(object.isInternal) ? Boolean(object.isInternal) : undefined,
            date: isSet(object.date) ? String(object.date) : undefined,
            bodyMarkdown: isSet(object.bodyMarkdown) ? String(object.bodyMarkdown) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            participatingAs: isSet(object.participatingAs) ? String(object.participatingAs) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.body !== undefined) {
            obj.body = message.body;
        }
        if (message.author !== undefined) {
            obj.author = Participant.toJSON(message.author);
        }
        if (message.isInternal !== undefined) {
            obj.isInternal = message.isInternal;
        }
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.bodyMarkdown !== undefined) {
            obj.bodyMarkdown = message.bodyMarkdown;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.participatingAs !== undefined) {
            obj.participatingAs = message.participatingAs;
        }
        return obj;
    },
    create(base) {
        return MessageData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageData();
        message.body = object.body ?? undefined;
        message.author = (object.author !== undefined && object.author !== null)
            ? Participant.fromPartial(object.author)
            : undefined;
        message.isInternal = object.isInternal ?? undefined;
        message.date = object.date ?? undefined;
        message.bodyMarkdown = object.bodyMarkdown ?? undefined;
        message.id = object.id ?? undefined;
        message.participatingAs = object.participatingAs ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(MessageData.$type, MessageData);
function createBaseConversationUserData() {
    return {
        recentComments: {},
        muteStatus: undefined,
        name: undefined,
        created: undefined,
        banStatus: undefined,
        isSuspended: undefined,
        approveStatus: undefined,
        isShadowBanned: undefined,
        recentPosts: {},
        recentConvos: {},
        id: undefined,
    };
}
export const ConversationUserData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.recentComments).forEach(([key, value]) => {
            ConversationUserData_RecentCommentsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        if (message.muteStatus !== undefined) {
            ConversationUserData_MuteStatus.encode(message.muteStatus, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.created !== undefined) {
            StringValue.encode({ value: message.created }, writer.uint32(34).fork()).ldelim();
        }
        if (message.banStatus !== undefined) {
            ConversationUserData_BanStatus.encode(message.banStatus, writer.uint32(42).fork()).ldelim();
        }
        if (message.isSuspended !== undefined) {
            BoolValue.encode({ value: message.isSuspended }, writer.uint32(50).fork()).ldelim();
        }
        if (message.approveStatus !== undefined) {
            ConversationUserData_ApproveStatus.encode(message.approveStatus, writer.uint32(58).fork()).ldelim();
        }
        if (message.isShadowBanned !== undefined) {
            BoolValue.encode({ value: message.isShadowBanned }, writer.uint32(66).fork()).ldelim();
        }
        Object.entries(message.recentPosts).forEach(([key, value]) => {
            ConversationUserData_RecentPostsEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        Object.entries(message.recentConvos).forEach(([key, value]) => {
            ConversationUserData_RecentConvosEntry.encode({ key: key, value }, writer.uint32(82).fork()).ldelim();
        });
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = ConversationUserData_RecentCommentsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.recentComments[entry1.key] = entry1.value;
                    }
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.muteStatus = ConversationUserData_MuteStatus.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.created = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.banStatus = ConversationUserData_BanStatus.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.isSuspended = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.approveStatus = ConversationUserData_ApproveStatus.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.isShadowBanned = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    const entry9 = ConversationUserData_RecentPostsEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.recentPosts[entry9.key] = entry9.value;
                    }
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    const entry10 = ConversationUserData_RecentConvosEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.recentConvos[entry10.key] = entry10.value;
                    }
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            recentComments: isObject(object.recentComments)
                ? Object.entries(object.recentComments).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_CommentData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            muteStatus: isSet(object.muteStatus) ? ConversationUserData_MuteStatus.fromJSON(object.muteStatus) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            created: isSet(object.created) ? String(object.created) : undefined,
            banStatus: isSet(object.banStatus) ? ConversationUserData_BanStatus.fromJSON(object.banStatus) : undefined,
            isSuspended: isSet(object.isSuspended) ? Boolean(object.isSuspended) : undefined,
            approveStatus: isSet(object.approveStatus)
                ? ConversationUserData_ApproveStatus.fromJSON(object.approveStatus)
                : undefined,
            isShadowBanned: isSet(object.isShadowBanned) ? Boolean(object.isShadowBanned) : undefined,
            recentPosts: isObject(object.recentPosts)
                ? Object.entries(object.recentPosts).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_PostData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            recentConvos: isObject(object.recentConvos)
                ? Object.entries(object.recentConvos).reduce((acc, [key, value]) => {
                    acc[key] = ConversationUserData_ConvoData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            id: isSet(object.id) ? String(object.id) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.recentComments) {
            const entries = Object.entries(message.recentComments);
            if (entries.length > 0) {
                obj.recentComments = {};
                entries.forEach(([k, v]) => {
                    obj.recentComments[k] = ConversationUserData_CommentData.toJSON(v);
                });
            }
        }
        if (message.muteStatus !== undefined) {
            obj.muteStatus = ConversationUserData_MuteStatus.toJSON(message.muteStatus);
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.created !== undefined) {
            obj.created = message.created;
        }
        if (message.banStatus !== undefined) {
            obj.banStatus = ConversationUserData_BanStatus.toJSON(message.banStatus);
        }
        if (message.isSuspended !== undefined) {
            obj.isSuspended = message.isSuspended;
        }
        if (message.approveStatus !== undefined) {
            obj.approveStatus = ConversationUserData_ApproveStatus.toJSON(message.approveStatus);
        }
        if (message.isShadowBanned !== undefined) {
            obj.isShadowBanned = message.isShadowBanned;
        }
        if (message.recentPosts) {
            const entries = Object.entries(message.recentPosts);
            if (entries.length > 0) {
                obj.recentPosts = {};
                entries.forEach(([k, v]) => {
                    obj.recentPosts[k] = ConversationUserData_PostData.toJSON(v);
                });
            }
        }
        if (message.recentConvos) {
            const entries = Object.entries(message.recentConvos);
            if (entries.length > 0) {
                obj.recentConvos = {};
                entries.forEach(([k, v]) => {
                    obj.recentConvos[k] = ConversationUserData_ConvoData.toJSON(v);
                });
            }
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData();
        message.recentComments = Object.entries(object.recentComments ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_CommentData.fromPartial(value);
            }
            return acc;
        }, {});
        message.muteStatus = (object.muteStatus !== undefined && object.muteStatus !== null)
            ? ConversationUserData_MuteStatus.fromPartial(object.muteStatus)
            : undefined;
        message.name = object.name ?? undefined;
        message.created = object.created ?? undefined;
        message.banStatus = (object.banStatus !== undefined && object.banStatus !== null)
            ? ConversationUserData_BanStatus.fromPartial(object.banStatus)
            : undefined;
        message.isSuspended = object.isSuspended ?? undefined;
        message.approveStatus = (object.approveStatus !== undefined && object.approveStatus !== null)
            ? ConversationUserData_ApproveStatus.fromPartial(object.approveStatus)
            : undefined;
        message.isShadowBanned = object.isShadowBanned ?? undefined;
        message.recentPosts = Object.entries(object.recentPosts ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_PostData.fromPartial(value);
            }
            return acc;
        }, {});
        message.recentConvos = Object.entries(object.recentConvos ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationUserData_ConvoData.fromPartial(value);
            }
            return acc;
        }, {});
        message.id = object.id ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData.$type, ConversationUserData);
function createBaseConversationUserData_CommentData() {
    return { comment: undefined, date: undefined, permalink: undefined, title: undefined };
}
export const ConversationUserData_CommentData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.CommentData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.comment !== undefined) {
            StringValue.encode({ value: message.comment }, writer.uint32(10).fork()).ldelim();
        }
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(18).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(26).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_CommentData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.comment = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            comment: isSet(object.comment) ? String(object.comment) : undefined,
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.comment !== undefined) {
            obj.comment = message.comment;
        }
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.permalink !== undefined) {
            obj.permalink = message.permalink;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_CommentData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_CommentData();
        message.comment = object.comment ?? undefined;
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_CommentData.$type, ConversationUserData_CommentData);
function createBaseConversationUserData_MuteStatus() {
    return { muteCount: undefined, isMuted: undefined, endDate: undefined, reason: undefined };
}
export const ConversationUserData_MuteStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.MuteStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.muteCount !== undefined) {
            Int64Value.encode({ value: message.muteCount }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isMuted !== undefined) {
            BoolValue.encode({ value: message.isMuted }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_MuteStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.muteCount = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.isMuted = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            muteCount: isSet(object.muteCount) ? Number(object.muteCount) : undefined,
            isMuted: isSet(object.isMuted) ? Boolean(object.isMuted) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.muteCount !== undefined) {
            obj.muteCount = message.muteCount;
        }
        if (message.isMuted !== undefined) {
            obj.isMuted = message.isMuted;
        }
        if (message.endDate !== undefined) {
            obj.endDate = message.endDate;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_MuteStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_MuteStatus();
        message.muteCount = object.muteCount ?? undefined;
        message.isMuted = object.isMuted ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_MuteStatus.$type, ConversationUserData_MuteStatus);
function createBaseConversationUserData_BanStatus() {
    return { isBanned: undefined, isPermanent: undefined, endDate: undefined, reason: undefined };
}
export const ConversationUserData_BanStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.BanStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isBanned !== undefined) {
            BoolValue.encode({ value: message.isBanned }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isPermanent !== undefined) {
            BoolValue.encode({ value: message.isPermanent }, writer.uint32(18).fork()).ldelim();
        }
        if (message.endDate !== undefined) {
            StringValue.encode({ value: message.endDate }, writer.uint32(26).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_BanStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.isBanned = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.isPermanent = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.endDate = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            isBanned: isSet(object.isBanned) ? Boolean(object.isBanned) : undefined,
            isPermanent: isSet(object.isPermanent) ? Boolean(object.isPermanent) : undefined,
            endDate: isSet(object.endDate) ? String(object.endDate) : undefined,
            reason: isSet(object.reason) ? String(object.reason) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.isBanned !== undefined) {
            obj.isBanned = message.isBanned;
        }
        if (message.isPermanent !== undefined) {
            obj.isPermanent = message.isPermanent;
        }
        if (message.endDate !== undefined) {
            obj.endDate = message.endDate;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_BanStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_BanStatus();
        message.isBanned = object.isBanned ?? undefined;
        message.isPermanent = object.isPermanent ?? undefined;
        message.endDate = object.endDate ?? undefined;
        message.reason = object.reason ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_BanStatus.$type, ConversationUserData_BanStatus);
function createBaseConversationUserData_ApproveStatus() {
    return { isApproved: undefined };
}
export const ConversationUserData_ApproveStatus = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ApproveStatus",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isApproved !== undefined) {
            BoolValue.encode({ value: message.isApproved }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_ApproveStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { isApproved: isSet(object.isApproved) ? Boolean(object.isApproved) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.isApproved !== undefined) {
            obj.isApproved = message.isApproved;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_ApproveStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_ApproveStatus();
        message.isApproved = object.isApproved ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_ApproveStatus.$type, ConversationUserData_ApproveStatus);
function createBaseConversationUserData_PostData() {
    return { date: undefined, permalink: undefined, title: undefined };
}
export const ConversationUserData_PostData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.PostData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_PostData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.permalink !== undefined) {
            obj.permalink = message.permalink;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_PostData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_PostData();
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_PostData.$type, ConversationUserData_PostData);
function createBaseConversationUserData_ConvoData() {
    return { date: undefined, permalink: undefined, id: undefined, subject: undefined };
}
export const ConversationUserData_ConvoData = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.ConvoData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.subject !== undefined) {
            StringValue.encode({ value: message.subject }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_ConvoData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.subject = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            subject: isSet(object.subject) ? String(object.subject) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.permalink !== undefined) {
            obj.permalink = message.permalink;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.subject !== undefined) {
            obj.subject = message.subject;
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_ConvoData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_ConvoData();
        message.date = object.date ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.id = object.id ?? undefined;
        message.subject = object.subject ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_ConvoData.$type, ConversationUserData_ConvoData);
function createBaseConversationUserData_RecentCommentsEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentCommentsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentCommentsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_CommentData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentCommentsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ConversationUserData_CommentData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_CommentData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ConversationUserData_CommentData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_RecentCommentsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentCommentsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_CommentData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_RecentCommentsEntry.$type, ConversationUserData_RecentCommentsEntry);
function createBaseConversationUserData_RecentPostsEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentPostsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentPostsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_PostData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentPostsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ConversationUserData_PostData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_PostData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ConversationUserData_PostData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_RecentPostsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentPostsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_PostData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_RecentPostsEntry.$type, ConversationUserData_RecentPostsEntry);
function createBaseConversationUserData_RecentConvosEntry() {
    return { key: "", value: undefined };
}
export const ConversationUserData_RecentConvosEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ConversationUserData.RecentConvosEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationUserData_ConvoData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationUserData_RecentConvosEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ConversationUserData_ConvoData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ConversationUserData_ConvoData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ConversationUserData_ConvoData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ConversationUserData_RecentConvosEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationUserData_RecentConvosEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationUserData_ConvoData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ConversationUserData_RecentConvosEntry.$type, ConversationUserData_RecentConvosEntry);
function createBaseParticipant() {
    return {
        isMod: undefined,
        isAdmin: undefined,
        name: undefined,
        isOp: undefined,
        isParticipant: undefined,
        isApproved: undefined,
        isHidden: undefined,
        id: undefined,
        isDeleted: undefined,
    };
}
export const Participant = {
    $type: "devvit.plugin.redditapi.newmodmail.Participant",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isAdmin !== undefined) {
            BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.isOp !== undefined) {
            BoolValue.encode({ value: message.isOp }, writer.uint32(34).fork()).ldelim();
        }
        if (message.isParticipant !== undefined) {
            BoolValue.encode({ value: message.isParticipant }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isApproved !== undefined) {
            BoolValue.encode({ value: message.isApproved }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isHidden !== undefined) {
            BoolValue.encode({ value: message.isHidden }, writer.uint32(58).fork()).ldelim();
        }
        if (message.id !== undefined) {
            Int64Value.encode({ value: message.id }, writer.uint32(66).fork()).ldelim();
        }
        if (message.isDeleted !== undefined) {
            BoolValue.encode({ value: message.isDeleted }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParticipant();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.isOp = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.isParticipant = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.isApproved = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.id = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            isAdmin: isSet(object.isAdmin) ? Boolean(object.isAdmin) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isOp: isSet(object.isOp) ? Boolean(object.isOp) : undefined,
            isParticipant: isSet(object.isParticipant) ? Boolean(object.isParticipant) : undefined,
            isApproved: isSet(object.isApproved) ? Boolean(object.isApproved) : undefined,
            isHidden: isSet(object.isHidden) ? Boolean(object.isHidden) : undefined,
            id: isSet(object.id) ? Number(object.id) : undefined,
            isDeleted: isSet(object.isDeleted) ? Boolean(object.isDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.isMod !== undefined) {
            obj.isMod = message.isMod;
        }
        if (message.isAdmin !== undefined) {
            obj.isAdmin = message.isAdmin;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.isOp !== undefined) {
            obj.isOp = message.isOp;
        }
        if (message.isParticipant !== undefined) {
            obj.isParticipant = message.isParticipant;
        }
        if (message.isApproved !== undefined) {
            obj.isApproved = message.isApproved;
        }
        if (message.isHidden !== undefined) {
            obj.isHidden = message.isHidden;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.isDeleted !== undefined) {
            obj.isDeleted = message.isDeleted;
        }
        return obj;
    },
    create(base) {
        return Participant.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParticipant();
        message.isMod = object.isMod ?? undefined;
        message.isAdmin = object.isAdmin ?? undefined;
        message.name = object.name ?? undefined;
        message.isOp = object.isOp ?? undefined;
        message.isParticipant = object.isParticipant ?? undefined;
        message.isApproved = object.isApproved ?? undefined;
        message.isHidden = object.isHidden ?? undefined;
        message.id = object.id ?? undefined;
        message.isDeleted = object.isDeleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Participant.$type, Participant);
function createBaseModActionData() {
    return { date: undefined, actionTypeId: undefined, id: undefined, author: undefined };
}
export const ModActionData = {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.date !== undefined) {
            StringValue.encode({ value: message.date }, writer.uint32(10).fork()).ldelim();
        }
        if (message.actionTypeId !== undefined) {
            Int32Value.encode({ value: message.actionTypeId }, writer.uint32(18).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(26).fork()).ldelim();
        }
        if (message.author !== undefined) {
            ModActionData_ModActionAuthor.encode(message.author, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModActionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.date = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.actionTypeId = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.author = ModActionData_ModActionAuthor.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            date: isSet(object.date) ? String(object.date) : undefined,
            actionTypeId: isSet(object.actionTypeId) ? Number(object.actionTypeId) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            author: isSet(object.author) ? ModActionData_ModActionAuthor.fromJSON(object.author) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.date !== undefined) {
            obj.date = message.date;
        }
        if (message.actionTypeId !== undefined) {
            obj.actionTypeId = message.actionTypeId;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.author !== undefined) {
            obj.author = ModActionData_ModActionAuthor.toJSON(message.author);
        }
        return obj;
    },
    create(base) {
        return ModActionData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModActionData();
        message.date = object.date ?? undefined;
        message.actionTypeId = object.actionTypeId ?? undefined;
        message.id = object.id ?? undefined;
        message.author = (object.author !== undefined && object.author !== null)
            ? ModActionData_ModActionAuthor.fromPartial(object.author)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ModActionData.$type, ModActionData);
function createBaseModActionData_ModActionAuthor() {
    return {
        isMod: undefined,
        isAdmin: undefined,
        name: undefined,
        isHidden: undefined,
        id: undefined,
        isDeleted: undefined,
    };
}
export const ModActionData_ModActionAuthor = {
    $type: "devvit.plugin.redditapi.newmodmail.ModActionData.ModActionAuthor",
    encode(message, writer = _m0.Writer.create()) {
        if (message.isMod !== undefined) {
            BoolValue.encode({ value: message.isMod }, writer.uint32(10).fork()).ldelim();
        }
        if (message.isAdmin !== undefined) {
            BoolValue.encode({ value: message.isAdmin }, writer.uint32(18).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(26).fork()).ldelim();
        }
        if (message.isHidden !== undefined) {
            BoolValue.encode({ value: message.isHidden }, writer.uint32(34).fork()).ldelim();
        }
        if (message.id !== undefined) {
            Int64Value.encode({ value: message.id }, writer.uint32(42).fork()).ldelim();
        }
        if (message.isDeleted !== undefined) {
            BoolValue.encode({ value: message.isDeleted }, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModActionData_ModActionAuthor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.isMod = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.isAdmin = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.isHidden = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.id = Int64Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.isDeleted = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            isMod: isSet(object.isMod) ? Boolean(object.isMod) : undefined,
            isAdmin: isSet(object.isAdmin) ? Boolean(object.isAdmin) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            isHidden: isSet(object.isHidden) ? Boolean(object.isHidden) : undefined,
            id: isSet(object.id) ? Number(object.id) : undefined,
            isDeleted: isSet(object.isDeleted) ? Boolean(object.isDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.isMod !== undefined) {
            obj.isMod = message.isMod;
        }
        if (message.isAdmin !== undefined) {
            obj.isAdmin = message.isAdmin;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.isHidden !== undefined) {
            obj.isHidden = message.isHidden;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.isDeleted !== undefined) {
            obj.isDeleted = message.isDeleted;
        }
        return obj;
    },
    create(base) {
        return ModActionData_ModActionAuthor.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModActionData_ModActionAuthor();
        message.isMod = object.isMod ?? undefined;
        message.isAdmin = object.isAdmin ?? undefined;
        message.name = object.name ?? undefined;
        message.isHidden = object.isHidden ?? undefined;
        message.id = object.id ?? undefined;
        message.isDeleted = object.isDeleted ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ModActionData_ModActionAuthor.$type, ModActionData_ModActionAuthor);
function createBaseBulkReadConversationsRequest() {
    return { entity: "", state: "" };
}
export const BulkReadConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.entity !== "") {
            writer.uint32(10).string(message.entity);
        }
        if (message.state !== "") {
            writer.uint32(18).string(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBulkReadConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.entity = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.state = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
            state: isSet(object.state) ? globalThis.String(object.state) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.entity !== "") {
            obj.entity = message.entity;
        }
        if (message.state !== "") {
            obj.state = message.state;
        }
        return obj;
    },
    create(base) {
        return BulkReadConversationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBulkReadConversationsRequest();
        message.entity = object.entity ?? "";
        message.state = object.state ?? "";
        return message;
    },
};
messageTypeRegistry.set(BulkReadConversationsRequest.$type, BulkReadConversationsRequest);
function createBaseGetConversationsRequest() {
    return { after: undefined, entity: undefined, limit: undefined, sort: undefined, state: undefined };
}
export const GetConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.after !== undefined) {
            StringValue.encode({ value: message.after }, writer.uint32(10).fork()).ldelim();
        }
        if (message.entity !== undefined) {
            StringValue.encode({ value: message.entity }, writer.uint32(18).fork()).ldelim();
        }
        if (message.limit !== undefined) {
            Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();
        }
        if (message.sort !== undefined) {
            StringValue.encode({ value: message.sort }, writer.uint32(34).fork()).ldelim();
        }
        if (message.state !== undefined) {
            StringValue.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.after = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.entity = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.limit = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sort = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.state = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            after: isSet(object.after) ? String(object.after) : undefined,
            entity: isSet(object.entity) ? String(object.entity) : undefined,
            limit: isSet(object.limit) ? Number(object.limit) : undefined,
            sort: isSet(object.sort) ? String(object.sort) : undefined,
            state: isSet(object.state) ? String(object.state) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.after !== undefined) {
            obj.after = message.after;
        }
        if (message.entity !== undefined) {
            obj.entity = message.entity;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        if (message.sort !== undefined) {
            obj.sort = message.sort;
        }
        if (message.state !== undefined) {
            obj.state = message.state;
        }
        return obj;
    },
    create(base) {
        return GetConversationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationsRequest();
        message.after = object.after ?? undefined;
        message.entity = object.entity ?? undefined;
        message.limit = object.limit ?? undefined;
        message.sort = object.sort ?? undefined;
        message.state = object.state ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationsRequest.$type, GetConversationsRequest);
function createBaseCreateConversationRequest() {
    return { body: "", isAuthorHidden: false, srName: "", subject: "", to: undefined };
}
export const CreateConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== "") {
            writer.uint32(10).string(message.body);
        }
        if (message.isAuthorHidden !== false) {
            writer.uint32(16).bool(message.isAuthorHidden);
        }
        if (message.srName !== "") {
            writer.uint32(26).string(message.srName);
        }
        if (message.subject !== "") {
            writer.uint32(34).string(message.subject);
        }
        if (message.to !== undefined) {
            StringValue.encode({ value: message.to }, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.body = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.isAuthorHidden = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.srName = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.subject = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.to = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? globalThis.String(object.body) : "",
            isAuthorHidden: isSet(object.isAuthorHidden) ? globalThis.Boolean(object.isAuthorHidden) : false,
            srName: isSet(object.srName) ? globalThis.String(object.srName) : "",
            subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
            to: isSet(object.to) ? String(object.to) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.body !== "") {
            obj.body = message.body;
        }
        if (message.isAuthorHidden !== false) {
            obj.isAuthorHidden = message.isAuthorHidden;
        }
        if (message.srName !== "") {
            obj.srName = message.srName;
        }
        if (message.subject !== "") {
            obj.subject = message.subject;
        }
        if (message.to !== undefined) {
            obj.to = message.to;
        }
        return obj;
    },
    create(base) {
        return CreateConversationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationRequest();
        message.body = object.body ?? "";
        message.isAuthorHidden = object.isAuthorHidden ?? false;
        message.srName = object.srName ?? "";
        message.subject = object.subject ?? "";
        message.to = object.to ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationRequest.$type, CreateConversationRequest);
function createBaseGetConversationRequest() {
    return { conversationId: "", markRead: false };
}
export const GetConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.markRead !== false) {
            writer.uint32(16).bool(message.markRead);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.markRead = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
            markRead: isSet(object.markRead) ? globalThis.Boolean(object.markRead) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationId !== "") {
            obj.conversationId = message.conversationId;
        }
        if (message.markRead !== false) {
            obj.markRead = message.markRead;
        }
        return obj;
    },
    create(base) {
        return GetConversationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationRequest();
        message.conversationId = object.conversationId ?? "";
        message.markRead = object.markRead ?? false;
        return message;
    },
};
messageTypeRegistry.set(GetConversationRequest.$type, GetConversationRequest);
function createBaseCreateConversationMessageRequest() {
    return { body: "", isAuthorHidden: false, isInternal: false, conversationId: "" };
}
export const CreateConversationMessageRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== "") {
            writer.uint32(10).string(message.body);
        }
        if (message.isAuthorHidden !== false) {
            writer.uint32(16).bool(message.isAuthorHidden);
        }
        if (message.isInternal !== false) {
            writer.uint32(24).bool(message.isInternal);
        }
        if (message.conversationId !== "") {
            writer.uint32(34).string(message.conversationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.body = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.isAuthorHidden = reader.bool();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.isInternal = reader.bool();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.conversationId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? globalThis.String(object.body) : "",
            isAuthorHidden: isSet(object.isAuthorHidden) ? globalThis.Boolean(object.isAuthorHidden) : false,
            isInternal: isSet(object.isInternal) ? globalThis.Boolean(object.isInternal) : false,
            conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.body !== "") {
            obj.body = message.body;
        }
        if (message.isAuthorHidden !== false) {
            obj.isAuthorHidden = message.isAuthorHidden;
        }
        if (message.isInternal !== false) {
            obj.isInternal = message.isInternal;
        }
        if (message.conversationId !== "") {
            obj.conversationId = message.conversationId;
        }
        return obj;
    },
    create(base) {
        return CreateConversationMessageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageRequest();
        message.body = object.body ?? "";
        message.isAuthorHidden = object.isAuthorHidden ?? false;
        message.isInternal = object.isInternal ?? false;
        message.conversationId = object.conversationId ?? "";
        return message;
    },
};
messageTypeRegistry.set(CreateConversationMessageRequest.$type, CreateConversationMessageRequest);
function createBaseBasicConversationRequest() {
    return { conversationId: "" };
}
export const BasicConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationId !== "") {
            obj.conversationId = message.conversationId;
        }
        return obj;
    },
    create(base) {
        return BasicConversationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBasicConversationRequest();
        message.conversationId = object.conversationId ?? "";
        return message;
    },
};
messageTypeRegistry.set(BasicConversationRequest.$type, BasicConversationRequest);
function createBaseBasicConversationsRequest() {
    return { conversationIds: "" };
}
export const BasicConversationsRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.BasicConversationsRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationIds !== "") {
            writer.uint32(10).string(message.conversationIds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicConversationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationIds = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { conversationIds: isSet(object.conversationIds) ? globalThis.String(object.conversationIds) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationIds !== "") {
            obj.conversationIds = message.conversationIds;
        }
        return obj;
    },
    create(base) {
        return BasicConversationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBasicConversationsRequest();
        message.conversationIds = object.conversationIds ?? "";
        return message;
    },
};
messageTypeRegistry.set(BasicConversationsRequest.$type, BasicConversationsRequest);
function createBaseMuteConversationRequest() {
    return { conversationId: "", numHours: 0 };
}
export const MuteConversationRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.numHours !== 0) {
            writer.uint32(16).int32(message.numHours);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.numHours = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
            numHours: isSet(object.numHours) ? globalThis.Number(object.numHours) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationId !== "") {
            obj.conversationId = message.conversationId;
        }
        if (message.numHours !== 0) {
            obj.numHours = Math.round(message.numHours);
        }
        return obj;
    },
    create(base) {
        return MuteConversationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMuteConversationRequest();
        message.conversationId = object.conversationId ?? "";
        message.numHours = object.numHours ?? 0;
        return message;
    },
};
messageTypeRegistry.set(MuteConversationRequest.$type, MuteConversationRequest);
function createBaseTempBanRequest() {
    return { conversationId: "", duration: 0 };
}
export const TempBanRequest = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversationId !== "") {
            writer.uint32(10).string(message.conversationId);
        }
        if (message.duration !== 0) {
            writer.uint32(16).int32(message.duration);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.duration = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
            duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationId !== "") {
            obj.conversationId = message.conversationId;
        }
        if (message.duration !== 0) {
            obj.duration = Math.round(message.duration);
        }
        return obj;
    },
    create(base) {
        return TempBanRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTempBanRequest();
        message.conversationId = object.conversationId ?? "";
        message.duration = object.duration ?? 0;
        return message;
    },
};
messageTypeRegistry.set(TempBanRequest.$type, TempBanRequest);
function createBaseBulkReadConversationsResponse() {
    return { conversationIds: [] };
}
export const BulkReadConversationsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.BulkReadConversationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.conversationIds) {
            StringValue.encode({ value: v }, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBulkReadConversationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationIds: globalThis.Array.isArray(object?.conversationIds)
                ? object.conversationIds.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationIds?.length) {
            obj.conversationIds = message.conversationIds;
        }
        return obj;
    },
    create(base) {
        return BulkReadConversationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBulkReadConversationsResponse();
        message.conversationIds = object.conversationIds?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(BulkReadConversationsResponse.$type, BulkReadConversationsResponse);
function createBaseGetConversationsResponse() {
    return { conversations: {}, messages: {}, viewerId: undefined, conversationIds: [] };
}
export const GetConversationsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.conversations).forEach(([key, value]) => {
            GetConversationsResponse_ConversationsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.messages).forEach(([key, value]) => {
            GetConversationsResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.viewerId !== undefined) {
            StringValue.encode({ value: message.viewerId }, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.conversationIds) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = GetConversationsResponse_ConversationsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.conversations[entry1.key] = entry1.value;
                    }
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = GetConversationsResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.viewerId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.conversationIds.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isObject(object.conversations)
                ? Object.entries(object.conversations).reduce((acc, [key, value]) => {
                    acc[key] = ConversationData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            viewerId: isSet(object.viewerId) ? String(object.viewerId) : undefined,
            conversationIds: globalThis.Array.isArray(object?.conversationIds)
                ? object.conversationIds.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations) {
            const entries = Object.entries(message.conversations);
            if (entries.length > 0) {
                obj.conversations = {};
                entries.forEach(([k, v]) => {
                    obj.conversations[k] = ConversationData.toJSON(v);
                });
            }
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.viewerId !== undefined) {
            obj.viewerId = message.viewerId;
        }
        if (message.conversationIds?.length) {
            obj.conversationIds = message.conversationIds;
        }
        return obj;
    },
    create(base) {
        return GetConversationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse();
        message.conversations = Object.entries(object.conversations ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ConversationData.fromPartial(value);
            }
            return acc;
        }, {});
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.viewerId = object.viewerId ?? undefined;
        message.conversationIds = object.conversationIds?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(GetConversationsResponse.$type, GetConversationsResponse);
function createBaseGetConversationsResponse_ConversationsEntry() {
    return { key: "", value: undefined };
}
export const GetConversationsResponse_ConversationsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.ConversationsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ConversationData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse_ConversationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ConversationData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ConversationData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ConversationData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetConversationsResponse_ConversationsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse_ConversationsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ConversationData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationsResponse_ConversationsEntry.$type, GetConversationsResponse_ConversationsEntry);
function createBaseGetConversationsResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const GetConversationsResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationsResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetConversationsResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationsResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationsResponse_MessagesEntry.$type, GetConversationsResponse_MessagesEntry);
function createBaseCreateConversationResponse() {
    return {
        conversation: undefined,
        messages: {},
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
        explanation: undefined,
        user: undefined,
    };
}
export const CreateConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            CreateConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            CreateConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(34).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(42).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(50).fork()).ldelim();
        }
        if (message.explanation !== undefined) {
            StringValue.encode({ value: message.explanation }, writer.uint32(58).fork()).ldelim();
        }
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = CreateConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = CreateConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.explanation = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
            explanation: isSet(object.explanation) ? String(object.explanation) : undefined,
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversation !== undefined) {
            obj.conversation = ConversationData.toJSON(message.conversation);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        if (message.explanation !== undefined) {
            obj.explanation = message.explanation;
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return CreateConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        message.explanation = object.explanation ?? undefined;
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationResponse.$type, CreateConversationResponse);
function createBaseCreateConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return CreateConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationResponse_MessagesEntry.$type, CreateConversationResponse_MessagesEntry);
function createBaseCreateConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return CreateConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationResponse_ModActionsEntry.$type, CreateConversationResponse_ModActionsEntry);
function createBaseGetConversationResponse() {
    return { conversation: undefined, messages: {}, modActions: {}, participantSubreddit: undefined, user: undefined };
}
export const GetConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            GetConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            GetConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.participantSubreddit !== undefined) {
            Any.encode(message.participantSubreddit, writer.uint32(34).fork()).ldelim();
        }
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = GetConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = GetConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.participantSubreddit = Any.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            participantSubreddit: isSet(object.participantSubreddit) ? Any.fromJSON(object.participantSubreddit) : undefined,
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversation !== undefined) {
            obj.conversation = ConversationData.toJSON(message.conversation);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.participantSubreddit !== undefined) {
            obj.participantSubreddit = Any.toJSON(message.participantSubreddit);
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return GetConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.participantSubreddit = (object.participantSubreddit !== undefined && object.participantSubreddit !== null)
            ? Any.fromPartial(object.participantSubreddit)
            : undefined;
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationResponse.$type, GetConversationResponse);
function createBaseGetConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const GetConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationResponse_MessagesEntry.$type, GetConversationResponse_MessagesEntry);
function createBaseGetConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const GetConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.GetConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GetConversationResponse_ModActionsEntry.$type, GetConversationResponse_ModActionsEntry);
function createBaseCreateConversationMessageResponse() {
    return { conversation: undefined, messages: {}, user: undefined };
}
export const CreateConversationMessageResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            CreateConversationMessageResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork())
                .ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = CreateConversationMessageResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversation !== undefined) {
            obj.conversation = ConversationData.toJSON(message.conversation);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        return obj;
    },
    create(base) {
        return CreateConversationMessageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageResponse();
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationMessageResponse.$type, CreateConversationMessageResponse);
function createBaseCreateConversationMessageResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const CreateConversationMessageResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.CreateConversationMessageResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateConversationMessageResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return CreateConversationMessageResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateConversationMessageResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(CreateConversationMessageResponse_MessagesEntry.$type, CreateConversationMessageResponse_MessagesEntry);
function createBaseApproveConversationResponse() {
    return {
        conversations: undefined,
        messages: {},
        user: undefined,
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
        explanation: undefined,
    };
}
export const ApproveConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            ApproveConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            ApproveConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
        }
        if (message.explanation !== undefined) {
            StringValue.encode({ value: message.explanation }, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = ApproveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = ApproveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.explanation = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
            explanation: isSet(object.explanation) ? String(object.explanation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations !== undefined) {
            obj.conversations = ConversationData.toJSON(message.conversations);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        if (message.explanation !== undefined) {
            obj.explanation = message.explanation;
        }
        return obj;
    },
    create(base) {
        return ApproveConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        message.explanation = object.explanation ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ApproveConversationResponse.$type, ApproveConversationResponse);
function createBaseApproveConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const ApproveConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ApproveConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ApproveConversationResponse_MessagesEntry.$type, ApproveConversationResponse_MessagesEntry);
function createBaseApproveConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ApproveConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ApproveConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApproveConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ApproveConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApproveConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ApproveConversationResponse_ModActionsEntry.$type, ApproveConversationResponse_ModActionsEntry);
function createBaseArchiveConversationResponse() {
    return { conversations: undefined, messages: {}, modActions: {}, conversation: undefined };
}
export const ArchiveConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            ArchiveConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            ArchiveConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = ArchiveConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = ArchiveConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations !== undefined) {
            obj.conversations = ConversationData.toJSON(message.conversations);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.conversation !== undefined) {
            obj.conversation = ConversationData.toJSON(message.conversation);
        }
        return obj;
    },
    create(base) {
        return ArchiveConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ArchiveConversationResponse.$type, ArchiveConversationResponse);
function createBaseArchiveConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const ArchiveConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ArchiveConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ArchiveConversationResponse_MessagesEntry.$type, ArchiveConversationResponse_MessagesEntry);
function createBaseArchiveConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const ArchiveConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.ArchiveConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return ArchiveConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseArchiveConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ArchiveConversationResponse_ModActionsEntry.$type, ArchiveConversationResponse_ModActionsEntry);
function createBaseHighlightConversationResponse() {
    return { conversations: undefined, messages: {}, modActions: {}, conversation: undefined };
}
export const HighlightConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            HighlightConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.modActions).forEach(([key, value]) => {
            HighlightConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(26).fork())
                .ldelim();
        });
        if (message.conversation !== undefined) {
            ConversationData.encode(message.conversation, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = HighlightConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = HighlightConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.modActions[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.conversation = ConversationData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            conversation: isSet(object.conversation) ? ConversationData.fromJSON(object.conversation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations !== undefined) {
            obj.conversations = ConversationData.toJSON(message.conversations);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.conversation !== undefined) {
            obj.conversation = ConversationData.toJSON(message.conversation);
        }
        return obj;
    },
    create(base) {
        return HighlightConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.conversation = (object.conversation !== undefined && object.conversation !== null)
            ? ConversationData.fromPartial(object.conversation)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(HighlightConversationResponse.$type, HighlightConversationResponse);
function createBaseHighlightConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const HighlightConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return HighlightConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(HighlightConversationResponse_MessagesEntry.$type, HighlightConversationResponse_MessagesEntry);
function createBaseHighlightConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const HighlightConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.HighlightConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHighlightConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return HighlightConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHighlightConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(HighlightConversationResponse_ModActionsEntry.$type, HighlightConversationResponse_ModActionsEntry);
function createBaseMuteConversationResponse() {
    return { conversations: undefined, messages: {}, user: undefined, modActions: {} };
}
export const MuteConversationResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            MuteConversationResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            MuteConversationResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = MuteConversationResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = MuteConversationResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations !== undefined) {
            obj.conversations = ConversationData.toJSON(message.conversations);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return MuteConversationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(MuteConversationResponse.$type, MuteConversationResponse);
function createBaseMuteConversationResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const MuteConversationResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return MuteConversationResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(MuteConversationResponse_MessagesEntry.$type, MuteConversationResponse_MessagesEntry);
function createBaseMuteConversationResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const MuteConversationResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.MuteConversationResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteConversationResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return MuteConversationResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMuteConversationResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(MuteConversationResponse_ModActionsEntry.$type, MuteConversationResponse_ModActionsEntry);
function createBaseTempBanResponse() {
    return {
        conversations: undefined,
        messages: {},
        user: undefined,
        modActions: {},
        fields: [],
        reason: undefined,
        message: undefined,
    };
}
export const TempBanResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.conversations !== undefined) {
            ConversationData.encode(message.conversations, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.messages).forEach(([key, value]) => {
            TempBanResponse_MessagesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.user !== undefined) {
            ConversationUserData.encode(message.user, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.modActions).forEach(([key, value]) => {
            TempBanResponse_ModActionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        for (const v of message.fields) {
            StringValue.encode({ value: v }, writer.uint32(42).fork()).ldelim();
        }
        if (message.reason !== undefined) {
            StringValue.encode({ value: message.reason }, writer.uint32(50).fork()).ldelim();
        }
        if (message.message !== undefined) {
            StringValue.encode({ value: message.message }, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations = ConversationData.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = TempBanResponse_MessagesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.messages[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.user = ConversationUserData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = TempBanResponse_ModActionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.modActions[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fields.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.reason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.message = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: isSet(object.conversations) ? ConversationData.fromJSON(object.conversations) : undefined,
            messages: isObject(object.messages)
                ? Object.entries(object.messages).reduce((acc, [key, value]) => {
                    acc[key] = MessageData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            user: isSet(object.user) ? ConversationUserData.fromJSON(object.user) : undefined,
            modActions: isObject(object.modActions)
                ? Object.entries(object.modActions).reduce((acc, [key, value]) => {
                    acc[key] = ModActionData.fromJSON(value);
                    return acc;
                }, {})
                : {},
            fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e) => String(e)) : [],
            reason: isSet(object.reason) ? String(object.reason) : undefined,
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations !== undefined) {
            obj.conversations = ConversationData.toJSON(message.conversations);
        }
        if (message.messages) {
            const entries = Object.entries(message.messages);
            if (entries.length > 0) {
                obj.messages = {};
                entries.forEach(([k, v]) => {
                    obj.messages[k] = MessageData.toJSON(v);
                });
            }
        }
        if (message.user !== undefined) {
            obj.user = ConversationUserData.toJSON(message.user);
        }
        if (message.modActions) {
            const entries = Object.entries(message.modActions);
            if (entries.length > 0) {
                obj.modActions = {};
                entries.forEach(([k, v]) => {
                    obj.modActions[k] = ModActionData.toJSON(v);
                });
            }
        }
        if (message.fields?.length) {
            obj.fields = message.fields;
        }
        if (message.reason !== undefined) {
            obj.reason = message.reason;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return TempBanResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse();
        message.conversations = (object.conversations !== undefined && object.conversations !== null)
            ? ConversationData.fromPartial(object.conversations)
            : undefined;
        message.messages = Object.entries(object.messages ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = MessageData.fromPartial(value);
            }
            return acc;
        }, {});
        message.user = (object.user !== undefined && object.user !== null)
            ? ConversationUserData.fromPartial(object.user)
            : undefined;
        message.modActions = Object.entries(object.modActions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = ModActionData.fromPartial(value);
            }
            return acc;
        }, {});
        message.fields = object.fields?.map((e) => e) || [];
        message.reason = object.reason ?? undefined;
        message.message = object.message ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(TempBanResponse.$type, TempBanResponse);
function createBaseTempBanResponse_MessagesEntry() {
    return { key: "", value: undefined };
}
export const TempBanResponse_MessagesEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.MessagesEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            MessageData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse_MessagesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = MessageData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? MessageData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = MessageData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return TempBanResponse_MessagesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse_MessagesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? MessageData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(TempBanResponse_MessagesEntry.$type, TempBanResponse_MessagesEntry);
function createBaseTempBanResponse_ModActionsEntry() {
    return { key: "", value: undefined };
}
export const TempBanResponse_ModActionsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.TempBanResponse.ModActionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            ModActionData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTempBanResponse_ModActionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = ModActionData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? ModActionData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = ModActionData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return TempBanResponse_ModActionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTempBanResponse_ModActionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? ModActionData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(TempBanResponse_ModActionsEntry.$type, TempBanResponse_ModActionsEntry);
function createBaseSubredditsResponse() {
    return { subreddits: {} };
}
export const SubredditsResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.subreddits).forEach(([key, value]) => {
            SubredditsResponse_SubredditsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SubredditsResponse_SubredditsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.subreddits[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subreddits: isObject(object.subreddits)
                ? Object.entries(object.subreddits).reduce((acc, [key, value]) => {
                    acc[key] = SubredditsResponse_SubredditData.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subreddits) {
            const entries = Object.entries(message.subreddits);
            if (entries.length > 0) {
                obj.subreddits = {};
                entries.forEach(([k, v]) => {
                    obj.subreddits[k] = SubredditsResponse_SubredditData.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return SubredditsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse();
        message.subreddits = Object.entries(object.subreddits ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SubredditsResponse_SubredditData.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(SubredditsResponse.$type, SubredditsResponse);
function createBaseSubredditsResponse_SubredditData() {
    return {
        communityIcon: undefined,
        keyColor: undefined,
        displayName: undefined,
        name: undefined,
        subscribers: undefined,
        primaryColor: undefined,
        id: undefined,
        lastUpdated: undefined,
        icon: undefined,
    };
}
export const SubredditsResponse_SubredditData = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditData",
    encode(message, writer = _m0.Writer.create()) {
        if (message.communityIcon !== undefined) {
            StringValue.encode({ value: message.communityIcon }, writer.uint32(10).fork()).ldelim();
        }
        if (message.keyColor !== undefined) {
            StringValue.encode({ value: message.keyColor }, writer.uint32(18).fork()).ldelim();
        }
        if (message.displayName !== undefined) {
            StringValue.encode({ value: message.displayName }, writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(34).fork()).ldelim();
        }
        if (message.subscribers !== undefined) {
            Int32Value.encode({ value: message.subscribers }, writer.uint32(42).fork()).ldelim();
        }
        if (message.primaryColor !== undefined) {
            StringValue.encode({ value: message.primaryColor }, writer.uint32(50).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(58).fork()).ldelim();
        }
        if (message.lastUpdated !== undefined) {
            StringValue.encode({ value: message.lastUpdated }, writer.uint32(66).fork()).ldelim();
        }
        if (message.icon !== undefined) {
            StringValue.encode({ value: message.icon }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse_SubredditData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.communityIcon = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keyColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.displayName = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.subscribers = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.primaryColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.lastUpdated = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.icon = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityIcon: isSet(object.communityIcon) ? String(object.communityIcon) : undefined,
            keyColor: isSet(object.keyColor) ? String(object.keyColor) : undefined,
            displayName: isSet(object.displayName) ? String(object.displayName) : undefined,
            name: isSet(object.name) ? String(object.name) : undefined,
            subscribers: isSet(object.subscribers) ? Number(object.subscribers) : undefined,
            primaryColor: isSet(object.primaryColor) ? String(object.primaryColor) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            lastUpdated: isSet(object.lastUpdated) ? String(object.lastUpdated) : undefined,
            icon: isSet(object.icon) ? String(object.icon) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.communityIcon !== undefined) {
            obj.communityIcon = message.communityIcon;
        }
        if (message.keyColor !== undefined) {
            obj.keyColor = message.keyColor;
        }
        if (message.displayName !== undefined) {
            obj.displayName = message.displayName;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.subscribers !== undefined) {
            obj.subscribers = message.subscribers;
        }
        if (message.primaryColor !== undefined) {
            obj.primaryColor = message.primaryColor;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.lastUpdated !== undefined) {
            obj.lastUpdated = message.lastUpdated;
        }
        if (message.icon !== undefined) {
            obj.icon = message.icon;
        }
        return obj;
    },
    create(base) {
        return SubredditsResponse_SubredditData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse_SubredditData();
        message.communityIcon = object.communityIcon ?? undefined;
        message.keyColor = object.keyColor ?? undefined;
        message.displayName = object.displayName ?? undefined;
        message.name = object.name ?? undefined;
        message.subscribers = object.subscribers ?? undefined;
        message.primaryColor = object.primaryColor ?? undefined;
        message.id = object.id ?? undefined;
        message.lastUpdated = object.lastUpdated ?? undefined;
        message.icon = object.icon ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(SubredditsResponse_SubredditData.$type, SubredditsResponse_SubredditData);
function createBaseSubredditsResponse_SubredditsEntry() {
    return { key: "", value: undefined };
}
export const SubredditsResponse_SubredditsEntry = {
    $type: "devvit.plugin.redditapi.newmodmail.SubredditsResponse.SubredditsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SubredditsResponse_SubredditData.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubredditsResponse_SubredditsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SubredditsResponse_SubredditData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SubredditsResponse_SubredditData.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SubredditsResponse_SubredditData.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SubredditsResponse_SubredditsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubredditsResponse_SubredditsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SubredditsResponse_SubredditData.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(SubredditsResponse_SubredditsEntry.$type, SubredditsResponse_SubredditsEntry);
function createBaseUnreadCountResponse() {
    return {
        archived: undefined,
        appeals: undefined,
        highlighted: undefined,
        notifications: undefined,
        joinRequests: undefined,
        filtered: undefined,
        new: undefined,
        inprogress: undefined,
        mod: undefined,
    };
}
export const UnreadCountResponse = {
    $type: "devvit.plugin.redditapi.newmodmail.UnreadCountResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.archived !== undefined) {
            Int32Value.encode({ value: message.archived }, writer.uint32(10).fork()).ldelim();
        }
        if (message.appeals !== undefined) {
            Int32Value.encode({ value: message.appeals }, writer.uint32(18).fork()).ldelim();
        }
        if (message.highlighted !== undefined) {
            Int32Value.encode({ value: message.highlighted }, writer.uint32(26).fork()).ldelim();
        }
        if (message.notifications !== undefined) {
            Int32Value.encode({ value: message.notifications }, writer.uint32(34).fork()).ldelim();
        }
        if (message.joinRequests !== undefined) {
            Int32Value.encode({ value: message.joinRequests }, writer.uint32(42).fork()).ldelim();
        }
        if (message.filtered !== undefined) {
            Int32Value.encode({ value: message.filtered }, writer.uint32(50).fork()).ldelim();
        }
        if (message.new !== undefined) {
            Int32Value.encode({ value: message.new }, writer.uint32(58).fork()).ldelim();
        }
        if (message.inprogress !== undefined) {
            Int32Value.encode({ value: message.inprogress }, writer.uint32(66).fork()).ldelim();
        }
        if (message.mod !== undefined) {
            Int32Value.encode({ value: message.mod }, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnreadCountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.archived = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.appeals = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.highlighted = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.notifications = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.joinRequests = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.filtered = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.new = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.inprogress = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.mod = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            archived: isSet(object.archived) ? Number(object.archived) : undefined,
            appeals: isSet(object.appeals) ? Number(object.appeals) : undefined,
            highlighted: isSet(object.highlighted) ? Number(object.highlighted) : undefined,
            notifications: isSet(object.notifications) ? Number(object.notifications) : undefined,
            joinRequests: isSet(object.joinRequests) ? Number(object.joinRequests) : undefined,
            filtered: isSet(object.filtered) ? Number(object.filtered) : undefined,
            new: isSet(object.new) ? Number(object.new) : undefined,
            inprogress: isSet(object.inprogress) ? Number(object.inprogress) : undefined,
            mod: isSet(object.mod) ? Number(object.mod) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.archived !== undefined) {
            obj.archived = message.archived;
        }
        if (message.appeals !== undefined) {
            obj.appeals = message.appeals;
        }
        if (message.highlighted !== undefined) {
            obj.highlighted = message.highlighted;
        }
        if (message.notifications !== undefined) {
            obj.notifications = message.notifications;
        }
        if (message.joinRequests !== undefined) {
            obj.joinRequests = message.joinRequests;
        }
        if (message.filtered !== undefined) {
            obj.filtered = message.filtered;
        }
        if (message.new !== undefined) {
            obj.new = message.new;
        }
        if (message.inprogress !== undefined) {
            obj.inprogress = message.inprogress;
        }
        if (message.mod !== undefined) {
            obj.mod = message.mod;
        }
        return obj;
    },
    create(base) {
        return UnreadCountResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnreadCountResponse();
        message.archived = object.archived ?? undefined;
        message.appeals = object.appeals ?? undefined;
        message.highlighted = object.highlighted ?? undefined;
        message.notifications = object.notifications ?? undefined;
        message.joinRequests = object.joinRequests ?? undefined;
        message.filtered = object.filtered ?? undefined;
        message.new = object.new ?? undefined;
        message.inprogress = object.inprogress ?? undefined;
        message.mod = object.mod ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(UnreadCountResponse.$type, UnreadCountResponse);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
