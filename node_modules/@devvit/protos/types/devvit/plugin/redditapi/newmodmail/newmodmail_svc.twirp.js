import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { BulkReadConversationsRequest, BulkReadConversationsResponse, GetConversationsRequest, GetConversationsResponse, CreateConversationRequest, CreateConversationResponse, GetConversationRequest, GetConversationResponse, CreateConversationMessageRequest, CreateConversationMessageResponse, BasicConversationRequest, ApproveConversationResponse, ArchiveConversationResponse, HighlightConversationResponse, MuteConversationRequest, MuteConversationResponse, TempBanRequest, TempBanResponse, ConversationUserData, BasicConversationsRequest, SubredditsResponse, UnreadCountResponse, } from './newmodmail_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
export var NewModmailMethod;
(function (NewModmailMethod) {
    NewModmailMethod["BulkReadConversations"] = "BulkReadConversations";
    NewModmailMethod["GetConversations"] = "GetConversations";
    NewModmailMethod["CreateConversation"] = "CreateConversation";
    NewModmailMethod["GetConversation"] = "GetConversation";
    NewModmailMethod["CreateConversationMessage"] = "CreateConversationMessage";
    NewModmailMethod["ApproveConversation"] = "ApproveConversation";
    NewModmailMethod["ArchiveConversation"] = "ArchiveConversation";
    NewModmailMethod["DisapproveConversation"] = "DisapproveConversation";
    NewModmailMethod["UnhighlightConversation"] = "UnhighlightConversation";
    NewModmailMethod["HighlightConversation"] = "HighlightConversation";
    NewModmailMethod["MuteConversation"] = "MuteConversation";
    NewModmailMethod["TempBan"] = "TempBan";
    NewModmailMethod["UnarchiveConversation"] = "UnarchiveConversation";
    NewModmailMethod["Unban"] = "Unban";
    NewModmailMethod["UnmuteConversation"] = "UnmuteConversation";
    NewModmailMethod["UserConversations"] = "UserConversations";
    NewModmailMethod["Read"] = "Read";
    NewModmailMethod["Subreddits"] = "Subreddits";
    NewModmailMethod["Unread"] = "Unread";
    NewModmailMethod["UnreadCount"] = "UnreadCount";
})(NewModmailMethod || (NewModmailMethod = {}));
export const NewModmailMethodList = [
    NewModmailMethod.BulkReadConversations,
    NewModmailMethod.GetConversations,
    NewModmailMethod.CreateConversation,
    NewModmailMethod.GetConversation,
    NewModmailMethod.CreateConversationMessage,
    NewModmailMethod.ApproveConversation,
    NewModmailMethod.ArchiveConversation,
    NewModmailMethod.DisapproveConversation,
    NewModmailMethod.UnhighlightConversation,
    NewModmailMethod.HighlightConversation,
    NewModmailMethod.MuteConversation,
    NewModmailMethod.TempBan,
    NewModmailMethod.UnarchiveConversation,
    NewModmailMethod.Unban,
    NewModmailMethod.UnmuteConversation,
    NewModmailMethod.UserConversations,
    NewModmailMethod.Read,
    NewModmailMethod.Subreddits,
    NewModmailMethod.Unread,
    NewModmailMethod.UnreadCount,
];
export function createNewModmailServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.newmodmail',
        serviceName: 'NewModmail',
        methodList: NewModmailMethodList,
        matchRoute: matchNewModmailRoute,
    });
}
function matchNewModmailRoute(method, events) {
    switch (method) {
        case 'BulkReadConversations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'BulkReadConversations' };
                await events.onMatch(ctx);
                return handleNewModmailBulkReadConversationsRequest(ctx, service, data, interceptors);
            };
        case 'GetConversations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetConversations' };
                await events.onMatch(ctx);
                return handleNewModmailGetConversationsRequest(ctx, service, data, interceptors);
            };
        case 'CreateConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateConversation' };
                await events.onMatch(ctx);
                return handleNewModmailCreateConversationRequest(ctx, service, data, interceptors);
            };
        case 'GetConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetConversation' };
                await events.onMatch(ctx);
                return handleNewModmailGetConversationRequest(ctx, service, data, interceptors);
            };
        case 'CreateConversationMessage':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'CreateConversationMessage' };
                await events.onMatch(ctx);
                return handleNewModmailCreateConversationMessageRequest(ctx, service, data, interceptors);
            };
        case 'ApproveConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ApproveConversation' };
                await events.onMatch(ctx);
                return handleNewModmailApproveConversationRequest(ctx, service, data, interceptors);
            };
        case 'ArchiveConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ArchiveConversation' };
                await events.onMatch(ctx);
                return handleNewModmailArchiveConversationRequest(ctx, service, data, interceptors);
            };
        case 'DisapproveConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'DisapproveConversation' };
                await events.onMatch(ctx);
                return handleNewModmailDisapproveConversationRequest(ctx, service, data, interceptors);
            };
        case 'UnhighlightConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnhighlightConversation' };
                await events.onMatch(ctx);
                return handleNewModmailUnhighlightConversationRequest(ctx, service, data, interceptors);
            };
        case 'HighlightConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HighlightConversation' };
                await events.onMatch(ctx);
                return handleNewModmailHighlightConversationRequest(ctx, service, data, interceptors);
            };
        case 'MuteConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MuteConversation' };
                await events.onMatch(ctx);
                return handleNewModmailMuteConversationRequest(ctx, service, data, interceptors);
            };
        case 'TempBan':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'TempBan' };
                await events.onMatch(ctx);
                return handleNewModmailTempBanRequest(ctx, service, data, interceptors);
            };
        case 'UnarchiveConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnarchiveConversation' };
                await events.onMatch(ctx);
                return handleNewModmailUnarchiveConversationRequest(ctx, service, data, interceptors);
            };
        case 'Unban':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unban' };
                await events.onMatch(ctx);
                return handleNewModmailUnbanRequest(ctx, service, data, interceptors);
            };
        case 'UnmuteConversation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnmuteConversation' };
                await events.onMatch(ctx);
                return handleNewModmailUnmuteConversationRequest(ctx, service, data, interceptors);
            };
        case 'UserConversations':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserConversations' };
                await events.onMatch(ctx);
                return handleNewModmailUserConversationsRequest(ctx, service, data, interceptors);
            };
        case 'Read':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Read' };
                await events.onMatch(ctx);
                return handleNewModmailReadRequest(ctx, service, data, interceptors);
            };
        case 'Subreddits':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Subreddits' };
                await events.onMatch(ctx);
                return handleNewModmailSubredditsRequest(ctx, service, data, interceptors);
            };
        case 'Unread':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unread' };
                await events.onMatch(ctx);
                return handleNewModmailUnreadRequest(ctx, service, data, interceptors);
            };
        case 'UnreadCount':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnreadCount' };
                await events.onMatch(ctx);
                return handleNewModmailUnreadCountRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailBulkReadConversationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailBulkReadConversationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailBulkReadConversationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailGetConversationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailGetConversationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailGetConversationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailCreateConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailCreateConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailCreateConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailGetConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailGetConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailGetConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailCreateConversationMessageRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailCreateConversationMessageJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailCreateConversationMessageProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailApproveConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailApproveConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailApproveConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailArchiveConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailArchiveConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailArchiveConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailDisapproveConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailDisapproveConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailDisapproveConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnhighlightConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnhighlightConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnhighlightConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailHighlightConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailHighlightConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailHighlightConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailMuteConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailMuteConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailMuteConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailTempBanRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailTempBanJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailTempBanProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnarchiveConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnarchiveConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnarchiveConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnbanRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnbanJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnbanProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnmuteConversationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnmuteConversationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnmuteConversationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUserConversationsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUserConversationsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUserConversationsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailReadRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailReadJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailReadProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailSubredditsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailSubredditsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailSubredditsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnreadRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnreadJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnreadProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleNewModmailUnreadCountRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleNewModmailUnreadCountJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleNewModmailUnreadCountProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleNewModmailBulkReadConversationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BulkReadConversationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BulkReadConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.BulkReadConversations(ctx, request);
    }
    return JSON.stringify(BulkReadConversationsResponse.toJSON(response));
}
async function handleNewModmailGetConversationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetConversationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetConversations(ctx, request);
    }
    return JSON.stringify(GetConversationsResponse.toJSON(response));
}
async function handleNewModmailCreateConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateConversation(ctx, request);
    }
    return JSON.stringify(CreateConversationResponse.toJSON(response));
}
async function handleNewModmailGetConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetConversation(ctx, request);
    }
    return JSON.stringify(GetConversationResponse.toJSON(response));
}
async function handleNewModmailCreateConversationMessageJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = CreateConversationMessageRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateConversationMessage(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateConversationMessage(ctx, request);
    }
    return JSON.stringify(CreateConversationMessageResponse.toJSON(response));
}
async function handleNewModmailApproveConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ApproveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.ApproveConversation(ctx, request);
    }
    return JSON.stringify(ApproveConversationResponse.toJSON(response));
}
async function handleNewModmailArchiveConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ArchiveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.ArchiveConversation(ctx, request);
    }
    return JSON.stringify(ArchiveConversationResponse.toJSON(response));
}
async function handleNewModmailDisapproveConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DisapproveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.DisapproveConversation(ctx, request);
    }
    return JSON.stringify(ApproveConversationResponse.toJSON(response));
}
async function handleNewModmailUnhighlightConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnhighlightConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnhighlightConversation(ctx, request);
    }
    return JSON.stringify(HighlightConversationResponse.toJSON(response));
}
async function handleNewModmailHighlightConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HighlightConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.HighlightConversation(ctx, request);
    }
    return JSON.stringify(HighlightConversationResponse.toJSON(response));
}
async function handleNewModmailMuteConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = MuteConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MuteConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.MuteConversation(ctx, request);
    }
    return JSON.stringify(MuteConversationResponse.toJSON(response));
}
async function handleNewModmailTempBanJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TempBanRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.TempBan(ctx, inputReq);
        });
    }
    else {
        response = await service.TempBan(ctx, request);
    }
    return JSON.stringify(TempBanResponse.toJSON(response));
}
async function handleNewModmailUnarchiveConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnarchiveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnarchiveConversation(ctx, request);
    }
    return JSON.stringify(ArchiveConversationResponse.toJSON(response));
}
async function handleNewModmailUnbanJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unban(ctx, inputReq);
        });
    }
    else {
        response = await service.Unban(ctx, request);
    }
    return JSON.stringify(TempBanResponse.toJSON(response));
}
async function handleNewModmailUnmuteConversationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmuteConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmuteConversation(ctx, request);
    }
    return JSON.stringify(MuteConversationResponse.toJSON(response));
}
async function handleNewModmailUserConversationsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.UserConversations(ctx, request);
    }
    return JSON.stringify(ConversationUserData.toJSON(response));
}
async function handleNewModmailReadJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Read(ctx, inputReq);
        });
    }
    else {
        response = await service.Read(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleNewModmailSubredditsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Subreddits(ctx, inputReq);
        });
    }
    else {
        response = await service.Subreddits(ctx, request);
    }
    return JSON.stringify(SubredditsResponse.toJSON(response));
}
async function handleNewModmailUnreadJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BasicConversationsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unread(ctx, inputReq);
        });
    }
    else {
        response = await service.Unread(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleNewModmailUnreadCountJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnreadCount(ctx, inputReq);
        });
    }
    else {
        response = await service.UnreadCount(ctx, request);
    }
    return JSON.stringify(UnreadCountResponse.toJSON(response));
}
async function handleNewModmailBulkReadConversationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BulkReadConversationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BulkReadConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.BulkReadConversations(ctx, request);
    }
    return Buffer.from(BulkReadConversationsResponse.encode(response).finish());
}
async function handleNewModmailGetConversationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetConversationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.GetConversations(ctx, request);
    }
    return Buffer.from(GetConversationsResponse.encode(response).finish());
}
async function handleNewModmailCreateConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateConversation(ctx, request);
    }
    return Buffer.from(CreateConversationResponse.encode(response).finish());
}
async function handleNewModmailGetConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetConversation(ctx, request);
    }
    return Buffer.from(GetConversationResponse.encode(response).finish());
}
async function handleNewModmailCreateConversationMessageProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = CreateConversationMessageRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.CreateConversationMessage(ctx, inputReq);
        });
    }
    else {
        response = await service.CreateConversationMessage(ctx, request);
    }
    return Buffer.from(CreateConversationMessageResponse.encode(response).finish());
}
async function handleNewModmailApproveConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ApproveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.ApproveConversation(ctx, request);
    }
    return Buffer.from(ApproveConversationResponse.encode(response).finish());
}
async function handleNewModmailArchiveConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ArchiveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.ArchiveConversation(ctx, request);
    }
    return Buffer.from(ArchiveConversationResponse.encode(response).finish());
}
async function handleNewModmailDisapproveConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.DisapproveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.DisapproveConversation(ctx, request);
    }
    return Buffer.from(ApproveConversationResponse.encode(response).finish());
}
async function handleNewModmailUnhighlightConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnhighlightConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnhighlightConversation(ctx, request);
    }
    return Buffer.from(HighlightConversationResponse.encode(response).finish());
}
async function handleNewModmailHighlightConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HighlightConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.HighlightConversation(ctx, request);
    }
    return Buffer.from(HighlightConversationResponse.encode(response).finish());
}
async function handleNewModmailMuteConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = MuteConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MuteConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.MuteConversation(ctx, request);
    }
    return Buffer.from(MuteConversationResponse.encode(response).finish());
}
async function handleNewModmailTempBanProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TempBanRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.TempBan(ctx, inputReq);
        });
    }
    else {
        response = await service.TempBan(ctx, request);
    }
    return Buffer.from(TempBanResponse.encode(response).finish());
}
async function handleNewModmailUnarchiveConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnarchiveConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnarchiveConversation(ctx, request);
    }
    return Buffer.from(ArchiveConversationResponse.encode(response).finish());
}
async function handleNewModmailUnbanProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unban(ctx, inputReq);
        });
    }
    else {
        response = await service.Unban(ctx, request);
    }
    return Buffer.from(TempBanResponse.encode(response).finish());
}
async function handleNewModmailUnmuteConversationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnmuteConversation(ctx, inputReq);
        });
    }
    else {
        response = await service.UnmuteConversation(ctx, request);
    }
    return Buffer.from(MuteConversationResponse.encode(response).finish());
}
async function handleNewModmailUserConversationsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserConversations(ctx, inputReq);
        });
    }
    else {
        response = await service.UserConversations(ctx, request);
    }
    return Buffer.from(ConversationUserData.encode(response).finish());
}
async function handleNewModmailReadProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Read(ctx, inputReq);
        });
    }
    else {
        response = await service.Read(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleNewModmailSubredditsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Subreddits(ctx, inputReq);
        });
    }
    else {
        response = await service.Subreddits(ctx, request);
    }
    return Buffer.from(SubredditsResponse.encode(response).finish());
}
async function handleNewModmailUnreadProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BasicConversationsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unread(ctx, inputReq);
        });
    }
    else {
        response = await service.Unread(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleNewModmailUnreadCountProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnreadCount(ctx, inputReq);
        });
    }
    else {
        response = await service.UnreadCount(ctx, request);
    }
    return Buffer.from(UnreadCountResponse.encode(response).finish());
}
