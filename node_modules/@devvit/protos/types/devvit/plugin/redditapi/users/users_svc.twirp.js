import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { BlockUserRequest, BlockUserResponse, FriendRequest, ReportUserRequest, SetPermissionsRequest, UnfriendRequest, UserDataByAccountIdsRequest, UserDataByAccountIdsResponse, UsernameAvailableRequest, GenericUsersRequest, GeneralFriendResponse, UpdateFriendRelationshipRequest, UserTrophiesResponse, UserAboutRequest, UserAboutResponse, UserWhereRequest, } from './users_msg.js';
import { JsonStatus, Listing } from '../common/common_msg.js';
import { Empty } from '../../../../google/protobuf/empty.js';
import { BoolValue } from '../../../../google/protobuf/wrappers.js';
export var UsersMethod;
(function (UsersMethod) {
    UsersMethod["BlockUser"] = "BlockUser";
    UsersMethod["Friend"] = "Friend";
    UsersMethod["ReportUser"] = "ReportUser";
    UsersMethod["SetPermissions"] = "SetPermissions";
    UsersMethod["Unfriend"] = "Unfriend";
    UsersMethod["UserDataByAccountIds"] = "UserDataByAccountIds";
    UsersMethod["UsernameAvailable"] = "UsernameAvailable";
    UsersMethod["UnfriendUser"] = "UnfriendUser";
    UsersMethod["GetFriendInformation"] = "GetFriendInformation";
    UsersMethod["UpdateFriendRelationship"] = "UpdateFriendRelationship";
    UsersMethod["UserTrophies"] = "UserTrophies";
    UsersMethod["UserAbout"] = "UserAbout";
    UsersMethod["UserWhere"] = "UserWhere";
})(UsersMethod || (UsersMethod = {}));
export const UsersMethodList = [
    UsersMethod.BlockUser,
    UsersMethod.Friend,
    UsersMethod.ReportUser,
    UsersMethod.SetPermissions,
    UsersMethod.Unfriend,
    UsersMethod.UserDataByAccountIds,
    UsersMethod.UsernameAvailable,
    UsersMethod.UnfriendUser,
    UsersMethod.GetFriendInformation,
    UsersMethod.UpdateFriendRelationship,
    UsersMethod.UserTrophies,
    UsersMethod.UserAbout,
    UsersMethod.UserWhere,
];
export function createUsersServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redditapi.users',
        serviceName: 'Users',
        methodList: UsersMethodList,
        matchRoute: matchUsersRoute,
    });
}
function matchUsersRoute(method, events) {
    switch (method) {
        case 'BlockUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'BlockUser' };
                await events.onMatch(ctx);
                return handleUsersBlockUserRequest(ctx, service, data, interceptors);
            };
        case 'Friend':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Friend' };
                await events.onMatch(ctx);
                return handleUsersFriendRequest(ctx, service, data, interceptors);
            };
        case 'ReportUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ReportUser' };
                await events.onMatch(ctx);
                return handleUsersReportUserRequest(ctx, service, data, interceptors);
            };
        case 'SetPermissions':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetPermissions' };
                await events.onMatch(ctx);
                return handleUsersSetPermissionsRequest(ctx, service, data, interceptors);
            };
        case 'Unfriend':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unfriend' };
                await events.onMatch(ctx);
                return handleUsersUnfriendRequest(ctx, service, data, interceptors);
            };
        case 'UserDataByAccountIds':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserDataByAccountIds' };
                await events.onMatch(ctx);
                return handleUsersUserDataByAccountIdsRequest(ctx, service, data, interceptors);
            };
        case 'UsernameAvailable':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UsernameAvailable' };
                await events.onMatch(ctx);
                return handleUsersUsernameAvailableRequest(ctx, service, data, interceptors);
            };
        case 'UnfriendUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UnfriendUser' };
                await events.onMatch(ctx);
                return handleUsersUnfriendUserRequest(ctx, service, data, interceptors);
            };
        case 'GetFriendInformation':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetFriendInformation' };
                await events.onMatch(ctx);
                return handleUsersGetFriendInformationRequest(ctx, service, data, interceptors);
            };
        case 'UpdateFriendRelationship':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateFriendRelationship' };
                await events.onMatch(ctx);
                return handleUsersUpdateFriendRelationshipRequest(ctx, service, data, interceptors);
            };
        case 'UserTrophies':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserTrophies' };
                await events.onMatch(ctx);
                return handleUsersUserTrophiesRequest(ctx, service, data, interceptors);
            };
        case 'UserAbout':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserAbout' };
                await events.onMatch(ctx);
                return handleUsersUserAboutRequest(ctx, service, data, interceptors);
            };
        case 'UserWhere':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UserWhere' };
                await events.onMatch(ctx);
                return handleUsersUserWhereRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersBlockUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersBlockUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersBlockUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersFriendRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersFriendJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersFriendProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersReportUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersReportUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersReportUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersSetPermissionsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersSetPermissionsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersSetPermissionsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUnfriendRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUnfriendJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUnfriendProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUserDataByAccountIdsRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUserDataByAccountIdsJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUserDataByAccountIdsProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUsernameAvailableRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUsernameAvailableJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUsernameAvailableProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUnfriendUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUnfriendUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUnfriendUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersGetFriendInformationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersGetFriendInformationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersGetFriendInformationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUpdateFriendRelationshipRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUpdateFriendRelationshipJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUpdateFriendRelationshipProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUserTrophiesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUserTrophiesJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUserTrophiesProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUserAboutRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUserAboutJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUserAboutProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleUsersUserWhereRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleUsersUserWhereJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleUsersUserWhereProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleUsersBlockUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BlockUserRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BlockUser(ctx, inputReq);
        });
    }
    else {
        response = await service.BlockUser(ctx, request);
    }
    return JSON.stringify(BlockUserResponse.toJSON(response));
}
async function handleUsersFriendJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = FriendRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Friend(ctx, inputReq);
        });
    }
    else {
        response = await service.Friend(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleUsersReportUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ReportUserRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ReportUser(ctx, inputReq);
        });
    }
    else {
        response = await service.ReportUser(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleUsersSetPermissionsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetPermissionsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetPermissions(ctx, inputReq);
        });
    }
    else {
        response = await service.SetPermissions(ctx, request);
    }
    return JSON.stringify(JsonStatus.toJSON(response));
}
async function handleUsersUnfriendJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UnfriendRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unfriend(ctx, inputReq);
        });
    }
    else {
        response = await service.Unfriend(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleUsersUserDataByAccountIdsJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UserDataByAccountIdsRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserDataByAccountIds(ctx, inputReq);
        });
    }
    else {
        response = await service.UserDataByAccountIds(ctx, request);
    }
    return JSON.stringify(UserDataByAccountIdsResponse.toJSON(response));
}
async function handleUsersUsernameAvailableJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UsernameAvailableRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UsernameAvailable(ctx, inputReq);
        });
    }
    else {
        response = await service.UsernameAvailable(ctx, request);
    }
    return JSON.stringify(BoolValue.toJSON(response));
}
async function handleUsersUnfriendUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GenericUsersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnfriendUser(ctx, inputReq);
        });
    }
    else {
        response = await service.UnfriendUser(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleUsersGetFriendInformationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GenericUsersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetFriendInformation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetFriendInformation(ctx, request);
    }
    return JSON.stringify(GeneralFriendResponse.toJSON(response));
}
async function handleUsersUpdateFriendRelationshipJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateFriendRelationshipRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateFriendRelationship(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateFriendRelationship(ctx, request);
    }
    return JSON.stringify(GeneralFriendResponse.toJSON(response));
}
async function handleUsersUserTrophiesJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GenericUsersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserTrophies(ctx, inputReq);
        });
    }
    else {
        response = await service.UserTrophies(ctx, request);
    }
    return JSON.stringify(UserTrophiesResponse.toJSON(response));
}
async function handleUsersUserAboutJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UserAboutRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserAbout(ctx, inputReq);
        });
    }
    else {
        response = await service.UserAbout(ctx, request);
    }
    return JSON.stringify(UserAboutResponse.toJSON(response));
}
async function handleUsersUserWhereJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UserWhereRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserWhere(ctx, inputReq);
        });
    }
    else {
        response = await service.UserWhere(ctx, request);
    }
    return JSON.stringify(Listing.toJSON(response));
}
async function handleUsersBlockUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BlockUserRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BlockUser(ctx, inputReq);
        });
    }
    else {
        response = await service.BlockUser(ctx, request);
    }
    return Buffer.from(BlockUserResponse.encode(response).finish());
}
async function handleUsersFriendProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = FriendRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Friend(ctx, inputReq);
        });
    }
    else {
        response = await service.Friend(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleUsersReportUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ReportUserRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ReportUser(ctx, inputReq);
        });
    }
    else {
        response = await service.ReportUser(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleUsersSetPermissionsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetPermissionsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetPermissions(ctx, inputReq);
        });
    }
    else {
        response = await service.SetPermissions(ctx, request);
    }
    return Buffer.from(JsonStatus.encode(response).finish());
}
async function handleUsersUnfriendProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UnfriendRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unfriend(ctx, inputReq);
        });
    }
    else {
        response = await service.Unfriend(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleUsersUserDataByAccountIdsProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UserDataByAccountIdsRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserDataByAccountIds(ctx, inputReq);
        });
    }
    else {
        response = await service.UserDataByAccountIds(ctx, request);
    }
    return Buffer.from(UserDataByAccountIdsResponse.encode(response).finish());
}
async function handleUsersUsernameAvailableProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UsernameAvailableRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UsernameAvailable(ctx, inputReq);
        });
    }
    else {
        response = await service.UsernameAvailable(ctx, request);
    }
    return Buffer.from(BoolValue.encode(response).finish());
}
async function handleUsersUnfriendUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GenericUsersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UnfriendUser(ctx, inputReq);
        });
    }
    else {
        response = await service.UnfriendUser(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleUsersGetFriendInformationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GenericUsersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetFriendInformation(ctx, inputReq);
        });
    }
    else {
        response = await service.GetFriendInformation(ctx, request);
    }
    return Buffer.from(GeneralFriendResponse.encode(response).finish());
}
async function handleUsersUpdateFriendRelationshipProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateFriendRelationshipRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateFriendRelationship(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateFriendRelationship(ctx, request);
    }
    return Buffer.from(GeneralFriendResponse.encode(response).finish());
}
async function handleUsersUserTrophiesProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GenericUsersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserTrophies(ctx, inputReq);
        });
    }
    else {
        response = await service.UserTrophies(ctx, request);
    }
    return Buffer.from(UserTrophiesResponse.encode(response).finish());
}
async function handleUsersUserAboutProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UserAboutRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserAbout(ctx, inputReq);
        });
    }
    else {
        response = await service.UserAbout(ctx, request);
    }
    return Buffer.from(UserAboutResponse.encode(response).finish());
}
async function handleUsersUserWhereProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UserWhereRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UserWhere(ctx, inputReq);
        });
    }
    else {
        response = await service.UserWhere(ctx, request);
    }
    return Buffer.from(Listing.encode(response).finish());
}
