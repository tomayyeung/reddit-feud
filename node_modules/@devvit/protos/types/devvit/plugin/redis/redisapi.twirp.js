import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { KeyRequest, SetRequest, KeysRequest, IncrByRequest, HSetRequest, HGetRequest, RedisFieldValues, HDelRequest, HScanRequest, HScanResponse, KeysResponse, HIncrByRequest, TransactionId, TransactionResponses, WatchRequest, KeyRangeRequest, SetRangeRequest, RedisValues, KeyValuesRequest, ExpireRequest, ZAddRequest, ZRangeRequest, ZMembers, ZRemRequest, ZRemRangeByLexRequest, ZRemRangeByRankRequest, ZRemRangeByScoreRequest, ZScoreRequest, ZRankRequest, ZIncrByRequest, ZScanRequest, ZScanResponse, } from './redisapi.js';
import { StringValue, Int64Value, DoubleValue, } from '../../../google/protobuf/wrappers.js';
import { Empty } from '../../../google/protobuf/empty.js';
export var RedisAPIMethod;
(function (RedisAPIMethod) {
    RedisAPIMethod["Get"] = "Get";
    RedisAPIMethod["Set"] = "Set";
    RedisAPIMethod["Del"] = "Del";
    RedisAPIMethod["Type"] = "Type";
    RedisAPIMethod["IncrBy"] = "IncrBy";
    RedisAPIMethod["HSet"] = "HSet";
    RedisAPIMethod["HGet"] = "HGet";
    RedisAPIMethod["HGetAll"] = "HGetAll";
    RedisAPIMethod["HDel"] = "HDel";
    RedisAPIMethod["HScan"] = "HScan";
    RedisAPIMethod["HKeys"] = "HKeys";
    RedisAPIMethod["HIncrBy"] = "HIncrBy";
    RedisAPIMethod["HLen"] = "HLen";
    RedisAPIMethod["Multi"] = "Multi";
    RedisAPIMethod["Exec"] = "Exec";
    RedisAPIMethod["Discard"] = "Discard";
    RedisAPIMethod["Watch"] = "Watch";
    RedisAPIMethod["Unwatch"] = "Unwatch";
    RedisAPIMethod["GetRange"] = "GetRange";
    RedisAPIMethod["SetRange"] = "SetRange";
    RedisAPIMethod["Strlen"] = "Strlen";
    RedisAPIMethod["MGet"] = "MGet";
    RedisAPIMethod["MSet"] = "MSet";
    RedisAPIMethod["Expire"] = "Expire";
    RedisAPIMethod["ExpireTime"] = "ExpireTime";
    RedisAPIMethod["ZAdd"] = "ZAdd";
    RedisAPIMethod["ZCard"] = "ZCard";
    RedisAPIMethod["ZRange"] = "ZRange";
    RedisAPIMethod["ZRem"] = "ZRem";
    RedisAPIMethod["ZRemRangeByLex"] = "ZRemRangeByLex";
    RedisAPIMethod["ZRemRangeByRank"] = "ZRemRangeByRank";
    RedisAPIMethod["ZRemRangeByScore"] = "ZRemRangeByScore";
    RedisAPIMethod["ZScore"] = "ZScore";
    RedisAPIMethod["ZRank"] = "ZRank";
    RedisAPIMethod["ZIncrBy"] = "ZIncrBy";
    RedisAPIMethod["ZScan"] = "ZScan";
})(RedisAPIMethod || (RedisAPIMethod = {}));
export const RedisAPIMethodList = [
    RedisAPIMethod.Get,
    RedisAPIMethod.Set,
    RedisAPIMethod.Del,
    RedisAPIMethod.Type,
    RedisAPIMethod.IncrBy,
    RedisAPIMethod.HSet,
    RedisAPIMethod.HGet,
    RedisAPIMethod.HGetAll,
    RedisAPIMethod.HDel,
    RedisAPIMethod.HScan,
    RedisAPIMethod.HKeys,
    RedisAPIMethod.HIncrBy,
    RedisAPIMethod.HLen,
    RedisAPIMethod.Multi,
    RedisAPIMethod.Exec,
    RedisAPIMethod.Discard,
    RedisAPIMethod.Watch,
    RedisAPIMethod.Unwatch,
    RedisAPIMethod.GetRange,
    RedisAPIMethod.SetRange,
    RedisAPIMethod.Strlen,
    RedisAPIMethod.MGet,
    RedisAPIMethod.MSet,
    RedisAPIMethod.Expire,
    RedisAPIMethod.ExpireTime,
    RedisAPIMethod.ZAdd,
    RedisAPIMethod.ZCard,
    RedisAPIMethod.ZRange,
    RedisAPIMethod.ZRem,
    RedisAPIMethod.ZRemRangeByLex,
    RedisAPIMethod.ZRemRangeByRank,
    RedisAPIMethod.ZRemRangeByScore,
    RedisAPIMethod.ZScore,
    RedisAPIMethod.ZRank,
    RedisAPIMethod.ZIncrBy,
    RedisAPIMethod.ZScan,
];
export function createRedisAPIServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.redis',
        serviceName: 'RedisAPI',
        methodList: RedisAPIMethodList,
        matchRoute: matchRedisAPIRoute,
    });
}
function matchRedisAPIRoute(method, events) {
    switch (method) {
        case 'Get':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Get' };
                await events.onMatch(ctx);
                return handleRedisAPIGetRequest(ctx, service, data, interceptors);
            };
        case 'Set':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Set' };
                await events.onMatch(ctx);
                return handleRedisAPISetRequest(ctx, service, data, interceptors);
            };
        case 'Del':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Del' };
                await events.onMatch(ctx);
                return handleRedisAPIDelRequest(ctx, service, data, interceptors);
            };
        case 'Type':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Type' };
                await events.onMatch(ctx);
                return handleRedisAPITypeRequest(ctx, service, data, interceptors);
            };
        case 'IncrBy':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'IncrBy' };
                await events.onMatch(ctx);
                return handleRedisAPIIncrByRequest(ctx, service, data, interceptors);
            };
        case 'HSet':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HSet' };
                await events.onMatch(ctx);
                return handleRedisAPIHSetRequest(ctx, service, data, interceptors);
            };
        case 'HGet':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HGet' };
                await events.onMatch(ctx);
                return handleRedisAPIHGetRequest(ctx, service, data, interceptors);
            };
        case 'HGetAll':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HGetAll' };
                await events.onMatch(ctx);
                return handleRedisAPIHGetAllRequest(ctx, service, data, interceptors);
            };
        case 'HDel':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HDel' };
                await events.onMatch(ctx);
                return handleRedisAPIHDelRequest(ctx, service, data, interceptors);
            };
        case 'HScan':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HScan' };
                await events.onMatch(ctx);
                return handleRedisAPIHScanRequest(ctx, service, data, interceptors);
            };
        case 'HKeys':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HKeys' };
                await events.onMatch(ctx);
                return handleRedisAPIHKeysRequest(ctx, service, data, interceptors);
            };
        case 'HIncrBy':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HIncrBy' };
                await events.onMatch(ctx);
                return handleRedisAPIHIncrByRequest(ctx, service, data, interceptors);
            };
        case 'HLen':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'HLen' };
                await events.onMatch(ctx);
                return handleRedisAPIHLenRequest(ctx, service, data, interceptors);
            };
        case 'Multi':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Multi' };
                await events.onMatch(ctx);
                return handleRedisAPIMultiRequest(ctx, service, data, interceptors);
            };
        case 'Exec':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Exec' };
                await events.onMatch(ctx);
                return handleRedisAPIExecRequest(ctx, service, data, interceptors);
            };
        case 'Discard':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Discard' };
                await events.onMatch(ctx);
                return handleRedisAPIDiscardRequest(ctx, service, data, interceptors);
            };
        case 'Watch':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Watch' };
                await events.onMatch(ctx);
                return handleRedisAPIWatchRequest(ctx, service, data, interceptors);
            };
        case 'Unwatch':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Unwatch' };
                await events.onMatch(ctx);
                return handleRedisAPIUnwatchRequest(ctx, service, data, interceptors);
            };
        case 'GetRange':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetRange' };
                await events.onMatch(ctx);
                return handleRedisAPIGetRangeRequest(ctx, service, data, interceptors);
            };
        case 'SetRange':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'SetRange' };
                await events.onMatch(ctx);
                return handleRedisAPISetRangeRequest(ctx, service, data, interceptors);
            };
        case 'Strlen':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Strlen' };
                await events.onMatch(ctx);
                return handleRedisAPIStrlenRequest(ctx, service, data, interceptors);
            };
        case 'MGet':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MGet' };
                await events.onMatch(ctx);
                return handleRedisAPIMGetRequest(ctx, service, data, interceptors);
            };
        case 'MSet':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'MSet' };
                await events.onMatch(ctx);
                return handleRedisAPIMSetRequest(ctx, service, data, interceptors);
            };
        case 'Expire':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Expire' };
                await events.onMatch(ctx);
                return handleRedisAPIExpireRequest(ctx, service, data, interceptors);
            };
        case 'ExpireTime':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ExpireTime' };
                await events.onMatch(ctx);
                return handleRedisAPIExpireTimeRequest(ctx, service, data, interceptors);
            };
        case 'ZAdd':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZAdd' };
                await events.onMatch(ctx);
                return handleRedisAPIZAddRequest(ctx, service, data, interceptors);
            };
        case 'ZCard':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZCard' };
                await events.onMatch(ctx);
                return handleRedisAPIZCardRequest(ctx, service, data, interceptors);
            };
        case 'ZRange':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRange' };
                await events.onMatch(ctx);
                return handleRedisAPIZRangeRequest(ctx, service, data, interceptors);
            };
        case 'ZRem':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRem' };
                await events.onMatch(ctx);
                return handleRedisAPIZRemRequest(ctx, service, data, interceptors);
            };
        case 'ZRemRangeByLex':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRemRangeByLex' };
                await events.onMatch(ctx);
                return handleRedisAPIZRemRangeByLexRequest(ctx, service, data, interceptors);
            };
        case 'ZRemRangeByRank':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRemRangeByRank' };
                await events.onMatch(ctx);
                return handleRedisAPIZRemRangeByRankRequest(ctx, service, data, interceptors);
            };
        case 'ZRemRangeByScore':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRemRangeByScore' };
                await events.onMatch(ctx);
                return handleRedisAPIZRemRangeByScoreRequest(ctx, service, data, interceptors);
            };
        case 'ZScore':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZScore' };
                await events.onMatch(ctx);
                return handleRedisAPIZScoreRequest(ctx, service, data, interceptors);
            };
        case 'ZRank':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZRank' };
                await events.onMatch(ctx);
                return handleRedisAPIZRankRequest(ctx, service, data, interceptors);
            };
        case 'ZIncrBy':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZIncrBy' };
                await events.onMatch(ctx);
                return handleRedisAPIZIncrByRequest(ctx, service, data, interceptors);
            };
        case 'ZScan':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ZScan' };
                await events.onMatch(ctx);
                return handleRedisAPIZScanRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIGetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIGetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIGetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPISetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPISetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPISetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIDelRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIDelJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIDelProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPITypeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPITypeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPITypeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIIncrByRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIIncrByJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIIncrByProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHSetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHSetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHSetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHGetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHGetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHGetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHGetAllRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHGetAllJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHGetAllProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHDelRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHDelJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHDelProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHScanRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHScanJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHScanProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHKeysRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHKeysJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHKeysProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHIncrByRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHIncrByJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHIncrByProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIHLenRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIHLenJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIHLenProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIMultiRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIMultiJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIMultiProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIExecRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIExecJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIExecProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIDiscardRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIDiscardJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIDiscardProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIWatchRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIWatchJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIWatchProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIUnwatchRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIUnwatchJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIUnwatchProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIGetRangeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIGetRangeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIGetRangeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPISetRangeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPISetRangeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPISetRangeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIStrlenRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIStrlenJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIStrlenProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIMGetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIMGetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIMGetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIMSetRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIMSetJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIMSetProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIExpireRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIExpireJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIExpireProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIExpireTimeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIExpireTimeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIExpireTimeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZAddRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZAddJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZAddProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZCardRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZCardJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZCardProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRangeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRangeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRangeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRemRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRemJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRemProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRemRangeByLexRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRemRangeByLexJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRemRangeByLexProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRemRangeByRankRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRemRangeByRankJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRemRangeByRankProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRemRangeByScoreRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRemRangeByScoreJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRemRangeByScoreProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZScoreRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZScoreJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZScoreProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZRankRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZRankJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZRankProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZIncrByRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZIncrByJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZIncrByProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleRedisAPIZScanRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleRedisAPIZScanJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleRedisAPIZScanProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleRedisAPIGetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleRedisAPISetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Set(ctx, inputReq);
        });
    }
    else {
        response = await service.Set(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleRedisAPIDelJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeysRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Del(ctx, inputReq);
        });
    }
    else {
        response = await service.Del(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPITypeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Type(ctx, inputReq);
        });
    }
    else {
        response = await service.Type(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleRedisAPIIncrByJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = IncrByRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.IncrBy(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIHSetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = HSetRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HSet(ctx, inputReq);
        });
    }
    else {
        response = await service.HSet(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIHGetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = HGetRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HGet(ctx, inputReq);
        });
    }
    else {
        response = await service.HGet(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleRedisAPIHGetAllJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HGetAll(ctx, inputReq);
        });
    }
    else {
        response = await service.HGetAll(ctx, request);
    }
    return JSON.stringify(RedisFieldValues.toJSON(response));
}
async function handleRedisAPIHDelJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = HDelRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HDel(ctx, inputReq);
        });
    }
    else {
        response = await service.HDel(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIHScanJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = HScanRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HScan(ctx, inputReq);
        });
    }
    else {
        response = await service.HScan(ctx, request);
    }
    return JSON.stringify(HScanResponse.toJSON(response));
}
async function handleRedisAPIHKeysJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HKeys(ctx, inputReq);
        });
    }
    else {
        response = await service.HKeys(ctx, request);
    }
    return JSON.stringify(KeysResponse.toJSON(response));
}
async function handleRedisAPIHIncrByJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = HIncrByRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HIncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.HIncrBy(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIHLenJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HLen(ctx, inputReq);
        });
    }
    else {
        response = await service.HLen(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIMultiJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TransactionId.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Multi(ctx, inputReq);
        });
    }
    else {
        response = await service.Multi(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleRedisAPIExecJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TransactionId.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exec(ctx, inputReq);
        });
    }
    else {
        response = await service.Exec(ctx, request);
    }
    return JSON.stringify(TransactionResponses.toJSON(response));
}
async function handleRedisAPIDiscardJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TransactionId.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Discard(ctx, inputReq);
        });
    }
    else {
        response = await service.Discard(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleRedisAPIWatchJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = WatchRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Watch(ctx, inputReq);
        });
    }
    else {
        response = await service.Watch(ctx, request);
    }
    return JSON.stringify(TransactionId.toJSON(response));
}
async function handleRedisAPIUnwatchJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = TransactionId.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unwatch(ctx, inputReq);
        });
    }
    else {
        response = await service.Unwatch(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleRedisAPIGetRangeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRangeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetRange(ctx, inputReq);
        });
    }
    else {
        response = await service.GetRange(ctx, request);
    }
    return JSON.stringify(StringValue.toJSON(response));
}
async function handleRedisAPISetRangeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = SetRangeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetRange(ctx, inputReq);
        });
    }
    else {
        response = await service.SetRange(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIStrlenJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Strlen(ctx, inputReq);
        });
    }
    else {
        response = await service.Strlen(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIMGetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeysRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MGet(ctx, inputReq);
        });
    }
    else {
        response = await service.MGet(ctx, request);
    }
    return JSON.stringify(RedisValues.toJSON(response));
}
async function handleRedisAPIMSetJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyValuesRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MSet(ctx, inputReq);
        });
    }
    else {
        response = await service.MSet(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleRedisAPIExpireJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ExpireRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Expire(ctx, inputReq);
        });
    }
    else {
        response = await service.Expire(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleRedisAPIExpireTimeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ExpireTime(ctx, inputReq);
        });
    }
    else {
        response = await service.ExpireTime(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZAddJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZAddRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZAdd(ctx, inputReq);
        });
    }
    else {
        response = await service.ZAdd(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZCardJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = KeyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZCard(ctx, inputReq);
        });
    }
    else {
        response = await service.ZCard(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZRangeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRangeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRange(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRange(ctx, request);
    }
    return JSON.stringify(ZMembers.toJSON(response));
}
async function handleRedisAPIZRemJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRemRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRem(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRem(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZRemRangeByLexJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRemRangeByLexRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByLex(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByLex(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZRemRangeByRankJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRemRangeByRankRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByRank(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByRank(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZRemRangeByScoreJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRemRangeByScoreRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByScore(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByScore(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZScoreJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZScoreRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZScore(ctx, inputReq);
        });
    }
    else {
        response = await service.ZScore(ctx, request);
    }
    return JSON.stringify(DoubleValue.toJSON(response));
}
async function handleRedisAPIZRankJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZRankRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRank(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRank(ctx, request);
    }
    return JSON.stringify(Int64Value.toJSON(response));
}
async function handleRedisAPIZIncrByJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZIncrByRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZIncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.ZIncrBy(ctx, request);
    }
    return JSON.stringify(DoubleValue.toJSON(response));
}
async function handleRedisAPIZScanJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ZScanRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZScan(ctx, inputReq);
        });
    }
    else {
        response = await service.ZScan(ctx, request);
    }
    return JSON.stringify(ZScanResponse.toJSON(response));
}
async function handleRedisAPIGetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Get(ctx, inputReq);
        });
    }
    else {
        response = await service.Get(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleRedisAPISetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Set(ctx, inputReq);
        });
    }
    else {
        response = await service.Set(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleRedisAPIDelProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeysRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Del(ctx, inputReq);
        });
    }
    else {
        response = await service.Del(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPITypeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Type(ctx, inputReq);
        });
    }
    else {
        response = await service.Type(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleRedisAPIIncrByProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = IncrByRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.IncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.IncrBy(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIHSetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = HSetRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HSet(ctx, inputReq);
        });
    }
    else {
        response = await service.HSet(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIHGetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = HGetRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HGet(ctx, inputReq);
        });
    }
    else {
        response = await service.HGet(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleRedisAPIHGetAllProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HGetAll(ctx, inputReq);
        });
    }
    else {
        response = await service.HGetAll(ctx, request);
    }
    return Buffer.from(RedisFieldValues.encode(response).finish());
}
async function handleRedisAPIHDelProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = HDelRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HDel(ctx, inputReq);
        });
    }
    else {
        response = await service.HDel(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIHScanProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = HScanRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HScan(ctx, inputReq);
        });
    }
    else {
        response = await service.HScan(ctx, request);
    }
    return Buffer.from(HScanResponse.encode(response).finish());
}
async function handleRedisAPIHKeysProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HKeys(ctx, inputReq);
        });
    }
    else {
        response = await service.HKeys(ctx, request);
    }
    return Buffer.from(KeysResponse.encode(response).finish());
}
async function handleRedisAPIHIncrByProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = HIncrByRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HIncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.HIncrBy(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIHLenProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.HLen(ctx, inputReq);
        });
    }
    else {
        response = await service.HLen(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIMultiProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TransactionId.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Multi(ctx, inputReq);
        });
    }
    else {
        response = await service.Multi(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleRedisAPIExecProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TransactionId.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Exec(ctx, inputReq);
        });
    }
    else {
        response = await service.Exec(ctx, request);
    }
    return Buffer.from(TransactionResponses.encode(response).finish());
}
async function handleRedisAPIDiscardProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TransactionId.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Discard(ctx, inputReq);
        });
    }
    else {
        response = await service.Discard(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleRedisAPIWatchProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = WatchRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Watch(ctx, inputReq);
        });
    }
    else {
        response = await service.Watch(ctx, request);
    }
    return Buffer.from(TransactionId.encode(response).finish());
}
async function handleRedisAPIUnwatchProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = TransactionId.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Unwatch(ctx, inputReq);
        });
    }
    else {
        response = await service.Unwatch(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleRedisAPIGetRangeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRangeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetRange(ctx, inputReq);
        });
    }
    else {
        response = await service.GetRange(ctx, request);
    }
    return Buffer.from(StringValue.encode(response).finish());
}
async function handleRedisAPISetRangeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = SetRangeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.SetRange(ctx, inputReq);
        });
    }
    else {
        response = await service.SetRange(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIStrlenProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Strlen(ctx, inputReq);
        });
    }
    else {
        response = await service.Strlen(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIMGetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeysRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MGet(ctx, inputReq);
        });
    }
    else {
        response = await service.MGet(ctx, request);
    }
    return Buffer.from(RedisValues.encode(response).finish());
}
async function handleRedisAPIMSetProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyValuesRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.MSet(ctx, inputReq);
        });
    }
    else {
        response = await service.MSet(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleRedisAPIExpireProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ExpireRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Expire(ctx, inputReq);
        });
    }
    else {
        response = await service.Expire(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleRedisAPIExpireTimeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ExpireTime(ctx, inputReq);
        });
    }
    else {
        response = await service.ExpireTime(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZAddProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZAddRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZAdd(ctx, inputReq);
        });
    }
    else {
        response = await service.ZAdd(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZCardProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = KeyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZCard(ctx, inputReq);
        });
    }
    else {
        response = await service.ZCard(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZRangeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRangeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRange(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRange(ctx, request);
    }
    return Buffer.from(ZMembers.encode(response).finish());
}
async function handleRedisAPIZRemProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRemRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRem(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRem(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZRemRangeByLexProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRemRangeByLexRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByLex(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByLex(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZRemRangeByRankProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRemRangeByRankRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByRank(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByRank(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZRemRangeByScoreProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRemRangeByScoreRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRemRangeByScore(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRemRangeByScore(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZScoreProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZScoreRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZScore(ctx, inputReq);
        });
    }
    else {
        response = await service.ZScore(ctx, request);
    }
    return Buffer.from(DoubleValue.encode(response).finish());
}
async function handleRedisAPIZRankProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZRankRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZRank(ctx, inputReq);
        });
    }
    else {
        response = await service.ZRank(ctx, request);
    }
    return Buffer.from(Int64Value.encode(response).finish());
}
async function handleRedisAPIZIncrByProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZIncrByRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZIncrBy(ctx, inputReq);
        });
    }
    else {
        response = await service.ZIncrBy(ctx, request);
    }
    return Buffer.from(DoubleValue.encode(response).finish());
}
async function handleRedisAPIZScanProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ZScanRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ZScan(ctx, inputReq);
        });
    }
    else {
        response = await service.ZScan(ctx, request);
    }
    return Buffer.from(ZScanResponse.encode(response).finish());
}
