/**
 * #post.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { ListValue } from "../../google/protobuf/struct.js";
import { BoolValue, FloatValue, Int32Value, StringValue } from "../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../typeRegistry.js";
import { AuthorFlairRichText, Awarding, BanInfo, Gildings, MediaEmbed } from "./common.js";
function createBasePost() {
    return {
        allAwardings: [],
        allowLiveComments: undefined,
        approved: undefined,
        approvedAtUtc: undefined,
        approvedBy: undefined,
        archived: undefined,
        author: undefined,
        authorFlairBackgroundColor: undefined,
        authorFlairCssClass: undefined,
        authorFlairRichtext: [],
        authorFlairTemplateId: undefined,
        authorFlairText: undefined,
        authorFlairTextColor: undefined,
        authorFlairType: undefined,
        authorFullname: undefined,
        authorIsBlocked: undefined,
        authorPatreonFlair: undefined,
        authorPremium: undefined,
        awarders: [],
        bannedAtUtc: undefined,
        bannedBy: undefined,
        canGild: undefined,
        canModPost: undefined,
        category: undefined,
        clicked: undefined,
        contentCategories: [],
        contestMode: undefined,
        created: undefined,
        createdUtc: undefined,
        discussionType: undefined,
        distinguished: undefined,
        domain: undefined,
        downs: undefined,
        edited: undefined,
        gilded: undefined,
        gildings: undefined,
        hidden: undefined,
        hideScore: undefined,
        id: undefined,
        ignoreReports: undefined,
        isCreatedFromAdsUi: undefined,
        isCrosspostable: undefined,
        isMeta: undefined,
        isOriginalContent: undefined,
        isRedditMediaDomain: undefined,
        isRobotIndexable: undefined,
        isSelf: undefined,
        isVideo: undefined,
        likes: undefined,
        linkFlairBackgroundColor: undefined,
        linkFlairCssClass: undefined,
        linkFlairRichtext: [],
        linkFlairTextColor: undefined,
        linkFlairText: undefined,
        linkFlairType: undefined,
        locked: undefined,
        mediaEmbed: undefined,
        mediaOnly: undefined,
        media: undefined,
        modNote: undefined,
        modReasonBy: undefined,
        modReasonTitle: undefined,
        modReports: [],
        name: undefined,
        noFollow: undefined,
        numComments: undefined,
        numCrossposts: undefined,
        numDuplicates: undefined,
        numReports: undefined,
        over18: undefined,
        parentWhitelistStatus: undefined,
        permalink: undefined,
        pinned: undefined,
        postHint: undefined,
        preview: undefined,
        pwls: undefined,
        quarantine: undefined,
        removalReason: undefined,
        removedByCategory: undefined,
        removedBy: undefined,
        removed: undefined,
        reportReasons: [],
        rteMode: undefined,
        saved: undefined,
        score: undefined,
        secureMediaEmbed: undefined,
        secureMedia: undefined,
        selftextHtml: undefined,
        selftext: undefined,
        sendReplies: undefined,
        spam: undefined,
        spoiler: undefined,
        stickied: undefined,
        subredditId: undefined,
        subredditNamePrefixed: undefined,
        subredditSubscribers: undefined,
        subredditType: undefined,
        subreddit: undefined,
        suggestedSort: undefined,
        thumbnailHeight: undefined,
        thumbnailWidth: undefined,
        thumbnail: undefined,
        title: undefined,
        topAwardedType: undefined,
        totalAwardsReceived: undefined,
        treatmentTags: [],
        ups: undefined,
        upvoteRatio: undefined,
        urlOverriddenByDest: undefined,
        url: undefined,
        userReports: [],
        viewCount: undefined,
        visited: undefined,
        whitelistStatus: undefined,
        wls: undefined,
        linkFlairTemplateId: undefined,
        crowdControlLevel: undefined,
        isGallery: undefined,
        isLiveStream: undefined,
        isMetaDiscussion: undefined,
        oembed: undefined,
        banInfo: undefined,
        markedSpam: undefined,
        verdict: undefined,
        gallery: undefined,
    };
}
export const Post = {
    $type: "devvit.reddit.Post",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.allAwardings) {
            Awarding.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.allowLiveComments !== undefined) {
            BoolValue.encode({ value: message.allowLiveComments }, writer.uint32(18).fork()).ldelim();
        }
        if (message.approved !== undefined) {
            BoolValue.encode({ value: message.approved }, writer.uint32(26).fork()).ldelim();
        }
        if (message.approvedAtUtc !== undefined) {
            Int32Value.encode({ value: message.approvedAtUtc }, writer.uint32(34).fork()).ldelim();
        }
        if (message.approvedBy !== undefined) {
            StringValue.encode({ value: message.approvedBy }, writer.uint32(42).fork()).ldelim();
        }
        if (message.archived !== undefined) {
            BoolValue.encode({ value: message.archived }, writer.uint32(50).fork()).ldelim();
        }
        if (message.author !== undefined) {
            StringValue.encode({ value: message.author }, writer.uint32(58).fork()).ldelim();
        }
        if (message.authorFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.authorFlairBackgroundColor }, writer.uint32(66).fork()).ldelim();
        }
        if (message.authorFlairCssClass !== undefined) {
            StringValue.encode({ value: message.authorFlairCssClass }, writer.uint32(74).fork()).ldelim();
        }
        for (const v of message.authorFlairRichtext) {
            AuthorFlairRichText.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.authorFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.authorFlairTemplateId }, writer.uint32(90).fork()).ldelim();
        }
        if (message.authorFlairText !== undefined) {
            StringValue.encode({ value: message.authorFlairText }, writer.uint32(98).fork()).ldelim();
        }
        if (message.authorFlairTextColor !== undefined) {
            StringValue.encode({ value: message.authorFlairTextColor }, writer.uint32(106).fork()).ldelim();
        }
        if (message.authorFlairType !== undefined) {
            StringValue.encode({ value: message.authorFlairType }, writer.uint32(114).fork()).ldelim();
        }
        if (message.authorFullname !== undefined) {
            StringValue.encode({ value: message.authorFullname }, writer.uint32(122).fork()).ldelim();
        }
        if (message.authorIsBlocked !== undefined) {
            BoolValue.encode({ value: message.authorIsBlocked }, writer.uint32(130).fork()).ldelim();
        }
        if (message.authorPatreonFlair !== undefined) {
            BoolValue.encode({ value: message.authorPatreonFlair }, writer.uint32(138).fork()).ldelim();
        }
        if (message.authorPremium !== undefined) {
            BoolValue.encode({ value: message.authorPremium }, writer.uint32(146).fork()).ldelim();
        }
        for (const v of message.awarders) {
            StringValue.encode({ value: v }, writer.uint32(154).fork()).ldelim();
        }
        if (message.bannedAtUtc !== undefined) {
            Int32Value.encode({ value: message.bannedAtUtc }, writer.uint32(162).fork()).ldelim();
        }
        if (message.bannedBy !== undefined) {
            StringValue.encode({ value: message.bannedBy }, writer.uint32(170).fork()).ldelim();
        }
        if (message.canGild !== undefined) {
            BoolValue.encode({ value: message.canGild }, writer.uint32(178).fork()).ldelim();
        }
        if (message.canModPost !== undefined) {
            BoolValue.encode({ value: message.canModPost }, writer.uint32(186).fork()).ldelim();
        }
        if (message.category !== undefined) {
            StringValue.encode({ value: message.category }, writer.uint32(194).fork()).ldelim();
        }
        if (message.clicked !== undefined) {
            BoolValue.encode({ value: message.clicked }, writer.uint32(202).fork()).ldelim();
        }
        for (const v of message.contentCategories) {
            StringValue.encode({ value: v }, writer.uint32(210).fork()).ldelim();
        }
        if (message.contestMode !== undefined) {
            BoolValue.encode({ value: message.contestMode }, writer.uint32(218).fork()).ldelim();
        }
        if (message.created !== undefined) {
            Int32Value.encode({ value: message.created }, writer.uint32(226).fork()).ldelim();
        }
        if (message.createdUtc !== undefined) {
            Int32Value.encode({ value: message.createdUtc }, writer.uint32(234).fork()).ldelim();
        }
        if (message.discussionType !== undefined) {
            StringValue.encode({ value: message.discussionType }, writer.uint32(242).fork()).ldelim();
        }
        if (message.distinguished !== undefined) {
            StringValue.encode({ value: message.distinguished }, writer.uint32(250).fork()).ldelim();
        }
        if (message.domain !== undefined) {
            StringValue.encode({ value: message.domain }, writer.uint32(258).fork()).ldelim();
        }
        if (message.downs !== undefined) {
            Int32Value.encode({ value: message.downs }, writer.uint32(266).fork()).ldelim();
        }
        if (message.edited !== undefined) {
            BoolValue.encode({ value: message.edited }, writer.uint32(274).fork()).ldelim();
        }
        if (message.gilded !== undefined) {
            Int32Value.encode({ value: message.gilded }, writer.uint32(282).fork()).ldelim();
        }
        if (message.gildings !== undefined) {
            Gildings.encode(message.gildings, writer.uint32(290).fork()).ldelim();
        }
        if (message.hidden !== undefined) {
            BoolValue.encode({ value: message.hidden }, writer.uint32(298).fork()).ldelim();
        }
        if (message.hideScore !== undefined) {
            BoolValue.encode({ value: message.hideScore }, writer.uint32(306).fork()).ldelim();
        }
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(314).fork()).ldelim();
        }
        if (message.ignoreReports !== undefined) {
            BoolValue.encode({ value: message.ignoreReports }, writer.uint32(322).fork()).ldelim();
        }
        if (message.isCreatedFromAdsUi !== undefined) {
            BoolValue.encode({ value: message.isCreatedFromAdsUi }, writer.uint32(330).fork()).ldelim();
        }
        if (message.isCrosspostable !== undefined) {
            BoolValue.encode({ value: message.isCrosspostable }, writer.uint32(338).fork()).ldelim();
        }
        if (message.isMeta !== undefined) {
            BoolValue.encode({ value: message.isMeta }, writer.uint32(346).fork()).ldelim();
        }
        if (message.isOriginalContent !== undefined) {
            BoolValue.encode({ value: message.isOriginalContent }, writer.uint32(354).fork()).ldelim();
        }
        if (message.isRedditMediaDomain !== undefined) {
            BoolValue.encode({ value: message.isRedditMediaDomain }, writer.uint32(362).fork()).ldelim();
        }
        if (message.isRobotIndexable !== undefined) {
            BoolValue.encode({ value: message.isRobotIndexable }, writer.uint32(370).fork()).ldelim();
        }
        if (message.isSelf !== undefined) {
            BoolValue.encode({ value: message.isSelf }, writer.uint32(378).fork()).ldelim();
        }
        if (message.isVideo !== undefined) {
            BoolValue.encode({ value: message.isVideo }, writer.uint32(386).fork()).ldelim();
        }
        if (message.likes !== undefined) {
            BoolValue.encode({ value: message.likes }, writer.uint32(394).fork()).ldelim();
        }
        if (message.linkFlairBackgroundColor !== undefined) {
            StringValue.encode({ value: message.linkFlairBackgroundColor }, writer.uint32(402).fork()).ldelim();
        }
        if (message.linkFlairCssClass !== undefined) {
            StringValue.encode({ value: message.linkFlairCssClass }, writer.uint32(410).fork()).ldelim();
        }
        for (const v of message.linkFlairRichtext) {
            StringValue.encode({ value: v }, writer.uint32(418).fork()).ldelim();
        }
        if (message.linkFlairTextColor !== undefined) {
            StringValue.encode({ value: message.linkFlairTextColor }, writer.uint32(426).fork()).ldelim();
        }
        if (message.linkFlairText !== undefined) {
            StringValue.encode({ value: message.linkFlairText }, writer.uint32(434).fork()).ldelim();
        }
        if (message.linkFlairType !== undefined) {
            StringValue.encode({ value: message.linkFlairType }, writer.uint32(442).fork()).ldelim();
        }
        if (message.locked !== undefined) {
            BoolValue.encode({ value: message.locked }, writer.uint32(450).fork()).ldelim();
        }
        if (message.mediaEmbed !== undefined) {
            MediaEmbed.encode(message.mediaEmbed, writer.uint32(458).fork()).ldelim();
        }
        if (message.mediaOnly !== undefined) {
            BoolValue.encode({ value: message.mediaOnly }, writer.uint32(466).fork()).ldelim();
        }
        if (message.media !== undefined) {
            Media.encode(message.media, writer.uint32(474).fork()).ldelim();
        }
        if (message.modNote !== undefined) {
            StringValue.encode({ value: message.modNote }, writer.uint32(482).fork()).ldelim();
        }
        if (message.modReasonBy !== undefined) {
            StringValue.encode({ value: message.modReasonBy }, writer.uint32(490).fork()).ldelim();
        }
        if (message.modReasonTitle !== undefined) {
            StringValue.encode({ value: message.modReasonTitle }, writer.uint32(498).fork()).ldelim();
        }
        for (const v of message.modReports) {
            ListValue.encode(ListValue.wrap(v), writer.uint32(506).fork()).ldelim();
        }
        if (message.name !== undefined) {
            StringValue.encode({ value: message.name }, writer.uint32(514).fork()).ldelim();
        }
        if (message.noFollow !== undefined) {
            BoolValue.encode({ value: message.noFollow }, writer.uint32(522).fork()).ldelim();
        }
        if (message.numComments !== undefined) {
            Int32Value.encode({ value: message.numComments }, writer.uint32(530).fork()).ldelim();
        }
        if (message.numCrossposts !== undefined) {
            Int32Value.encode({ value: message.numCrossposts }, writer.uint32(538).fork()).ldelim();
        }
        if (message.numDuplicates !== undefined) {
            Int32Value.encode({ value: message.numDuplicates }, writer.uint32(546).fork()).ldelim();
        }
        if (message.numReports !== undefined) {
            Int32Value.encode({ value: message.numReports }, writer.uint32(554).fork()).ldelim();
        }
        if (message.over18 !== undefined) {
            BoolValue.encode({ value: message.over18 }, writer.uint32(562).fork()).ldelim();
        }
        if (message.parentWhitelistStatus !== undefined) {
            StringValue.encode({ value: message.parentWhitelistStatus }, writer.uint32(570).fork()).ldelim();
        }
        if (message.permalink !== undefined) {
            StringValue.encode({ value: message.permalink }, writer.uint32(578).fork()).ldelim();
        }
        if (message.pinned !== undefined) {
            BoolValue.encode({ value: message.pinned }, writer.uint32(586).fork()).ldelim();
        }
        if (message.postHint !== undefined) {
            StringValue.encode({ value: message.postHint }, writer.uint32(594).fork()).ldelim();
        }
        if (message.preview !== undefined) {
            Preview.encode(message.preview, writer.uint32(602).fork()).ldelim();
        }
        if (message.pwls !== undefined) {
            Int32Value.encode({ value: message.pwls }, writer.uint32(610).fork()).ldelim();
        }
        if (message.quarantine !== undefined) {
            BoolValue.encode({ value: message.quarantine }, writer.uint32(618).fork()).ldelim();
        }
        if (message.removalReason !== undefined) {
            StringValue.encode({ value: message.removalReason }, writer.uint32(626).fork()).ldelim();
        }
        if (message.removedByCategory !== undefined) {
            StringValue.encode({ value: message.removedByCategory }, writer.uint32(634).fork()).ldelim();
        }
        if (message.removedBy !== undefined) {
            StringValue.encode({ value: message.removedBy }, writer.uint32(642).fork()).ldelim();
        }
        if (message.removed !== undefined) {
            BoolValue.encode({ value: message.removed }, writer.uint32(650).fork()).ldelim();
        }
        for (const v of message.reportReasons) {
            StringValue.encode({ value: v }, writer.uint32(658).fork()).ldelim();
        }
        if (message.rteMode !== undefined) {
            StringValue.encode({ value: message.rteMode }, writer.uint32(666).fork()).ldelim();
        }
        if (message.saved !== undefined) {
            BoolValue.encode({ value: message.saved }, writer.uint32(674).fork()).ldelim();
        }
        if (message.score !== undefined) {
            Int32Value.encode({ value: message.score }, writer.uint32(682).fork()).ldelim();
        }
        if (message.secureMediaEmbed !== undefined) {
            MediaEmbed.encode(message.secureMediaEmbed, writer.uint32(690).fork()).ldelim();
        }
        if (message.secureMedia !== undefined) {
            Media.encode(message.secureMedia, writer.uint32(698).fork()).ldelim();
        }
        if (message.selftextHtml !== undefined) {
            StringValue.encode({ value: message.selftextHtml }, writer.uint32(706).fork()).ldelim();
        }
        if (message.selftext !== undefined) {
            StringValue.encode({ value: message.selftext }, writer.uint32(714).fork()).ldelim();
        }
        if (message.sendReplies !== undefined) {
            BoolValue.encode({ value: message.sendReplies }, writer.uint32(722).fork()).ldelim();
        }
        if (message.spam !== undefined) {
            BoolValue.encode({ value: message.spam }, writer.uint32(730).fork()).ldelim();
        }
        if (message.spoiler !== undefined) {
            BoolValue.encode({ value: message.spoiler }, writer.uint32(738).fork()).ldelim();
        }
        if (message.stickied !== undefined) {
            BoolValue.encode({ value: message.stickied }, writer.uint32(746).fork()).ldelim();
        }
        if (message.subredditId !== undefined) {
            StringValue.encode({ value: message.subredditId }, writer.uint32(754).fork()).ldelim();
        }
        if (message.subredditNamePrefixed !== undefined) {
            StringValue.encode({ value: message.subredditNamePrefixed }, writer.uint32(762).fork()).ldelim();
        }
        if (message.subredditSubscribers !== undefined) {
            Int32Value.encode({ value: message.subredditSubscribers }, writer.uint32(770).fork()).ldelim();
        }
        if (message.subredditType !== undefined) {
            StringValue.encode({ value: message.subredditType }, writer.uint32(778).fork()).ldelim();
        }
        if (message.subreddit !== undefined) {
            StringValue.encode({ value: message.subreddit }, writer.uint32(786).fork()).ldelim();
        }
        if (message.suggestedSort !== undefined) {
            StringValue.encode({ value: message.suggestedSort }, writer.uint32(794).fork()).ldelim();
        }
        if (message.thumbnailHeight !== undefined) {
            Int32Value.encode({ value: message.thumbnailHeight }, writer.uint32(802).fork()).ldelim();
        }
        if (message.thumbnailWidth !== undefined) {
            Int32Value.encode({ value: message.thumbnailWidth }, writer.uint32(810).fork()).ldelim();
        }
        if (message.thumbnail !== undefined) {
            StringValue.encode({ value: message.thumbnail }, writer.uint32(818).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(826).fork()).ldelim();
        }
        if (message.topAwardedType !== undefined) {
            StringValue.encode({ value: message.topAwardedType }, writer.uint32(834).fork()).ldelim();
        }
        if (message.totalAwardsReceived !== undefined) {
            Int32Value.encode({ value: message.totalAwardsReceived }, writer.uint32(842).fork()).ldelim();
        }
        for (const v of message.treatmentTags) {
            StringValue.encode({ value: v }, writer.uint32(850).fork()).ldelim();
        }
        if (message.ups !== undefined) {
            Int32Value.encode({ value: message.ups }, writer.uint32(858).fork()).ldelim();
        }
        if (message.upvoteRatio !== undefined) {
            FloatValue.encode({ value: message.upvoteRatio }, writer.uint32(866).fork()).ldelim();
        }
        if (message.urlOverriddenByDest !== undefined) {
            StringValue.encode({ value: message.urlOverriddenByDest }, writer.uint32(874).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(882).fork()).ldelim();
        }
        for (const v of message.userReports) {
            ListValue.encode(ListValue.wrap(v), writer.uint32(890).fork()).ldelim();
        }
        if (message.viewCount !== undefined) {
            Int32Value.encode({ value: message.viewCount }, writer.uint32(898).fork()).ldelim();
        }
        if (message.visited !== undefined) {
            BoolValue.encode({ value: message.visited }, writer.uint32(906).fork()).ldelim();
        }
        if (message.whitelistStatus !== undefined) {
            StringValue.encode({ value: message.whitelistStatus }, writer.uint32(914).fork()).ldelim();
        }
        if (message.wls !== undefined) {
            Int32Value.encode({ value: message.wls }, writer.uint32(922).fork()).ldelim();
        }
        if (message.linkFlairTemplateId !== undefined) {
            StringValue.encode({ value: message.linkFlairTemplateId }, writer.uint32(1202).fork()).ldelim();
        }
        if (message.crowdControlLevel !== undefined) {
            Int32Value.encode({ value: message.crowdControlLevel }, writer.uint32(1210).fork()).ldelim();
        }
        if (message.isGallery !== undefined) {
            BoolValue.encode({ value: message.isGallery }, writer.uint32(1218).fork()).ldelim();
        }
        if (message.isLiveStream !== undefined) {
            BoolValue.encode({ value: message.isLiveStream }, writer.uint32(1226).fork()).ldelim();
        }
        if (message.isMetaDiscussion !== undefined) {
            BoolValue.encode({ value: message.isMetaDiscussion }, writer.uint32(1234).fork()).ldelim();
        }
        if (message.oembed !== undefined) {
            OEmbed.encode(message.oembed, writer.uint32(1242).fork()).ldelim();
        }
        if (message.banInfo !== undefined) {
            BanInfo.encode(message.banInfo, writer.uint32(1250).fork()).ldelim();
        }
        if (message.markedSpam !== undefined) {
            BoolValue.encode({ value: message.markedSpam }, writer.uint32(1258).fork()).ldelim();
        }
        if (message.verdict !== undefined) {
            StringValue.encode({ value: message.verdict }, writer.uint32(1266).fork()).ldelim();
        }
        if (message.gallery !== undefined) {
            RedditPostGallery.encode(message.gallery, writer.uint32(1274).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePost();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.allAwardings.push(Awarding.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.allowLiveComments = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.approved = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.approvedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.approvedBy = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.archived = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.author = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.authorFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.authorFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.authorFlairRichtext.push(AuthorFlairRichText.decode(reader, reader.uint32()));
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.authorFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.authorFlairText = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.authorFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.authorFlairType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.authorFullname = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.authorIsBlocked = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 17:
                    if (tag !== 138) {
                        break;
                    }
                    message.authorPatreonFlair = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 18:
                    if (tag !== 146) {
                        break;
                    }
                    message.authorPremium = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 19:
                    if (tag !== 154) {
                        break;
                    }
                    message.awarders.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 20:
                    if (tag !== 162) {
                        break;
                    }
                    message.bannedAtUtc = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.bannedBy = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.canGild = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 23:
                    if (tag !== 186) {
                        break;
                    }
                    message.canModPost = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 24:
                    if (tag !== 194) {
                        break;
                    }
                    message.category = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 25:
                    if (tag !== 202) {
                        break;
                    }
                    message.clicked = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 26:
                    if (tag !== 210) {
                        break;
                    }
                    message.contentCategories.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 27:
                    if (tag !== 218) {
                        break;
                    }
                    message.contestMode = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 28:
                    if (tag !== 226) {
                        break;
                    }
                    message.created = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 29:
                    if (tag !== 234) {
                        break;
                    }
                    message.createdUtc = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 30:
                    if (tag !== 242) {
                        break;
                    }
                    message.discussionType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 31:
                    if (tag !== 250) {
                        break;
                    }
                    message.distinguished = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 32:
                    if (tag !== 258) {
                        break;
                    }
                    message.domain = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 33:
                    if (tag !== 266) {
                        break;
                    }
                    message.downs = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 34:
                    if (tag !== 274) {
                        break;
                    }
                    message.edited = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 35:
                    if (tag !== 282) {
                        break;
                    }
                    message.gilded = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 36:
                    if (tag !== 290) {
                        break;
                    }
                    message.gildings = Gildings.decode(reader, reader.uint32());
                    continue;
                case 37:
                    if (tag !== 298) {
                        break;
                    }
                    message.hidden = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 38:
                    if (tag !== 306) {
                        break;
                    }
                    message.hideScore = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 39:
                    if (tag !== 314) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 40:
                    if (tag !== 322) {
                        break;
                    }
                    message.ignoreReports = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 41:
                    if (tag !== 330) {
                        break;
                    }
                    message.isCreatedFromAdsUi = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 42:
                    if (tag !== 338) {
                        break;
                    }
                    message.isCrosspostable = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 43:
                    if (tag !== 346) {
                        break;
                    }
                    message.isMeta = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 44:
                    if (tag !== 354) {
                        break;
                    }
                    message.isOriginalContent = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 45:
                    if (tag !== 362) {
                        break;
                    }
                    message.isRedditMediaDomain = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 46:
                    if (tag !== 370) {
                        break;
                    }
                    message.isRobotIndexable = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 47:
                    if (tag !== 378) {
                        break;
                    }
                    message.isSelf = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 48:
                    if (tag !== 386) {
                        break;
                    }
                    message.isVideo = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 49:
                    if (tag !== 394) {
                        break;
                    }
                    message.likes = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 50:
                    if (tag !== 402) {
                        break;
                    }
                    message.linkFlairBackgroundColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 51:
                    if (tag !== 410) {
                        break;
                    }
                    message.linkFlairCssClass = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 52:
                    if (tag !== 418) {
                        break;
                    }
                    message.linkFlairRichtext.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 53:
                    if (tag !== 426) {
                        break;
                    }
                    message.linkFlairTextColor = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 54:
                    if (tag !== 434) {
                        break;
                    }
                    message.linkFlairText = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 55:
                    if (tag !== 442) {
                        break;
                    }
                    message.linkFlairType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 56:
                    if (tag !== 450) {
                        break;
                    }
                    message.locked = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 57:
                    if (tag !== 458) {
                        break;
                    }
                    message.mediaEmbed = MediaEmbed.decode(reader, reader.uint32());
                    continue;
                case 58:
                    if (tag !== 466) {
                        break;
                    }
                    message.mediaOnly = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 59:
                    if (tag !== 474) {
                        break;
                    }
                    message.media = Media.decode(reader, reader.uint32());
                    continue;
                case 60:
                    if (tag !== 482) {
                        break;
                    }
                    message.modNote = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 61:
                    if (tag !== 490) {
                        break;
                    }
                    message.modReasonBy = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 62:
                    if (tag !== 498) {
                        break;
                    }
                    message.modReasonTitle = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 63:
                    if (tag !== 506) {
                        break;
                    }
                    message.modReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
                    continue;
                case 64:
                    if (tag !== 514) {
                        break;
                    }
                    message.name = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 65:
                    if (tag !== 522) {
                        break;
                    }
                    message.noFollow = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 66:
                    if (tag !== 530) {
                        break;
                    }
                    message.numComments = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 67:
                    if (tag !== 538) {
                        break;
                    }
                    message.numCrossposts = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 68:
                    if (tag !== 546) {
                        break;
                    }
                    message.numDuplicates = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 69:
                    if (tag !== 554) {
                        break;
                    }
                    message.numReports = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 70:
                    if (tag !== 562) {
                        break;
                    }
                    message.over18 = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 71:
                    if (tag !== 570) {
                        break;
                    }
                    message.parentWhitelistStatus = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 72:
                    if (tag !== 578) {
                        break;
                    }
                    message.permalink = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 73:
                    if (tag !== 586) {
                        break;
                    }
                    message.pinned = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 74:
                    if (tag !== 594) {
                        break;
                    }
                    message.postHint = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 75:
                    if (tag !== 602) {
                        break;
                    }
                    message.preview = Preview.decode(reader, reader.uint32());
                    continue;
                case 76:
                    if (tag !== 610) {
                        break;
                    }
                    message.pwls = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 77:
                    if (tag !== 618) {
                        break;
                    }
                    message.quarantine = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 78:
                    if (tag !== 626) {
                        break;
                    }
                    message.removalReason = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 79:
                    if (tag !== 634) {
                        break;
                    }
                    message.removedByCategory = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 80:
                    if (tag !== 642) {
                        break;
                    }
                    message.removedBy = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 81:
                    if (tag !== 650) {
                        break;
                    }
                    message.removed = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 82:
                    if (tag !== 658) {
                        break;
                    }
                    message.reportReasons.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 83:
                    if (tag !== 666) {
                        break;
                    }
                    message.rteMode = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 84:
                    if (tag !== 674) {
                        break;
                    }
                    message.saved = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 85:
                    if (tag !== 682) {
                        break;
                    }
                    message.score = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 86:
                    if (tag !== 690) {
                        break;
                    }
                    message.secureMediaEmbed = MediaEmbed.decode(reader, reader.uint32());
                    continue;
                case 87:
                    if (tag !== 698) {
                        break;
                    }
                    message.secureMedia = Media.decode(reader, reader.uint32());
                    continue;
                case 88:
                    if (tag !== 706) {
                        break;
                    }
                    message.selftextHtml = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 89:
                    if (tag !== 714) {
                        break;
                    }
                    message.selftext = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 90:
                    if (tag !== 722) {
                        break;
                    }
                    message.sendReplies = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 91:
                    if (tag !== 730) {
                        break;
                    }
                    message.spam = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 92:
                    if (tag !== 738) {
                        break;
                    }
                    message.spoiler = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 93:
                    if (tag !== 746) {
                        break;
                    }
                    message.stickied = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 94:
                    if (tag !== 754) {
                        break;
                    }
                    message.subredditId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 95:
                    if (tag !== 762) {
                        break;
                    }
                    message.subredditNamePrefixed = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 96:
                    if (tag !== 770) {
                        break;
                    }
                    message.subredditSubscribers = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 97:
                    if (tag !== 778) {
                        break;
                    }
                    message.subredditType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 98:
                    if (tag !== 786) {
                        break;
                    }
                    message.subreddit = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 99:
                    if (tag !== 794) {
                        break;
                    }
                    message.suggestedSort = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 100:
                    if (tag !== 802) {
                        break;
                    }
                    message.thumbnailHeight = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 101:
                    if (tag !== 810) {
                        break;
                    }
                    message.thumbnailWidth = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 102:
                    if (tag !== 818) {
                        break;
                    }
                    message.thumbnail = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 103:
                    if (tag !== 826) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 104:
                    if (tag !== 834) {
                        break;
                    }
                    message.topAwardedType = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 105:
                    if (tag !== 842) {
                        break;
                    }
                    message.totalAwardsReceived = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 106:
                    if (tag !== 850) {
                        break;
                    }
                    message.treatmentTags.push(StringValue.decode(reader, reader.uint32()).value);
                    continue;
                case 107:
                    if (tag !== 858) {
                        break;
                    }
                    message.ups = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 108:
                    if (tag !== 866) {
                        break;
                    }
                    message.upvoteRatio = FloatValue.decode(reader, reader.uint32()).value;
                    continue;
                case 109:
                    if (tag !== 874) {
                        break;
                    }
                    message.urlOverriddenByDest = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 110:
                    if (tag !== 882) {
                        break;
                    }
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 111:
                    if (tag !== 890) {
                        break;
                    }
                    message.userReports.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
                    continue;
                case 112:
                    if (tag !== 898) {
                        break;
                    }
                    message.viewCount = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 113:
                    if (tag !== 906) {
                        break;
                    }
                    message.visited = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 114:
                    if (tag !== 914) {
                        break;
                    }
                    message.whitelistStatus = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 115:
                    if (tag !== 922) {
                        break;
                    }
                    message.wls = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 150:
                    if (tag !== 1202) {
                        break;
                    }
                    message.linkFlairTemplateId = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 151:
                    if (tag !== 1210) {
                        break;
                    }
                    message.crowdControlLevel = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 152:
                    if (tag !== 1218) {
                        break;
                    }
                    message.isGallery = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 153:
                    if (tag !== 1226) {
                        break;
                    }
                    message.isLiveStream = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 154:
                    if (tag !== 1234) {
                        break;
                    }
                    message.isMetaDiscussion = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 155:
                    if (tag !== 1242) {
                        break;
                    }
                    message.oembed = OEmbed.decode(reader, reader.uint32());
                    continue;
                case 156:
                    if (tag !== 1250) {
                        break;
                    }
                    message.banInfo = BanInfo.decode(reader, reader.uint32());
                    continue;
                case 157:
                    if (tag !== 1258) {
                        break;
                    }
                    message.markedSpam = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 158:
                    if (tag !== 1266) {
                        break;
                    }
                    message.verdict = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 159:
                    if (tag !== 1274) {
                        break;
                    }
                    message.gallery = RedditPostGallery.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            allAwardings: globalThis.Array.isArray(object?.allAwardings)
                ? object.allAwardings.map((e) => Awarding.fromJSON(e))
                : [],
            allowLiveComments: isSet(object.allowLiveComments) ? Boolean(object.allowLiveComments) : undefined,
            approved: isSet(object.approved) ? Boolean(object.approved) : undefined,
            approvedAtUtc: isSet(object.approvedAtUtc) ? Number(object.approvedAtUtc) : undefined,
            approvedBy: isSet(object.approvedBy) ? String(object.approvedBy) : undefined,
            archived: isSet(object.archived) ? Boolean(object.archived) : undefined,
            author: isSet(object.author) ? String(object.author) : undefined,
            authorFlairBackgroundColor: isSet(object.authorFlairBackgroundColor)
                ? String(object.authorFlairBackgroundColor)
                : undefined,
            authorFlairCssClass: isSet(object.authorFlairCssClass) ? String(object.authorFlairCssClass) : undefined,
            authorFlairRichtext: globalThis.Array.isArray(object?.authorFlairRichtext)
                ? object.authorFlairRichtext.map((e) => AuthorFlairRichText.fromJSON(e))
                : [],
            authorFlairTemplateId: isSet(object.authorFlairTemplateId) ? String(object.authorFlairTemplateId) : undefined,
            authorFlairText: isSet(object.authorFlairText) ? String(object.authorFlairText) : undefined,
            authorFlairTextColor: isSet(object.authorFlairTextColor) ? String(object.authorFlairTextColor) : undefined,
            authorFlairType: isSet(object.authorFlairType) ? String(object.authorFlairType) : undefined,
            authorFullname: isSet(object.authorFullname) ? String(object.authorFullname) : undefined,
            authorIsBlocked: isSet(object.authorIsBlocked) ? Boolean(object.authorIsBlocked) : undefined,
            authorPatreonFlair: isSet(object.authorPatreonFlair) ? Boolean(object.authorPatreonFlair) : undefined,
            authorPremium: isSet(object.authorPremium) ? Boolean(object.authorPremium) : undefined,
            awarders: globalThis.Array.isArray(object?.awarders) ? object.awarders.map((e) => String(e)) : [],
            bannedAtUtc: isSet(object.bannedAtUtc) ? Number(object.bannedAtUtc) : undefined,
            bannedBy: isSet(object.bannedBy) ? String(object.bannedBy) : undefined,
            canGild: isSet(object.canGild) ? Boolean(object.canGild) : undefined,
            canModPost: isSet(object.canModPost) ? Boolean(object.canModPost) : undefined,
            category: isSet(object.category) ? String(object.category) : undefined,
            clicked: isSet(object.clicked) ? Boolean(object.clicked) : undefined,
            contentCategories: globalThis.Array.isArray(object?.contentCategories)
                ? object.contentCategories.map((e) => String(e))
                : [],
            contestMode: isSet(object.contestMode) ? Boolean(object.contestMode) : undefined,
            created: isSet(object.created) ? Number(object.created) : undefined,
            createdUtc: isSet(object.createdUtc) ? Number(object.createdUtc) : undefined,
            discussionType: isSet(object.discussionType) ? String(object.discussionType) : undefined,
            distinguished: isSet(object.distinguished) ? String(object.distinguished) : undefined,
            domain: isSet(object.domain) ? String(object.domain) : undefined,
            downs: isSet(object.downs) ? Number(object.downs) : undefined,
            edited: isSet(object.edited) ? Boolean(object.edited) : undefined,
            gilded: isSet(object.gilded) ? Number(object.gilded) : undefined,
            gildings: isSet(object.gildings) ? Gildings.fromJSON(object.gildings) : undefined,
            hidden: isSet(object.hidden) ? Boolean(object.hidden) : undefined,
            hideScore: isSet(object.hideScore) ? Boolean(object.hideScore) : undefined,
            id: isSet(object.id) ? String(object.id) : undefined,
            ignoreReports: isSet(object.ignoreReports) ? Boolean(object.ignoreReports) : undefined,
            isCreatedFromAdsUi: isSet(object.isCreatedFromAdsUi) ? Boolean(object.isCreatedFromAdsUi) : undefined,
            isCrosspostable: isSet(object.isCrosspostable) ? Boolean(object.isCrosspostable) : undefined,
            isMeta: isSet(object.isMeta) ? Boolean(object.isMeta) : undefined,
            isOriginalContent: isSet(object.isOriginalContent) ? Boolean(object.isOriginalContent) : undefined,
            isRedditMediaDomain: isSet(object.isRedditMediaDomain) ? Boolean(object.isRedditMediaDomain) : undefined,
            isRobotIndexable: isSet(object.isRobotIndexable) ? Boolean(object.isRobotIndexable) : undefined,
            isSelf: isSet(object.isSelf) ? Boolean(object.isSelf) : undefined,
            isVideo: isSet(object.isVideo) ? Boolean(object.isVideo) : undefined,
            likes: isSet(object.likes) ? Boolean(object.likes) : undefined,
            linkFlairBackgroundColor: isSet(object.linkFlairBackgroundColor)
                ? String(object.linkFlairBackgroundColor)
                : undefined,
            linkFlairCssClass: isSet(object.linkFlairCssClass) ? String(object.linkFlairCssClass) : undefined,
            linkFlairRichtext: globalThis.Array.isArray(object?.linkFlairRichtext)
                ? object.linkFlairRichtext.map((e) => String(e))
                : [],
            linkFlairTextColor: isSet(object.linkFlairTextColor) ? String(object.linkFlairTextColor) : undefined,
            linkFlairText: isSet(object.linkFlairText) ? String(object.linkFlairText) : undefined,
            linkFlairType: isSet(object.linkFlairType) ? String(object.linkFlairType) : undefined,
            locked: isSet(object.locked) ? Boolean(object.locked) : undefined,
            mediaEmbed: isSet(object.mediaEmbed) ? MediaEmbed.fromJSON(object.mediaEmbed) : undefined,
            mediaOnly: isSet(object.mediaOnly) ? Boolean(object.mediaOnly) : undefined,
            media: isSet(object.media) ? Media.fromJSON(object.media) : undefined,
            modNote: isSet(object.modNote) ? String(object.modNote) : undefined,
            modReasonBy: isSet(object.modReasonBy) ? String(object.modReasonBy) : undefined,
            modReasonTitle: isSet(object.modReasonTitle) ? String(object.modReasonTitle) : undefined,
            modReports: globalThis.Array.isArray(object?.modReports) ? object.modReports.map((e) => [...e]) : [],
            name: isSet(object.name) ? String(object.name) : undefined,
            noFollow: isSet(object.noFollow) ? Boolean(object.noFollow) : undefined,
            numComments: isSet(object.numComments) ? Number(object.numComments) : undefined,
            numCrossposts: isSet(object.numCrossposts) ? Number(object.numCrossposts) : undefined,
            numDuplicates: isSet(object.numDuplicates) ? Number(object.numDuplicates) : undefined,
            numReports: isSet(object.numReports) ? Number(object.numReports) : undefined,
            over18: isSet(object.over18) ? Boolean(object.over18) : undefined,
            parentWhitelistStatus: isSet(object.parentWhitelistStatus) ? String(object.parentWhitelistStatus) : undefined,
            permalink: isSet(object.permalink) ? String(object.permalink) : undefined,
            pinned: isSet(object.pinned) ? Boolean(object.pinned) : undefined,
            postHint: isSet(object.postHint) ? String(object.postHint) : undefined,
            preview: isSet(object.preview) ? Preview.fromJSON(object.preview) : undefined,
            pwls: isSet(object.pwls) ? Number(object.pwls) : undefined,
            quarantine: isSet(object.quarantine) ? Boolean(object.quarantine) : undefined,
            removalReason: isSet(object.removalReason) ? String(object.removalReason) : undefined,
            removedByCategory: isSet(object.removedByCategory) ? String(object.removedByCategory) : undefined,
            removedBy: isSet(object.removedBy) ? String(object.removedBy) : undefined,
            removed: isSet(object.removed) ? Boolean(object.removed) : undefined,
            reportReasons: globalThis.Array.isArray(object?.reportReasons)
                ? object.reportReasons.map((e) => String(e))
                : [],
            rteMode: isSet(object.rteMode) ? String(object.rteMode) : undefined,
            saved: isSet(object.saved) ? Boolean(object.saved) : undefined,
            score: isSet(object.score) ? Number(object.score) : undefined,
            secureMediaEmbed: isSet(object.secureMediaEmbed) ? MediaEmbed.fromJSON(object.secureMediaEmbed) : undefined,
            secureMedia: isSet(object.secureMedia) ? Media.fromJSON(object.secureMedia) : undefined,
            selftextHtml: isSet(object.selftextHtml) ? String(object.selftextHtml) : undefined,
            selftext: isSet(object.selftext) ? String(object.selftext) : undefined,
            sendReplies: isSet(object.sendReplies) ? Boolean(object.sendReplies) : undefined,
            spam: isSet(object.spam) ? Boolean(object.spam) : undefined,
            spoiler: isSet(object.spoiler) ? Boolean(object.spoiler) : undefined,
            stickied: isSet(object.stickied) ? Boolean(object.stickied) : undefined,
            subredditId: isSet(object.subredditId) ? String(object.subredditId) : undefined,
            subredditNamePrefixed: isSet(object.subredditNamePrefixed) ? String(object.subredditNamePrefixed) : undefined,
            subredditSubscribers: isSet(object.subredditSubscribers) ? Number(object.subredditSubscribers) : undefined,
            subredditType: isSet(object.subredditType) ? String(object.subredditType) : undefined,
            subreddit: isSet(object.subreddit) ? String(object.subreddit) : undefined,
            suggestedSort: isSet(object.suggestedSort) ? String(object.suggestedSort) : undefined,
            thumbnailHeight: isSet(object.thumbnailHeight) ? Number(object.thumbnailHeight) : undefined,
            thumbnailWidth: isSet(object.thumbnailWidth) ? Number(object.thumbnailWidth) : undefined,
            thumbnail: isSet(object.thumbnail) ? String(object.thumbnail) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
            topAwardedType: isSet(object.topAwardedType) ? String(object.topAwardedType) : undefined,
            totalAwardsReceived: isSet(object.totalAwardsReceived) ? Number(object.totalAwardsReceived) : undefined,
            treatmentTags: globalThis.Array.isArray(object?.treatmentTags)
                ? object.treatmentTags.map((e) => String(e))
                : [],
            ups: isSet(object.ups) ? Number(object.ups) : undefined,
            upvoteRatio: isSet(object.upvoteRatio) ? Number(object.upvoteRatio) : undefined,
            urlOverriddenByDest: isSet(object.urlOverriddenByDest) ? String(object.urlOverriddenByDest) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            userReports: globalThis.Array.isArray(object?.userReports) ? object.userReports.map((e) => [...e]) : [],
            viewCount: isSet(object.viewCount) ? Number(object.viewCount) : undefined,
            visited: isSet(object.visited) ? Boolean(object.visited) : undefined,
            whitelistStatus: isSet(object.whitelistStatus) ? String(object.whitelistStatus) : undefined,
            wls: isSet(object.wls) ? Number(object.wls) : undefined,
            linkFlairTemplateId: isSet(object.linkFlairTemplateId) ? String(object.linkFlairTemplateId) : undefined,
            crowdControlLevel: isSet(object.crowdControlLevel) ? Number(object.crowdControlLevel) : undefined,
            isGallery: isSet(object.isGallery) ? Boolean(object.isGallery) : undefined,
            isLiveStream: isSet(object.isLiveStream) ? Boolean(object.isLiveStream) : undefined,
            isMetaDiscussion: isSet(object.isMetaDiscussion) ? Boolean(object.isMetaDiscussion) : undefined,
            oembed: isSet(object.oembed) ? OEmbed.fromJSON(object.oembed) : undefined,
            banInfo: isSet(object.banInfo) ? BanInfo.fromJSON(object.banInfo) : undefined,
            markedSpam: isSet(object.markedSpam) ? Boolean(object.markedSpam) : undefined,
            verdict: isSet(object.verdict) ? String(object.verdict) : undefined,
            gallery: isSet(object.gallery) ? RedditPostGallery.fromJSON(object.gallery) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.allAwardings?.length) {
            obj.allAwardings = message.allAwardings.map((e) => Awarding.toJSON(e));
        }
        if (message.allowLiveComments !== undefined) {
            obj.allowLiveComments = message.allowLiveComments;
        }
        if (message.approved !== undefined) {
            obj.approved = message.approved;
        }
        if (message.approvedAtUtc !== undefined) {
            obj.approvedAtUtc = message.approvedAtUtc;
        }
        if (message.approvedBy !== undefined) {
            obj.approvedBy = message.approvedBy;
        }
        if (message.archived !== undefined) {
            obj.archived = message.archived;
        }
        if (message.author !== undefined) {
            obj.author = message.author;
        }
        if (message.authorFlairBackgroundColor !== undefined) {
            obj.authorFlairBackgroundColor = message.authorFlairBackgroundColor;
        }
        if (message.authorFlairCssClass !== undefined) {
            obj.authorFlairCssClass = message.authorFlairCssClass;
        }
        if (message.authorFlairRichtext?.length) {
            obj.authorFlairRichtext = message.authorFlairRichtext.map((e) => AuthorFlairRichText.toJSON(e));
        }
        if (message.authorFlairTemplateId !== undefined) {
            obj.authorFlairTemplateId = message.authorFlairTemplateId;
        }
        if (message.authorFlairText !== undefined) {
            obj.authorFlairText = message.authorFlairText;
        }
        if (message.authorFlairTextColor !== undefined) {
            obj.authorFlairTextColor = message.authorFlairTextColor;
        }
        if (message.authorFlairType !== undefined) {
            obj.authorFlairType = message.authorFlairType;
        }
        if (message.authorFullname !== undefined) {
            obj.authorFullname = message.authorFullname;
        }
        if (message.authorIsBlocked !== undefined) {
            obj.authorIsBlocked = message.authorIsBlocked;
        }
        if (message.authorPatreonFlair !== undefined) {
            obj.authorPatreonFlair = message.authorPatreonFlair;
        }
        if (message.authorPremium !== undefined) {
            obj.authorPremium = message.authorPremium;
        }
        if (message.awarders?.length) {
            obj.awarders = message.awarders;
        }
        if (message.bannedAtUtc !== undefined) {
            obj.bannedAtUtc = message.bannedAtUtc;
        }
        if (message.bannedBy !== undefined) {
            obj.bannedBy = message.bannedBy;
        }
        if (message.canGild !== undefined) {
            obj.canGild = message.canGild;
        }
        if (message.canModPost !== undefined) {
            obj.canModPost = message.canModPost;
        }
        if (message.category !== undefined) {
            obj.category = message.category;
        }
        if (message.clicked !== undefined) {
            obj.clicked = message.clicked;
        }
        if (message.contentCategories?.length) {
            obj.contentCategories = message.contentCategories;
        }
        if (message.contestMode !== undefined) {
            obj.contestMode = message.contestMode;
        }
        if (message.created !== undefined) {
            obj.created = message.created;
        }
        if (message.createdUtc !== undefined) {
            obj.createdUtc = message.createdUtc;
        }
        if (message.discussionType !== undefined) {
            obj.discussionType = message.discussionType;
        }
        if (message.distinguished !== undefined) {
            obj.distinguished = message.distinguished;
        }
        if (message.domain !== undefined) {
            obj.domain = message.domain;
        }
        if (message.downs !== undefined) {
            obj.downs = message.downs;
        }
        if (message.edited !== undefined) {
            obj.edited = message.edited;
        }
        if (message.gilded !== undefined) {
            obj.gilded = message.gilded;
        }
        if (message.gildings !== undefined) {
            obj.gildings = Gildings.toJSON(message.gildings);
        }
        if (message.hidden !== undefined) {
            obj.hidden = message.hidden;
        }
        if (message.hideScore !== undefined) {
            obj.hideScore = message.hideScore;
        }
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.ignoreReports !== undefined) {
            obj.ignoreReports = message.ignoreReports;
        }
        if (message.isCreatedFromAdsUi !== undefined) {
            obj.isCreatedFromAdsUi = message.isCreatedFromAdsUi;
        }
        if (message.isCrosspostable !== undefined) {
            obj.isCrosspostable = message.isCrosspostable;
        }
        if (message.isMeta !== undefined) {
            obj.isMeta = message.isMeta;
        }
        if (message.isOriginalContent !== undefined) {
            obj.isOriginalContent = message.isOriginalContent;
        }
        if (message.isRedditMediaDomain !== undefined) {
            obj.isRedditMediaDomain = message.isRedditMediaDomain;
        }
        if (message.isRobotIndexable !== undefined) {
            obj.isRobotIndexable = message.isRobotIndexable;
        }
        if (message.isSelf !== undefined) {
            obj.isSelf = message.isSelf;
        }
        if (message.isVideo !== undefined) {
            obj.isVideo = message.isVideo;
        }
        if (message.likes !== undefined) {
            obj.likes = message.likes;
        }
        if (message.linkFlairBackgroundColor !== undefined) {
            obj.linkFlairBackgroundColor = message.linkFlairBackgroundColor;
        }
        if (message.linkFlairCssClass !== undefined) {
            obj.linkFlairCssClass = message.linkFlairCssClass;
        }
        if (message.linkFlairRichtext?.length) {
            obj.linkFlairRichtext = message.linkFlairRichtext;
        }
        if (message.linkFlairTextColor !== undefined) {
            obj.linkFlairTextColor = message.linkFlairTextColor;
        }
        if (message.linkFlairText !== undefined) {
            obj.linkFlairText = message.linkFlairText;
        }
        if (message.linkFlairType !== undefined) {
            obj.linkFlairType = message.linkFlairType;
        }
        if (message.locked !== undefined) {
            obj.locked = message.locked;
        }
        if (message.mediaEmbed !== undefined) {
            obj.mediaEmbed = MediaEmbed.toJSON(message.mediaEmbed);
        }
        if (message.mediaOnly !== undefined) {
            obj.mediaOnly = message.mediaOnly;
        }
        if (message.media !== undefined) {
            obj.media = Media.toJSON(message.media);
        }
        if (message.modNote !== undefined) {
            obj.modNote = message.modNote;
        }
        if (message.modReasonBy !== undefined) {
            obj.modReasonBy = message.modReasonBy;
        }
        if (message.modReasonTitle !== undefined) {
            obj.modReasonTitle = message.modReasonTitle;
        }
        if (message.modReports?.length) {
            obj.modReports = message.modReports;
        }
        if (message.name !== undefined) {
            obj.name = message.name;
        }
        if (message.noFollow !== undefined) {
            obj.noFollow = message.noFollow;
        }
        if (message.numComments !== undefined) {
            obj.numComments = message.numComments;
        }
        if (message.numCrossposts !== undefined) {
            obj.numCrossposts = message.numCrossposts;
        }
        if (message.numDuplicates !== undefined) {
            obj.numDuplicates = message.numDuplicates;
        }
        if (message.numReports !== undefined) {
            obj.numReports = message.numReports;
        }
        if (message.over18 !== undefined) {
            obj.over18 = message.over18;
        }
        if (message.parentWhitelistStatus !== undefined) {
            obj.parentWhitelistStatus = message.parentWhitelistStatus;
        }
        if (message.permalink !== undefined) {
            obj.permalink = message.permalink;
        }
        if (message.pinned !== undefined) {
            obj.pinned = message.pinned;
        }
        if (message.postHint !== undefined) {
            obj.postHint = message.postHint;
        }
        if (message.preview !== undefined) {
            obj.preview = Preview.toJSON(message.preview);
        }
        if (message.pwls !== undefined) {
            obj.pwls = message.pwls;
        }
        if (message.quarantine !== undefined) {
            obj.quarantine = message.quarantine;
        }
        if (message.removalReason !== undefined) {
            obj.removalReason = message.removalReason;
        }
        if (message.removedByCategory !== undefined) {
            obj.removedByCategory = message.removedByCategory;
        }
        if (message.removedBy !== undefined) {
            obj.removedBy = message.removedBy;
        }
        if (message.removed !== undefined) {
            obj.removed = message.removed;
        }
        if (message.reportReasons?.length) {
            obj.reportReasons = message.reportReasons;
        }
        if (message.rteMode !== undefined) {
            obj.rteMode = message.rteMode;
        }
        if (message.saved !== undefined) {
            obj.saved = message.saved;
        }
        if (message.score !== undefined) {
            obj.score = message.score;
        }
        if (message.secureMediaEmbed !== undefined) {
            obj.secureMediaEmbed = MediaEmbed.toJSON(message.secureMediaEmbed);
        }
        if (message.secureMedia !== undefined) {
            obj.secureMedia = Media.toJSON(message.secureMedia);
        }
        if (message.selftextHtml !== undefined) {
            obj.selftextHtml = message.selftextHtml;
        }
        if (message.selftext !== undefined) {
            obj.selftext = message.selftext;
        }
        if (message.sendReplies !== undefined) {
            obj.sendReplies = message.sendReplies;
        }
        if (message.spam !== undefined) {
            obj.spam = message.spam;
        }
        if (message.spoiler !== undefined) {
            obj.spoiler = message.spoiler;
        }
        if (message.stickied !== undefined) {
            obj.stickied = message.stickied;
        }
        if (message.subredditId !== undefined) {
            obj.subredditId = message.subredditId;
        }
        if (message.subredditNamePrefixed !== undefined) {
            obj.subredditNamePrefixed = message.subredditNamePrefixed;
        }
        if (message.subredditSubscribers !== undefined) {
            obj.subredditSubscribers = message.subredditSubscribers;
        }
        if (message.subredditType !== undefined) {
            obj.subredditType = message.subredditType;
        }
        if (message.subreddit !== undefined) {
            obj.subreddit = message.subreddit;
        }
        if (message.suggestedSort !== undefined) {
            obj.suggestedSort = message.suggestedSort;
        }
        if (message.thumbnailHeight !== undefined) {
            obj.thumbnailHeight = message.thumbnailHeight;
        }
        if (message.thumbnailWidth !== undefined) {
            obj.thumbnailWidth = message.thumbnailWidth;
        }
        if (message.thumbnail !== undefined) {
            obj.thumbnail = message.thumbnail;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        if (message.topAwardedType !== undefined) {
            obj.topAwardedType = message.topAwardedType;
        }
        if (message.totalAwardsReceived !== undefined) {
            obj.totalAwardsReceived = message.totalAwardsReceived;
        }
        if (message.treatmentTags?.length) {
            obj.treatmentTags = message.treatmentTags;
        }
        if (message.ups !== undefined) {
            obj.ups = message.ups;
        }
        if (message.upvoteRatio !== undefined) {
            obj.upvoteRatio = message.upvoteRatio;
        }
        if (message.urlOverriddenByDest !== undefined) {
            obj.urlOverriddenByDest = message.urlOverriddenByDest;
        }
        if (message.url !== undefined) {
            obj.url = message.url;
        }
        if (message.userReports?.length) {
            obj.userReports = message.userReports;
        }
        if (message.viewCount !== undefined) {
            obj.viewCount = message.viewCount;
        }
        if (message.visited !== undefined) {
            obj.visited = message.visited;
        }
        if (message.whitelistStatus !== undefined) {
            obj.whitelistStatus = message.whitelistStatus;
        }
        if (message.wls !== undefined) {
            obj.wls = message.wls;
        }
        if (message.linkFlairTemplateId !== undefined) {
            obj.linkFlairTemplateId = message.linkFlairTemplateId;
        }
        if (message.crowdControlLevel !== undefined) {
            obj.crowdControlLevel = message.crowdControlLevel;
        }
        if (message.isGallery !== undefined) {
            obj.isGallery = message.isGallery;
        }
        if (message.isLiveStream !== undefined) {
            obj.isLiveStream = message.isLiveStream;
        }
        if (message.isMetaDiscussion !== undefined) {
            obj.isMetaDiscussion = message.isMetaDiscussion;
        }
        if (message.oembed !== undefined) {
            obj.oembed = OEmbed.toJSON(message.oembed);
        }
        if (message.banInfo !== undefined) {
            obj.banInfo = BanInfo.toJSON(message.banInfo);
        }
        if (message.markedSpam !== undefined) {
            obj.markedSpam = message.markedSpam;
        }
        if (message.verdict !== undefined) {
            obj.verdict = message.verdict;
        }
        if (message.gallery !== undefined) {
            obj.gallery = RedditPostGallery.toJSON(message.gallery);
        }
        return obj;
    },
    create(base) {
        return Post.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePost();
        message.allAwardings = object.allAwardings?.map((e) => Awarding.fromPartial(e)) || [];
        message.allowLiveComments = object.allowLiveComments ?? undefined;
        message.approved = object.approved ?? undefined;
        message.approvedAtUtc = object.approvedAtUtc ?? undefined;
        message.approvedBy = object.approvedBy ?? undefined;
        message.archived = object.archived ?? undefined;
        message.author = object.author ?? undefined;
        message.authorFlairBackgroundColor = object.authorFlairBackgroundColor ?? undefined;
        message.authorFlairCssClass = object.authorFlairCssClass ?? undefined;
        message.authorFlairRichtext = object.authorFlairRichtext?.map((e) => AuthorFlairRichText.fromPartial(e)) || [];
        message.authorFlairTemplateId = object.authorFlairTemplateId ?? undefined;
        message.authorFlairText = object.authorFlairText ?? undefined;
        message.authorFlairTextColor = object.authorFlairTextColor ?? undefined;
        message.authorFlairType = object.authorFlairType ?? undefined;
        message.authorFullname = object.authorFullname ?? undefined;
        message.authorIsBlocked = object.authorIsBlocked ?? undefined;
        message.authorPatreonFlair = object.authorPatreonFlair ?? undefined;
        message.authorPremium = object.authorPremium ?? undefined;
        message.awarders = object.awarders?.map((e) => e) || [];
        message.bannedAtUtc = object.bannedAtUtc ?? undefined;
        message.bannedBy = object.bannedBy ?? undefined;
        message.canGild = object.canGild ?? undefined;
        message.canModPost = object.canModPost ?? undefined;
        message.category = object.category ?? undefined;
        message.clicked = object.clicked ?? undefined;
        message.contentCategories = object.contentCategories?.map((e) => e) || [];
        message.contestMode = object.contestMode ?? undefined;
        message.created = object.created ?? undefined;
        message.createdUtc = object.createdUtc ?? undefined;
        message.discussionType = object.discussionType ?? undefined;
        message.distinguished = object.distinguished ?? undefined;
        message.domain = object.domain ?? undefined;
        message.downs = object.downs ?? undefined;
        message.edited = object.edited ?? undefined;
        message.gilded = object.gilded ?? undefined;
        message.gildings = (object.gildings !== undefined && object.gildings !== null)
            ? Gildings.fromPartial(object.gildings)
            : undefined;
        message.hidden = object.hidden ?? undefined;
        message.hideScore = object.hideScore ?? undefined;
        message.id = object.id ?? undefined;
        message.ignoreReports = object.ignoreReports ?? undefined;
        message.isCreatedFromAdsUi = object.isCreatedFromAdsUi ?? undefined;
        message.isCrosspostable = object.isCrosspostable ?? undefined;
        message.isMeta = object.isMeta ?? undefined;
        message.isOriginalContent = object.isOriginalContent ?? undefined;
        message.isRedditMediaDomain = object.isRedditMediaDomain ?? undefined;
        message.isRobotIndexable = object.isRobotIndexable ?? undefined;
        message.isSelf = object.isSelf ?? undefined;
        message.isVideo = object.isVideo ?? undefined;
        message.likes = object.likes ?? undefined;
        message.linkFlairBackgroundColor = object.linkFlairBackgroundColor ?? undefined;
        message.linkFlairCssClass = object.linkFlairCssClass ?? undefined;
        message.linkFlairRichtext = object.linkFlairRichtext?.map((e) => e) || [];
        message.linkFlairTextColor = object.linkFlairTextColor ?? undefined;
        message.linkFlairText = object.linkFlairText ?? undefined;
        message.linkFlairType = object.linkFlairType ?? undefined;
        message.locked = object.locked ?? undefined;
        message.mediaEmbed = (object.mediaEmbed !== undefined && object.mediaEmbed !== null)
            ? MediaEmbed.fromPartial(object.mediaEmbed)
            : undefined;
        message.mediaOnly = object.mediaOnly ?? undefined;
        message.media = (object.media !== undefined && object.media !== null) ? Media.fromPartial(object.media) : undefined;
        message.modNote = object.modNote ?? undefined;
        message.modReasonBy = object.modReasonBy ?? undefined;
        message.modReasonTitle = object.modReasonTitle ?? undefined;
        message.modReports = object.modReports?.map((e) => e) || [];
        message.name = object.name ?? undefined;
        message.noFollow = object.noFollow ?? undefined;
        message.numComments = object.numComments ?? undefined;
        message.numCrossposts = object.numCrossposts ?? undefined;
        message.numDuplicates = object.numDuplicates ?? undefined;
        message.numReports = object.numReports ?? undefined;
        message.over18 = object.over18 ?? undefined;
        message.parentWhitelistStatus = object.parentWhitelistStatus ?? undefined;
        message.permalink = object.permalink ?? undefined;
        message.pinned = object.pinned ?? undefined;
        message.postHint = object.postHint ?? undefined;
        message.preview = (object.preview !== undefined && object.preview !== null)
            ? Preview.fromPartial(object.preview)
            : undefined;
        message.pwls = object.pwls ?? undefined;
        message.quarantine = object.quarantine ?? undefined;
        message.removalReason = object.removalReason ?? undefined;
        message.removedByCategory = object.removedByCategory ?? undefined;
        message.removedBy = object.removedBy ?? undefined;
        message.removed = object.removed ?? undefined;
        message.reportReasons = object.reportReasons?.map((e) => e) || [];
        message.rteMode = object.rteMode ?? undefined;
        message.saved = object.saved ?? undefined;
        message.score = object.score ?? undefined;
        message.secureMediaEmbed = (object.secureMediaEmbed !== undefined && object.secureMediaEmbed !== null)
            ? MediaEmbed.fromPartial(object.secureMediaEmbed)
            : undefined;
        message.secureMedia = (object.secureMedia !== undefined && object.secureMedia !== null)
            ? Media.fromPartial(object.secureMedia)
            : undefined;
        message.selftextHtml = object.selftextHtml ?? undefined;
        message.selftext = object.selftext ?? undefined;
        message.sendReplies = object.sendReplies ?? undefined;
        message.spam = object.spam ?? undefined;
        message.spoiler = object.spoiler ?? undefined;
        message.stickied = object.stickied ?? undefined;
        message.subredditId = object.subredditId ?? undefined;
        message.subredditNamePrefixed = object.subredditNamePrefixed ?? undefined;
        message.subredditSubscribers = object.subredditSubscribers ?? undefined;
        message.subredditType = object.subredditType ?? undefined;
        message.subreddit = object.subreddit ?? undefined;
        message.suggestedSort = object.suggestedSort ?? undefined;
        message.thumbnailHeight = object.thumbnailHeight ?? undefined;
        message.thumbnailWidth = object.thumbnailWidth ?? undefined;
        message.thumbnail = object.thumbnail ?? undefined;
        message.title = object.title ?? undefined;
        message.topAwardedType = object.topAwardedType ?? undefined;
        message.totalAwardsReceived = object.totalAwardsReceived ?? undefined;
        message.treatmentTags = object.treatmentTags?.map((e) => e) || [];
        message.ups = object.ups ?? undefined;
        message.upvoteRatio = object.upvoteRatio ?? undefined;
        message.urlOverriddenByDest = object.urlOverriddenByDest ?? undefined;
        message.url = object.url ?? undefined;
        message.userReports = object.userReports?.map((e) => e) || [];
        message.viewCount = object.viewCount ?? undefined;
        message.visited = object.visited ?? undefined;
        message.whitelistStatus = object.whitelistStatus ?? undefined;
        message.wls = object.wls ?? undefined;
        message.linkFlairTemplateId = object.linkFlairTemplateId ?? undefined;
        message.crowdControlLevel = object.crowdControlLevel ?? undefined;
        message.isGallery = object.isGallery ?? undefined;
        message.isLiveStream = object.isLiveStream ?? undefined;
        message.isMetaDiscussion = object.isMetaDiscussion ?? undefined;
        message.oembed = (object.oembed !== undefined && object.oembed !== null)
            ? OEmbed.fromPartial(object.oembed)
            : undefined;
        message.banInfo = (object.banInfo !== undefined && object.banInfo !== null)
            ? BanInfo.fromPartial(object.banInfo)
            : undefined;
        message.markedSpam = object.markedSpam ?? undefined;
        message.verdict = object.verdict ?? undefined;
        message.gallery = (object.gallery !== undefined && object.gallery !== null)
            ? RedditPostGallery.fromPartial(object.gallery)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(Post.$type, Post);
function createBaseMedia() {
    return { redditVideo: undefined };
}
export const Media = {
    $type: "devvit.reddit.Media",
    encode(message, writer = _m0.Writer.create()) {
        if (message.redditVideo !== undefined) {
            Media_RedditVideo.encode(message.redditVideo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMedia();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.redditVideo = Media_RedditVideo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { redditVideo: isSet(object.redditVideo) ? Media_RedditVideo.fromJSON(object.redditVideo) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.redditVideo !== undefined) {
            obj.redditVideo = Media_RedditVideo.toJSON(message.redditVideo);
        }
        return obj;
    },
    create(base) {
        return Media.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMedia();
        message.redditVideo = (object.redditVideo !== undefined && object.redditVideo !== null)
            ? Media_RedditVideo.fromPartial(object.redditVideo)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(Media.$type, Media);
function createBaseMedia_RedditVideo() {
    return {
        bitrateKbps: undefined,
        dashUrl: undefined,
        duration: undefined,
        fallbackUrl: undefined,
        height: undefined,
        hlsUrl: undefined,
        isGif: undefined,
        scrubberMediaUrl: undefined,
        transcodingStatus: undefined,
        width: undefined,
    };
}
export const Media_RedditVideo = {
    $type: "devvit.reddit.Media.RedditVideo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.bitrateKbps !== undefined) {
            Int32Value.encode({ value: message.bitrateKbps }, writer.uint32(10).fork()).ldelim();
        }
        if (message.dashUrl !== undefined) {
            StringValue.encode({ value: message.dashUrl }, writer.uint32(18).fork()).ldelim();
        }
        if (message.duration !== undefined) {
            Int32Value.encode({ value: message.duration }, writer.uint32(26).fork()).ldelim();
        }
        if (message.fallbackUrl !== undefined) {
            StringValue.encode({ value: message.fallbackUrl }, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(42).fork()).ldelim();
        }
        if (message.hlsUrl !== undefined) {
            StringValue.encode({ value: message.hlsUrl }, writer.uint32(50).fork()).ldelim();
        }
        if (message.isGif !== undefined) {
            BoolValue.encode({ value: message.isGif }, writer.uint32(58).fork()).ldelim();
        }
        if (message.scrubberMediaUrl !== undefined) {
            StringValue.encode({ value: message.scrubberMediaUrl }, writer.uint32(66).fork()).ldelim();
        }
        if (message.transcodingStatus !== undefined) {
            StringValue.encode({ value: message.transcodingStatus }, writer.uint32(74).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMedia_RedditVideo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bitrateKbps = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.dashUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.duration = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fallbackUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.hlsUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.isGif = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.scrubberMediaUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.transcodingStatus = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bitrateKbps: isSet(object.bitrateKbps) ? Number(object.bitrateKbps) : undefined,
            dashUrl: isSet(object.dashUrl) ? String(object.dashUrl) : undefined,
            duration: isSet(object.duration) ? Number(object.duration) : undefined,
            fallbackUrl: isSet(object.fallbackUrl) ? String(object.fallbackUrl) : undefined,
            height: isSet(object.height) ? Number(object.height) : undefined,
            hlsUrl: isSet(object.hlsUrl) ? String(object.hlsUrl) : undefined,
            isGif: isSet(object.isGif) ? Boolean(object.isGif) : undefined,
            scrubberMediaUrl: isSet(object.scrubberMediaUrl) ? String(object.scrubberMediaUrl) : undefined,
            transcodingStatus: isSet(object.transcodingStatus) ? String(object.transcodingStatus) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bitrateKbps !== undefined) {
            obj.bitrateKbps = message.bitrateKbps;
        }
        if (message.dashUrl !== undefined) {
            obj.dashUrl = message.dashUrl;
        }
        if (message.duration !== undefined) {
            obj.duration = message.duration;
        }
        if (message.fallbackUrl !== undefined) {
            obj.fallbackUrl = message.fallbackUrl;
        }
        if (message.height !== undefined) {
            obj.height = message.height;
        }
        if (message.hlsUrl !== undefined) {
            obj.hlsUrl = message.hlsUrl;
        }
        if (message.isGif !== undefined) {
            obj.isGif = message.isGif;
        }
        if (message.scrubberMediaUrl !== undefined) {
            obj.scrubberMediaUrl = message.scrubberMediaUrl;
        }
        if (message.transcodingStatus !== undefined) {
            obj.transcodingStatus = message.transcodingStatus;
        }
        if (message.width !== undefined) {
            obj.width = message.width;
        }
        return obj;
    },
    create(base) {
        return Media_RedditVideo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMedia_RedditVideo();
        message.bitrateKbps = object.bitrateKbps ?? undefined;
        message.dashUrl = object.dashUrl ?? undefined;
        message.duration = object.duration ?? undefined;
        message.fallbackUrl = object.fallbackUrl ?? undefined;
        message.height = object.height ?? undefined;
        message.hlsUrl = object.hlsUrl ?? undefined;
        message.isGif = object.isGif ?? undefined;
        message.scrubberMediaUrl = object.scrubberMediaUrl ?? undefined;
        message.transcodingStatus = object.transcodingStatus ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Media_RedditVideo.$type, Media_RedditVideo);
function createBasePreview() {
    return { enabled: undefined, images: [] };
}
export const Preview = {
    $type: "devvit.reddit.Preview",
    encode(message, writer = _m0.Writer.create()) {
        if (message.enabled !== undefined) {
            BoolValue.encode({ value: message.enabled }, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.images) {
            Preview_PreviewImage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreview();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.enabled = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.images.push(Preview_PreviewImage.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
            images: globalThis.Array.isArray(object?.images)
                ? object.images.map((e) => Preview_PreviewImage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.enabled !== undefined) {
            obj.enabled = message.enabled;
        }
        if (message.images?.length) {
            obj.images = message.images.map((e) => Preview_PreviewImage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Preview.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreview();
        message.enabled = object.enabled ?? undefined;
        message.images = object.images?.map((e) => Preview_PreviewImage.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(Preview.$type, Preview);
function createBasePreview_PreviewImage() {
    return { id: undefined, resolutions: [], source: undefined, variants: undefined };
}
export const Preview_PreviewImage = {
    $type: "devvit.reddit.Preview.PreviewImage",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== undefined) {
            StringValue.encode({ value: message.id }, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.resolutions) {
            Preview_PreviewImage_Image.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.source !== undefined) {
            Preview_PreviewImage_Image.encode(message.source, writer.uint32(26).fork()).ldelim();
        }
        if (message.variants !== undefined) {
            Preview_PreviewImage_Image.encode(message.variants, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreview_PreviewImage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.resolutions.push(Preview_PreviewImage_Image.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.source = Preview_PreviewImage_Image.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.variants = Preview_PreviewImage_Image.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : undefined,
            resolutions: globalThis.Array.isArray(object?.resolutions)
                ? object.resolutions.map((e) => Preview_PreviewImage_Image.fromJSON(e))
                : [],
            source: isSet(object.source) ? Preview_PreviewImage_Image.fromJSON(object.source) : undefined,
            variants: isSet(object.variants) ? Preview_PreviewImage_Image.fromJSON(object.variants) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.resolutions?.length) {
            obj.resolutions = message.resolutions.map((e) => Preview_PreviewImage_Image.toJSON(e));
        }
        if (message.source !== undefined) {
            obj.source = Preview_PreviewImage_Image.toJSON(message.source);
        }
        if (message.variants !== undefined) {
            obj.variants = Preview_PreviewImage_Image.toJSON(message.variants);
        }
        return obj;
    },
    create(base) {
        return Preview_PreviewImage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreview_PreviewImage();
        message.id = object.id ?? undefined;
        message.resolutions = object.resolutions?.map((e) => Preview_PreviewImage_Image.fromPartial(e)) || [];
        message.source = (object.source !== undefined && object.source !== null)
            ? Preview_PreviewImage_Image.fromPartial(object.source)
            : undefined;
        message.variants = (object.variants !== undefined && object.variants !== null)
            ? Preview_PreviewImage_Image.fromPartial(object.variants)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(Preview_PreviewImage.$type, Preview_PreviewImage);
function createBasePreview_PreviewImage_Image() {
    return { height: undefined, url: undefined, width: undefined };
}
export const Preview_PreviewImage_Image = {
    $type: "devvit.reddit.Preview.PreviewImage.Image",
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== undefined) {
            Int32Value.encode({ value: message.height }, writer.uint32(10).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(18).fork()).ldelim();
        }
        if (message.width !== undefined) {
            Int32Value.encode({ value: message.width }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreview_PreviewImage_Image();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.height = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.width = Int32Value.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet(object.height) ? Number(object.height) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
            width: isSet(object.width) ? Number(object.width) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== undefined) {
            obj.height = message.height;
        }
        if (message.url !== undefined) {
            obj.url = message.url;
        }
        if (message.width !== undefined) {
            obj.width = message.width;
        }
        return obj;
    },
    create(base) {
        return Preview_PreviewImage_Image.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreview_PreviewImage_Image();
        message.height = object.height ?? undefined;
        message.url = object.url ?? undefined;
        message.width = object.width ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(Preview_PreviewImage_Image.$type, Preview_PreviewImage_Image);
function createBaseOEmbed() {
    return { authorName: undefined, authorUrl: undefined, description: undefined, title: undefined };
}
export const OEmbed = {
    $type: "devvit.reddit.OEmbed",
    encode(message, writer = _m0.Writer.create()) {
        if (message.authorName !== undefined) {
            StringValue.encode({ value: message.authorName }, writer.uint32(10).fork()).ldelim();
        }
        if (message.authorUrl !== undefined) {
            StringValue.encode({ value: message.authorUrl }, writer.uint32(18).fork()).ldelim();
        }
        if (message.description !== undefined) {
            StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();
        }
        if (message.title !== undefined) {
            StringValue.encode({ value: message.title }, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOEmbed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.authorName = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.authorUrl = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.description = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.title = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            authorName: isSet(object.authorName) ? String(object.authorName) : undefined,
            authorUrl: isSet(object.authorUrl) ? String(object.authorUrl) : undefined,
            description: isSet(object.description) ? String(object.description) : undefined,
            title: isSet(object.title) ? String(object.title) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.authorName !== undefined) {
            obj.authorName = message.authorName;
        }
        if (message.authorUrl !== undefined) {
            obj.authorUrl = message.authorUrl;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.title !== undefined) {
            obj.title = message.title;
        }
        return obj;
    },
    create(base) {
        return OEmbed.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOEmbed();
        message.authorName = object.authorName ?? undefined;
        message.authorUrl = object.authorUrl ?? undefined;
        message.description = object.description ?? undefined;
        message.title = object.title ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(OEmbed.$type, OEmbed);
function createBaseRedditPostGallery() {
    return { body: undefined, domain: undefined, url: undefined };
}
export const RedditPostGallery = {
    $type: "devvit.reddit.RedditPostGallery",
    encode(message, writer = _m0.Writer.create()) {
        if (message.body !== undefined) {
            StringValue.encode({ value: message.body }, writer.uint32(10).fork()).ldelim();
        }
        if (message.domain !== undefined) {
            StringValue.encode({ value: message.domain }, writer.uint32(18).fork()).ldelim();
        }
        if (message.url !== undefined) {
            StringValue.encode({ value: message.url }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedditPostGallery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.body = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.domain = StringValue.decode(reader, reader.uint32()).value;
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.url = StringValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            body: isSet(object.body) ? String(object.body) : undefined,
            domain: isSet(object.domain) ? String(object.domain) : undefined,
            url: isSet(object.url) ? String(object.url) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.body !== undefined) {
            obj.body = message.body;
        }
        if (message.domain !== undefined) {
            obj.domain = message.domain;
        }
        if (message.url !== undefined) {
            obj.url = message.url;
        }
        return obj;
    },
    create(base) {
        return RedditPostGallery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedditPostGallery();
        message.body = object.body ?? undefined;
        message.domain = object.domain ?? undefined;
        message.url = object.url ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(RedditPostGallery.$type, RedditPostGallery);
function isSet(value) {
    return value !== null && value !== undefined;
}
