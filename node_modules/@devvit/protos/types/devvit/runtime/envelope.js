/**
 * #envelope.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Value } from "../../google/protobuf/struct.js";
import { messageTypeRegistry } from "../../typeRegistry.js";
import { Strings } from "./runtime_common.js";
function createBaseEnvelope() {
    return {
        id: "",
        src: "",
        dst: "",
        method: "",
        streamId: "",
        traceId: "",
        success: false,
        message: undefined,
        request: false,
        complete: false,
        metadata: {},
    };
}
export const Envelope = {
    $type: "devvit.runtime.Envelope",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(90).string(message.id);
        }
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.dst !== "") {
            writer.uint32(18).string(message.dst);
        }
        if (message.method !== "") {
            writer.uint32(26).string(message.method);
        }
        if (message.streamId !== "") {
            writer.uint32(34).string(message.streamId);
        }
        if (message.traceId !== "") {
            writer.uint32(82).string(message.traceId);
        }
        if (message.success !== false) {
            writer.uint32(40).bool(message.success);
        }
        if (message.message !== undefined) {
            Value.encode(Value.wrap(message.message), writer.uint32(50).fork()).ldelim();
        }
        if (message.request !== false) {
            writer.uint32(56).bool(message.request);
        }
        if (message.complete !== false) {
            writer.uint32(64).bool(message.complete);
        }
        Object.entries(message.metadata).forEach(([key, value]) => {
            Envelope_MetadataEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnvelope();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.src = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.dst = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.method = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.streamId = reader.string();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.traceId = reader.string();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.message = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.request = reader.bool();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.complete = reader.bool();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    const entry9 = Envelope_MetadataEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.metadata[entry9.key] = entry9.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            src: isSet(object.src) ? globalThis.String(object.src) : "",
            dst: isSet(object.dst) ? globalThis.String(object.dst) : "",
            method: isSet(object.method) ? globalThis.String(object.method) : "",
            streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
            traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            message: isSet(object?.message) ? object.message : undefined,
            request: isSet(object.request) ? globalThis.Boolean(object.request) : false,
            complete: isSet(object.complete) ? globalThis.Boolean(object.complete) : false,
            metadata: isObject(object.metadata)
                ? Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = Strings.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.src !== "") {
            obj.src = message.src;
        }
        if (message.dst !== "") {
            obj.dst = message.dst;
        }
        if (message.method !== "") {
            obj.method = message.method;
        }
        if (message.streamId !== "") {
            obj.streamId = message.streamId;
        }
        if (message.traceId !== "") {
            obj.traceId = message.traceId;
        }
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        if (message.request !== false) {
            obj.request = message.request;
        }
        if (message.complete !== false) {
            obj.complete = message.complete;
        }
        if (message.metadata) {
            const entries = Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = Strings.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return Envelope.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEnvelope();
        message.id = object.id ?? "";
        message.src = object.src ?? "";
        message.dst = object.dst ?? "";
        message.method = object.method ?? "";
        message.streamId = object.streamId ?? "";
        message.traceId = object.traceId ?? "";
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        message.request = object.request ?? false;
        message.complete = object.complete ?? false;
        message.metadata = Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Strings.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(Envelope.$type, Envelope);
function createBaseEnvelope_MetadataEntry() {
    return { key: "", value: undefined };
}
export const Envelope_MetadataEntry = {
    $type: "devvit.runtime.Envelope.MetadataEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Strings.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnvelope_MetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Strings.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? Strings.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = Strings.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return Envelope_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEnvelope_MetadataEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Strings.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(Envelope_MetadataEntry.$type, Envelope_MetadataEntry);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
