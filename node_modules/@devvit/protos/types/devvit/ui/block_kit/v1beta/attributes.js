/**
 * #attributes.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Struct } from "../../../../google/protobuf/struct.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
import { blockActionTypeFromJSON, blockActionTypeToJSON, blockBorderWidthFromJSON, blockBorderWidthToJSON, blockHorizontalAlignmentFromJSON, blockHorizontalAlignmentToJSON, blockSizeUnitFromJSON, blockSizeUnitToJSON, blockVerticalAlignmentFromJSON, blockVerticalAlignmentToJSON, } from "./enums.js";
function createBaseBlockAlignment() {
    return { vertical: undefined, horizontal: undefined };
}
export const BlockAlignment = {
    $type: "devvit.ui.block_kit.v1beta.BlockAlignment",
    encode(message, writer = _m0.Writer.create()) {
        if (message.vertical !== undefined) {
            writer.uint32(8).int32(message.vertical);
        }
        if (message.horizontal !== undefined) {
            writer.uint32(16).int32(message.horizontal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAlignment();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.vertical = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.horizontal = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            vertical: isSet(object.vertical) ? blockVerticalAlignmentFromJSON(object.vertical) : undefined,
            horizontal: isSet(object.horizontal) ? blockHorizontalAlignmentFromJSON(object.horizontal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.vertical !== undefined) {
            obj.vertical = blockVerticalAlignmentToJSON(message.vertical);
        }
        if (message.horizontal !== undefined) {
            obj.horizontal = blockHorizontalAlignmentToJSON(message.horizontal);
        }
        return obj;
    },
    create(base) {
        return BlockAlignment.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockAlignment();
        message.vertical = object.vertical ?? undefined;
        message.horizontal = object.horizontal ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockAlignment.$type, BlockAlignment);
function createBaseBlockBorder() {
    return { color: undefined, width: undefined, colors: undefined };
}
export const BlockBorder = {
    $type: "devvit.ui.block_kit.v1beta.BlockBorder",
    encode(message, writer = _m0.Writer.create()) {
        if (message.color !== undefined) {
            writer.uint32(10).string(message.color);
        }
        if (message.width !== undefined) {
            writer.uint32(16).int32(message.width);
        }
        if (message.colors !== undefined) {
            BlockColor.encode(message.colors, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockBorder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.color = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.width = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.colors = BlockColor.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            color: isSet(object.color) ? globalThis.String(object.color) : undefined,
            width: isSet(object.width) ? blockBorderWidthFromJSON(object.width) : undefined,
            colors: isSet(object.colors) ? BlockColor.fromJSON(object.colors) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.color !== undefined) {
            obj.color = message.color;
        }
        if (message.width !== undefined) {
            obj.width = blockBorderWidthToJSON(message.width);
        }
        if (message.colors !== undefined) {
            obj.colors = BlockColor.toJSON(message.colors);
        }
        return obj;
    },
    create(base) {
        return BlockBorder.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockBorder();
        message.color = object.color ?? undefined;
        message.width = object.width ?? undefined;
        message.colors = (object.colors !== undefined && object.colors !== null)
            ? BlockColor.fromPartial(object.colors)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockBorder.$type, BlockBorder);
function createBaseBlockSizes() {
    return { grow: undefined, width: undefined, height: undefined };
}
export const BlockSizes = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes",
    encode(message, writer = _m0.Writer.create()) {
        if (message.grow !== undefined) {
            writer.uint32(8).bool(message.grow);
        }
        if (message.width !== undefined) {
            BlockSizes_Dimension.encode(message.width, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== undefined) {
            BlockSizes_Dimension.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.grow = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.width = BlockSizes_Dimension.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.height = BlockSizes_Dimension.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            grow: isSet(object.grow) ? globalThis.Boolean(object.grow) : undefined,
            width: isSet(object.width) ? BlockSizes_Dimension.fromJSON(object.width) : undefined,
            height: isSet(object.height) ? BlockSizes_Dimension.fromJSON(object.height) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.grow !== undefined) {
            obj.grow = message.grow;
        }
        if (message.width !== undefined) {
            obj.width = BlockSizes_Dimension.toJSON(message.width);
        }
        if (message.height !== undefined) {
            obj.height = BlockSizes_Dimension.toJSON(message.height);
        }
        return obj;
    },
    create(base) {
        return BlockSizes.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockSizes();
        message.grow = object.grow ?? undefined;
        message.width = (object.width !== undefined && object.width !== null)
            ? BlockSizes_Dimension.fromPartial(object.width)
            : undefined;
        message.height = (object.height !== undefined && object.height !== null)
            ? BlockSizes_Dimension.fromPartial(object.height)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockSizes.$type, BlockSizes);
function createBaseBlockSizes_Dimension() {
    return { value: undefined, min: undefined, max: undefined };
}
export const BlockSizes_Dimension = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== undefined) {
            BlockSizes_Dimension_Value.encode(message.value, writer.uint32(10).fork()).ldelim();
        }
        if (message.min !== undefined) {
            BlockSizes_Dimension_Value.encode(message.min, writer.uint32(18).fork()).ldelim();
        }
        if (message.max !== undefined) {
            BlockSizes_Dimension_Value.encode(message.max, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes_Dimension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.value = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.min = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.max = BlockSizes_Dimension_Value.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? BlockSizes_Dimension_Value.fromJSON(object.value) : undefined,
            min: isSet(object.min) ? BlockSizes_Dimension_Value.fromJSON(object.min) : undefined,
            max: isSet(object.max) ? BlockSizes_Dimension_Value.fromJSON(object.max) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== undefined) {
            obj.value = BlockSizes_Dimension_Value.toJSON(message.value);
        }
        if (message.min !== undefined) {
            obj.min = BlockSizes_Dimension_Value.toJSON(message.min);
        }
        if (message.max !== undefined) {
            obj.max = BlockSizes_Dimension_Value.toJSON(message.max);
        }
        return obj;
    },
    create(base) {
        return BlockSizes_Dimension.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockSizes_Dimension();
        message.value = (object.value !== undefined && object.value !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.value)
            : undefined;
        message.min = (object.min !== undefined && object.min !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.min)
            : undefined;
        message.max = (object.max !== undefined && object.max !== null)
            ? BlockSizes_Dimension_Value.fromPartial(object.max)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockSizes_Dimension.$type, BlockSizes_Dimension);
function createBaseBlockSizes_Dimension_Value() {
    return { value: 0, unit: 0 };
}
export const BlockSizes_Dimension_Value = {
    $type: "devvit.ui.block_kit.v1beta.BlockSizes.Dimension.Value",
    encode(message, writer = _m0.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(13).float(message.value);
        }
        if (message.unit !== 0) {
            writer.uint32(16).int32(message.unit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSizes_Dimension_Value();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.value = reader.float();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.unit = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
            unit: isSet(object.unit) ? blockSizeUnitFromJSON(object.unit) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== 0) {
            obj.value = message.value;
        }
        if (message.unit !== 0) {
            obj.unit = blockSizeUnitToJSON(message.unit);
        }
        return obj;
    },
    create(base) {
        return BlockSizes_Dimension_Value.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockSizes_Dimension_Value();
        message.value = object.value ?? 0;
        message.unit = object.unit ?? 0;
        return message;
    },
};
messageTypeRegistry.set(BlockSizes_Dimension_Value.$type, BlockSizes_Dimension_Value);
function createBaseBlockSize() {
    return { grow: undefined, width: undefined, widthUnit: undefined, height: undefined, heightUnit: undefined };
}
export const BlockSize = {
    $type: "devvit.ui.block_kit.v1beta.BlockSize",
    encode(message, writer = _m0.Writer.create()) {
        if (message.grow !== undefined) {
            writer.uint32(8).bool(message.grow);
        }
        if (message.width !== undefined) {
            writer.uint32(21).float(message.width);
        }
        if (message.widthUnit !== undefined) {
            writer.uint32(32).int32(message.widthUnit);
        }
        if (message.height !== undefined) {
            writer.uint32(29).float(message.height);
        }
        if (message.heightUnit !== undefined) {
            writer.uint32(40).int32(message.heightUnit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockSize();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.grow = reader.bool();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.width = reader.float();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.widthUnit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.height = reader.float();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.heightUnit = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            grow: isSet(object.grow) ? globalThis.Boolean(object.grow) : undefined,
            width: isSet(object.width) ? globalThis.Number(object.width) : undefined,
            widthUnit: isSet(object.widthUnit) ? blockSizeUnitFromJSON(object.widthUnit) : undefined,
            height: isSet(object.height) ? globalThis.Number(object.height) : undefined,
            heightUnit: isSet(object.heightUnit) ? blockSizeUnitFromJSON(object.heightUnit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.grow !== undefined) {
            obj.grow = message.grow;
        }
        if (message.width !== undefined) {
            obj.width = message.width;
        }
        if (message.widthUnit !== undefined) {
            obj.widthUnit = blockSizeUnitToJSON(message.widthUnit);
        }
        if (message.height !== undefined) {
            obj.height = message.height;
        }
        if (message.heightUnit !== undefined) {
            obj.heightUnit = blockSizeUnitToJSON(message.heightUnit);
        }
        return obj;
    },
    create(base) {
        return BlockSize.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockSize();
        message.grow = object.grow ?? undefined;
        message.width = object.width ?? undefined;
        message.widthUnit = object.widthUnit ?? undefined;
        message.height = object.height ?? undefined;
        message.heightUnit = object.heightUnit ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockSize.$type, BlockSize);
function createBaseBlockAction() {
    return { type: 0, id: "", data: undefined };
}
export const BlockAction = {
    $type: "devvit.ui.block_kit.v1beta.BlockAction",
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.data !== undefined) {
            Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? blockActionTypeFromJSON(object.type) : 0,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            data: isObject(object.data) ? object.data : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = blockActionTypeToJSON(message.type);
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.data !== undefined) {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return BlockAction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockAction();
        message.type = object.type ?? 0;
        message.id = object.id ?? "";
        message.data = object.data ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockAction.$type, BlockAction);
function createBaseBlockColor() {
    return { light: undefined, dark: undefined };
}
export const BlockColor = {
    $type: "devvit.ui.block_kit.v1beta.BlockColor",
    encode(message, writer = _m0.Writer.create()) {
        if (message.light !== undefined) {
            writer.uint32(10).string(message.light);
        }
        if (message.dark !== undefined) {
            writer.uint32(18).string(message.dark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockColor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.light = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.dark = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            light: isSet(object.light) ? globalThis.String(object.light) : undefined,
            dark: isSet(object.dark) ? globalThis.String(object.dark) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.light !== undefined) {
            obj.light = message.light;
        }
        if (message.dark !== undefined) {
            obj.dark = message.dark;
        }
        return obj;
    },
    create(base) {
        return BlockColor.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockColor();
        message.light = object.light ?? undefined;
        message.dark = object.dark ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(BlockColor.$type, BlockColor);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
