/**
 * #ui.ts
 *
 * @packageDocumentation
 */
import _m0 from "protobufjs/minimal.js";
import { UIDimensions } from "../../common/v1alpha/common.js";
import { Effect } from "../../effects/v1alpha/effect.js";
import { UIEvent } from "../../events/v1alpha/event.js";
import { Block } from "./block.js";
/**
 * This file encodes a generic protocol for rendering UIs.  If you want to embed a UI into Devvit, you should use this protocol.
 * This protobuf is for the second iteration of Blocks components.  It's an extraction of CustomPost to work with any UI surface.
 *
 * The idea is that if you want to add a new surface, you can add an rpc method that takes a RenderUIRequest and returns a RenderUIResponse.
 * This RPC method will encompass the full lifecycle of the UI.  It will be called when the UI is first rendered, and it will be called again
 * when the user or system interacts with the UI via UIEvents.
 *
 * Example:
 *
 *    service MyService {
 *      rpc MyNewSidebarUI(UIRequest) returns (UIResponse) {};
 *    }
 *
 * There are some optimizations encoded in the protocol.  For example, if you just want a pure render, you can send a UIRequest with no events.  This
 * will return a UIResponse with no effects and no new state.  Conversely, if you want to update state, but not render anything, you can send a UIRequest
 * with no_render set to true.  This will return a UIResponse with effects and state updates but no new UI.
 *
 * The common case, however, is to send a UIRequest with events and no_render set to false.  This will perform the state updates, do a render, then return
 * a UIResponse with a new UI, new state, and effects, and saving the multiple round-trips.
 */
export interface UIRequest {
    /**
     * This is universally available to all UIs.  It's a place to put environment-specific data.
     * Typical items are e.g. locale, dark mode, etc.  Please don't put surface-specific data here.
     * (i.e. *NOT* post_id, that should be in the props.  *NOT* user_id, that should be in the state.)
     */
    env?: UIEnvironment | undefined;
    /** Props to the root component of this UI. */
    props?: {
        [key: string]: any;
    } | undefined;
    /** Stateful data received from a previous response */
    state?: {
        [key: string]: any;
    } | undefined;
    /**
     * This is a "repeated" so we can consider adding event batching (e.g. multiple key presses).  For
     * now, This is zero or one events. If you just want to render a UI, you can send an empty list.
     */
    events: UIEvent[];
}
export interface UIResponse {
    /**
     * Stateful data to be sent back. Event responses only contain state deltas to
     * allow the requester to aggregate and reconcile local and remote state. This
     * will be sent back to you in the next request.
     *
     * Note that the deltas also may include "tombstones" which must be used to delete
     * keys from the state.  This is useful for cleaning up state that is no longer needed.
     */
    state?: {
        [key: string]: any;
    } | undefined;
    /** Optional list of Effects to execute on the client */
    effects: Effect[];
    /** Optional list of Events that will re-enter the dispatcher queue */
    events: UIEvent[];
    /** Render the post with Blocks */
    blocks?: Block | undefined;
}
/**
 * This is universally available to all UIs.  It's a place to put environment-specific data.
 * Typical items are e.g. locale, dark mode, etc.  Please don't put surface-specific data here.
 * (i.e. *NOT* post_id, that should be in the props.  *NOT* user_id, that should be in the state.)
 */
export interface UIEnvironment {
    /** The locale of the user.  This is a string like "en-US" or "fr-CA" */
    locale?: string | undefined;
    /** The user's preferred color scheme.  This is a string like "light" or "dark" */
    colorScheme?: string | undefined;
    /** The layout size of the post */
    dimensions?: UIDimensions | undefined;
    /** The timezone of the user */
    timezone?: string | undefined;
}
export declare const UIRequest: {
    $type: "devvit.ui.block_kit.v1beta.UIRequest";
    encode(message: UIRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIRequest;
    fromJSON(object: any): UIRequest;
    toJSON(message: UIRequest): unknown;
    create(base?: DeepPartial<UIRequest>): UIRequest;
    fromPartial(object: DeepPartial<UIRequest>): UIRequest;
};
export declare const UIResponse: {
    $type: "devvit.ui.block_kit.v1beta.UIResponse";
    encode(message: UIResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIResponse;
    fromJSON(object: any): UIResponse;
    toJSON(message: UIResponse): unknown;
    create(base?: DeepPartial<UIResponse>): UIResponse;
    fromPartial(object: DeepPartial<UIResponse>): UIResponse;
};
export declare const UIEnvironment: {
    $type: "devvit.ui.block_kit.v1beta.UIEnvironment";
    encode(message: UIEnvironment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIEnvironment;
    fromJSON(object: any): UIEnvironment;
    toJSON(message: UIEnvironment): unknown;
    create(base?: DeepPartial<UIEnvironment>): UIEnvironment;
    fromPartial(object: DeepPartial<UIEnvironment>): UIEnvironment;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=ui.d.ts.map