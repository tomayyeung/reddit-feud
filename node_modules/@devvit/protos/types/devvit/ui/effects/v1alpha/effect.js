/**
 * #effect.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
import { WebViewEffect } from "../web_view/v1alpha/web_view.js";
import { CreateOrderEffect } from "./create_order.js";
import { SetIntervalsEffect } from "./interval.js";
import { NavigateToUrlEffect } from "./navigate_to_url.js";
import { RealtimeSubscriptionsEffect } from "./realtime_subscriptions.js";
import { ReloadPartEffect } from "./reload_part.js";
import { RerenderEffect } from "./rerender_ui.js";
import { ShowFormEffect } from "./show_form.js";
import { ShowToastEffect } from "./show_toast.js";
export var EffectType;
(function (EffectType) {
    /** EFFECT_REALTIME_SUB - Notify client to synchronize its realtime subscriptions */
    EffectType[EffectType["EFFECT_REALTIME_SUB"] = 0] = "EFFECT_REALTIME_SUB";
    /** EFFECT_RERENDER_UI - Trigger a re-render for apps that have visible UI */
    EffectType[EffectType["EFFECT_RERENDER_UI"] = 1] = "EFFECT_RERENDER_UI";
    /** EFFECT_RELOAD_PART - Notify the client that parts of a subreddit, post, or comment should be reloaded */
    EffectType[EffectType["EFFECT_RELOAD_PART"] = 2] = "EFFECT_RELOAD_PART";
    /** EFFECT_SHOW_FORM - Display a user input form */
    EffectType[EffectType["EFFECT_SHOW_FORM"] = 3] = "EFFECT_SHOW_FORM";
    /** EFFECT_SHOW_TOAST - Display a transient toast message */
    EffectType[EffectType["EFFECT_SHOW_TOAST"] = 4] = "EFFECT_SHOW_TOAST";
    /** EFFECT_NAVIGATE_TO_URL - Notify the client to navigate to a URL */
    EffectType[EffectType["EFFECT_NAVIGATE_TO_URL"] = 5] = "EFFECT_NAVIGATE_TO_URL";
    /** EFFECT_SET_INTERVALS - This updates the list of active timers. */
    EffectType[EffectType["EFFECT_SET_INTERVALS"] = 7] = "EFFECT_SET_INTERVALS";
    /** EFFECT_CREATE_ORDER - This starts a purchase flow */
    EffectType[EffectType["EFFECT_CREATE_ORDER"] = 8] = "EFFECT_CREATE_ORDER";
    /** EFFECT_WEB_VIEW - Control and communicate with WebViews */
    EffectType[EffectType["EFFECT_WEB_VIEW"] = 9] = "EFFECT_WEB_VIEW";
    EffectType[EffectType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EffectType || (EffectType = {}));
export function effectTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "EFFECT_REALTIME_SUB":
            return EffectType.EFFECT_REALTIME_SUB;
        case 1:
        case "EFFECT_RERENDER_UI":
            return EffectType.EFFECT_RERENDER_UI;
        case 2:
        case "EFFECT_RELOAD_PART":
            return EffectType.EFFECT_RELOAD_PART;
        case 3:
        case "EFFECT_SHOW_FORM":
            return EffectType.EFFECT_SHOW_FORM;
        case 4:
        case "EFFECT_SHOW_TOAST":
            return EffectType.EFFECT_SHOW_TOAST;
        case 5:
        case "EFFECT_NAVIGATE_TO_URL":
            return EffectType.EFFECT_NAVIGATE_TO_URL;
        case 7:
        case "EFFECT_SET_INTERVALS":
            return EffectType.EFFECT_SET_INTERVALS;
        case 8:
        case "EFFECT_CREATE_ORDER":
            return EffectType.EFFECT_CREATE_ORDER;
        case 9:
        case "EFFECT_WEB_VIEW":
            return EffectType.EFFECT_WEB_VIEW;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EffectType.UNRECOGNIZED;
    }
}
export function effectTypeToJSON(object) {
    switch (object) {
        case EffectType.EFFECT_REALTIME_SUB:
            return 0;
        case EffectType.EFFECT_RERENDER_UI:
            return 1;
        case EffectType.EFFECT_RELOAD_PART:
            return 2;
        case EffectType.EFFECT_SHOW_FORM:
            return 3;
        case EffectType.EFFECT_SHOW_TOAST:
            return 4;
        case EffectType.EFFECT_NAVIGATE_TO_URL:
            return 5;
        case EffectType.EFFECT_SET_INTERVALS:
            return 7;
        case EffectType.EFFECT_CREATE_ORDER:
            return 8;
        case EffectType.EFFECT_WEB_VIEW:
            return 9;
        case EffectType.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseEffect() {
    return {
        realtimeSubscriptions: undefined,
        rerenderUi: undefined,
        reloadPart: undefined,
        showForm: undefined,
        showToast: undefined,
        navigateToUrl: undefined,
        interval: undefined,
        createOrder: undefined,
        webView: undefined,
        type: 0,
    };
}
export const Effect = {
    $type: "devvit.ui.effects.v1alpha.Effect",
    encode(message, writer = _m0.Writer.create()) {
        if (message.realtimeSubscriptions !== undefined) {
            RealtimeSubscriptionsEffect.encode(message.realtimeSubscriptions, writer.uint32(10).fork()).ldelim();
        }
        if (message.rerenderUi !== undefined) {
            RerenderEffect.encode(message.rerenderUi, writer.uint32(18).fork()).ldelim();
        }
        if (message.reloadPart !== undefined) {
            ReloadPartEffect.encode(message.reloadPart, writer.uint32(26).fork()).ldelim();
        }
        if (message.showForm !== undefined) {
            ShowFormEffect.encode(message.showForm, writer.uint32(34).fork()).ldelim();
        }
        if (message.showToast !== undefined) {
            ShowToastEffect.encode(message.showToast, writer.uint32(42).fork()).ldelim();
        }
        if (message.navigateToUrl !== undefined) {
            NavigateToUrlEffect.encode(message.navigateToUrl, writer.uint32(50).fork()).ldelim();
        }
        if (message.interval !== undefined) {
            SetIntervalsEffect.encode(message.interval, writer.uint32(74).fork()).ldelim();
        }
        if (message.createOrder !== undefined) {
            CreateOrderEffect.encode(message.createOrder, writer.uint32(82).fork()).ldelim();
        }
        if (message.webView !== undefined) {
            WebViewEffect.encode(message.webView, writer.uint32(90).fork()).ldelim();
        }
        if (message.type !== 0) {
            writer.uint32(56).int32(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEffect();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.realtimeSubscriptions = RealtimeSubscriptionsEffect.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.rerenderUi = RerenderEffect.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.reloadPart = ReloadPartEffect.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.showForm = ShowFormEffect.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.showToast = ShowToastEffect.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.navigateToUrl = NavigateToUrlEffect.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.interval = SetIntervalsEffect.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.createOrder = CreateOrderEffect.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.webView = WebViewEffect.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            realtimeSubscriptions: isSet(object.realtimeSubscriptions)
                ? RealtimeSubscriptionsEffect.fromJSON(object.realtimeSubscriptions)
                : undefined,
            rerenderUi: isSet(object.rerenderUi) ? RerenderEffect.fromJSON(object.rerenderUi) : undefined,
            reloadPart: isSet(object.reloadPart) ? ReloadPartEffect.fromJSON(object.reloadPart) : undefined,
            showForm: isSet(object.showForm) ? ShowFormEffect.fromJSON(object.showForm) : undefined,
            showToast: isSet(object.showToast) ? ShowToastEffect.fromJSON(object.showToast) : undefined,
            navigateToUrl: isSet(object.navigateToUrl) ? NavigateToUrlEffect.fromJSON(object.navigateToUrl) : undefined,
            interval: isSet(object.interval) ? SetIntervalsEffect.fromJSON(object.interval) : undefined,
            createOrder: isSet(object.createOrder) ? CreateOrderEffect.fromJSON(object.createOrder) : undefined,
            webView: isSet(object.webView) ? WebViewEffect.fromJSON(object.webView) : undefined,
            type: isSet(object.type) ? effectTypeFromJSON(object.type) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.realtimeSubscriptions !== undefined) {
            obj.realtimeSubscriptions = RealtimeSubscriptionsEffect.toJSON(message.realtimeSubscriptions);
        }
        if (message.rerenderUi !== undefined) {
            obj.rerenderUi = RerenderEffect.toJSON(message.rerenderUi);
        }
        if (message.reloadPart !== undefined) {
            obj.reloadPart = ReloadPartEffect.toJSON(message.reloadPart);
        }
        if (message.showForm !== undefined) {
            obj.showForm = ShowFormEffect.toJSON(message.showForm);
        }
        if (message.showToast !== undefined) {
            obj.showToast = ShowToastEffect.toJSON(message.showToast);
        }
        if (message.navigateToUrl !== undefined) {
            obj.navigateToUrl = NavigateToUrlEffect.toJSON(message.navigateToUrl);
        }
        if (message.interval !== undefined) {
            obj.interval = SetIntervalsEffect.toJSON(message.interval);
        }
        if (message.createOrder !== undefined) {
            obj.createOrder = CreateOrderEffect.toJSON(message.createOrder);
        }
        if (message.webView !== undefined) {
            obj.webView = WebViewEffect.toJSON(message.webView);
        }
        if (message.type !== 0) {
            obj.type = effectTypeToJSON(message.type);
        }
        return obj;
    },
    create(base) {
        return Effect.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEffect();
        message.realtimeSubscriptions =
            (object.realtimeSubscriptions !== undefined && object.realtimeSubscriptions !== null)
                ? RealtimeSubscriptionsEffect.fromPartial(object.realtimeSubscriptions)
                : undefined;
        message.rerenderUi = (object.rerenderUi !== undefined && object.rerenderUi !== null)
            ? RerenderEffect.fromPartial(object.rerenderUi)
            : undefined;
        message.reloadPart = (object.reloadPart !== undefined && object.reloadPart !== null)
            ? ReloadPartEffect.fromPartial(object.reloadPart)
            : undefined;
        message.showForm = (object.showForm !== undefined && object.showForm !== null)
            ? ShowFormEffect.fromPartial(object.showForm)
            : undefined;
        message.showToast = (object.showToast !== undefined && object.showToast !== null)
            ? ShowToastEffect.fromPartial(object.showToast)
            : undefined;
        message.navigateToUrl = (object.navigateToUrl !== undefined && object.navigateToUrl !== null)
            ? NavigateToUrlEffect.fromPartial(object.navigateToUrl)
            : undefined;
        message.interval = (object.interval !== undefined && object.interval !== null)
            ? SetIntervalsEffect.fromPartial(object.interval)
            : undefined;
        message.createOrder = (object.createOrder !== undefined && object.createOrder !== null)
            ? CreateOrderEffect.fromPartial(object.createOrder)
            : undefined;
        message.webView = (object.webView !== undefined && object.webView !== null)
            ? WebViewEffect.fromPartial(object.webView)
            : undefined;
        message.type = object.type ?? 0;
        return message;
    },
};
messageTypeRegistry.set(Effect.$type, Effect);
function isSet(value) {
    return value !== null && value !== undefined;
}
