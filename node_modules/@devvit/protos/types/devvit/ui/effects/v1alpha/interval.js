/**
 * #interval.ts
 *
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Duration } from "../../../../google/protobuf/duration.js";
import { BoolValue } from "../../../../google/protobuf/wrappers.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
function createBaseSetIntervalsEffect() {
    return { intervals: {} };
}
export const SetIntervalsEffect = {
    $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.intervals).forEach(([key, value]) => {
            SetIntervalsEffect_IntervalsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetIntervalsEffect();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SetIntervalsEffect_IntervalsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.intervals[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            intervals: isObject(object.intervals)
                ? Object.entries(object.intervals).reduce((acc, [key, value]) => {
                    acc[key] = IntervalDetails.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.intervals) {
            const entries = Object.entries(message.intervals);
            if (entries.length > 0) {
                obj.intervals = {};
                entries.forEach(([k, v]) => {
                    obj.intervals[k] = IntervalDetails.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return SetIntervalsEffect.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetIntervalsEffect();
        message.intervals = Object.entries(object.intervals ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = IntervalDetails.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(SetIntervalsEffect.$type, SetIntervalsEffect);
function createBaseSetIntervalsEffect_IntervalsEntry() {
    return { key: "", value: undefined };
}
export const SetIntervalsEffect_IntervalsEntry = {
    $type: "devvit.ui.effects.v1alpha.SetIntervalsEffect.IntervalsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            IntervalDetails.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetIntervalsEffect_IntervalsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = IntervalDetails.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? IntervalDetails.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = IntervalDetails.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SetIntervalsEffect_IntervalsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetIntervalsEffect_IntervalsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? IntervalDetails.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(SetIntervalsEffect_IntervalsEntry.$type, SetIntervalsEffect_IntervalsEntry);
function createBaseIntervalDetails() {
    return { duration: undefined, async: undefined };
}
export const IntervalDetails = {
    $type: "devvit.ui.effects.v1alpha.IntervalDetails",
    encode(message, writer = _m0.Writer.create()) {
        if (message.duration !== undefined) {
            Duration.encode(message.duration, writer.uint32(10).fork()).ldelim();
        }
        if (message.async !== undefined) {
            BoolValue.encode({ value: message.async }, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIntervalDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.duration = Duration.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.async = BoolValue.decode(reader, reader.uint32()).value;
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
            async: isSet(object.async) ? Boolean(object.async) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.duration !== undefined) {
            obj.duration = Duration.toJSON(message.duration);
        }
        if (message.async !== undefined) {
            obj.async = message.async;
        }
        return obj;
    },
    create(base) {
        return IntervalDetails.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIntervalDetails();
        message.duration = (object.duration !== undefined && object.duration !== null)
            ? Duration.fromPartial(object.duration)
            : undefined;
        message.async = object.async ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(IntervalDetails.$type, IntervalDetails);
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
