/**
 * #event.ts
 *
 * @packageDocumentation
 */
import _m0 from "protobufjs/minimal.js";
import { OrderResultEvent } from "../../effects/v1alpha/create_order.js";
import { RealtimeSubscriptionEvent } from "../../effects/v1alpha/realtime_subscriptions.js";
import { FormSubmittedEvent } from "../../effects/v1alpha/show_form.js";
import { ToastActionEvent } from "../../effects/v1alpha/show_toast.js";
import { WebViewEvent } from "./web_view.js";
/**
 * This is set when we want to map events to a specific runtime, examples:
 * [1] incoming realtime messages on a websocket connection
 * [2] keydown events in a text input block
 * Both are intended to be run only on local runtime
 */
export declare enum UIEventScope {
    ALL = 0,
    LOCAL = 1,
    REMOTE = 2,
    UNRECOGNIZED = -1
}
export declare function uIEventScopeFromJSON(object: any): UIEventScope;
export declare function uIEventScopeToJSON(object: UIEventScope): number;
export interface UIEvent {
    realtimeEvent?: RealtimeSubscriptionEvent | undefined;
    formSubmitted?: FormSubmittedEvent | undefined;
    orderResult?: OrderResultEvent | undefined;
    toastAction?: ToastActionEvent | undefined;
    userAction?: UserAction | undefined;
    asyncRequest?: AsyncRequest | undefined;
    asyncResponse?: AsyncResponse | undefined;
    timer?: TimerEvent | undefined;
    blocking?: BlockingRenderEvent | undefined;
    resize?: ResizeEvent | undefined;
    webView?: WebViewEvent | undefined;
    /**
     * If an event is async, it can be fired in parallel with other events.  Async events
     * are not allowed to mutate state.  Any state mutations they attempt would be ignored.
     * If they want to communicate something back to the state, they need to pass a message via
     * effects.
     */
    async?: boolean | undefined;
    /** The id of a the hook that should respond to this event */
    hook?: string | undefined;
    /** Signals if this event should be sent to the front (true) or back of the queue (false) */
    retry?: boolean | undefined;
    scope?: UIEventScope | undefined;
}
/**
 * Server-side rendering event.  This is a signal to the server that it should
 * wait for all of the promises to resolve before sending the response.
 *
 * The default behavior is to send the response as soon as possible, and then
 * stream in the rest of the data as it becomes available.  This is usually
 * slower on first load, but faster on subsequent loads.
 *
 * On first load, the server is usually close to the database, so the
 * back-and-forth is relatively cheap compared to asking the client to initiate
 * a bunch of waterfalling requests to the server.
 */
export interface BlockingRenderEvent {
}
/** Signals to the server of device/client-side surface size changes */
export interface ResizeEvent {
}
/**
 * There's no data sent with the timer (yet?).  Just knowing to fire it is
 * enough.
 */
export interface TimerEvent {
}
export interface AsyncError {
    message: string;
    /** Typically a stack trace */
    details: string;
}
export interface AsyncRequest {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
}
export interface AsyncResponse {
    requestId: string;
    data?: {
        [key: string]: any;
    } | undefined;
    error?: AsyncError | undefined;
}
export interface UserAction {
    actionId: string;
    data?: {
        [key: string]: any;
    } | undefined;
}
export declare const UIEvent: {
    $type: "devvit.ui.events.v1alpha.UIEvent";
    encode(message: UIEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UIEvent;
    fromJSON(object: any): UIEvent;
    toJSON(message: UIEvent): unknown;
    create(base?: DeepPartial<UIEvent>): UIEvent;
    fromPartial(object: DeepPartial<UIEvent>): UIEvent;
};
export declare const BlockingRenderEvent: {
    $type: "devvit.ui.events.v1alpha.BlockingRenderEvent";
    encode(_: BlockingRenderEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BlockingRenderEvent;
    fromJSON(_: any): BlockingRenderEvent;
    toJSON(_: BlockingRenderEvent): unknown;
    create(base?: DeepPartial<BlockingRenderEvent>): BlockingRenderEvent;
    fromPartial(_: DeepPartial<BlockingRenderEvent>): BlockingRenderEvent;
};
export declare const ResizeEvent: {
    $type: "devvit.ui.events.v1alpha.ResizeEvent";
    encode(_: ResizeEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResizeEvent;
    fromJSON(_: any): ResizeEvent;
    toJSON(_: ResizeEvent): unknown;
    create(base?: DeepPartial<ResizeEvent>): ResizeEvent;
    fromPartial(_: DeepPartial<ResizeEvent>): ResizeEvent;
};
export declare const TimerEvent: {
    $type: "devvit.ui.events.v1alpha.TimerEvent";
    encode(_: TimerEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TimerEvent;
    fromJSON(_: any): TimerEvent;
    toJSON(_: TimerEvent): unknown;
    create(base?: DeepPartial<TimerEvent>): TimerEvent;
    fromPartial(_: DeepPartial<TimerEvent>): TimerEvent;
};
export declare const AsyncError: {
    $type: "devvit.ui.events.v1alpha.AsyncError";
    encode(message: AsyncError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncError;
    fromJSON(object: any): AsyncError;
    toJSON(message: AsyncError): unknown;
    create(base?: DeepPartial<AsyncError>): AsyncError;
    fromPartial(object: DeepPartial<AsyncError>): AsyncError;
};
export declare const AsyncRequest: {
    $type: "devvit.ui.events.v1alpha.AsyncRequest";
    encode(message: AsyncRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncRequest;
    fromJSON(object: any): AsyncRequest;
    toJSON(message: AsyncRequest): unknown;
    create(base?: DeepPartial<AsyncRequest>): AsyncRequest;
    fromPartial(object: DeepPartial<AsyncRequest>): AsyncRequest;
};
export declare const AsyncResponse: {
    $type: "devvit.ui.events.v1alpha.AsyncResponse";
    encode(message: AsyncResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AsyncResponse;
    fromJSON(object: any): AsyncResponse;
    toJSON(message: AsyncResponse): unknown;
    create(base?: DeepPartial<AsyncResponse>): AsyncResponse;
    fromPartial(object: DeepPartial<AsyncResponse>): AsyncResponse;
};
export declare const UserAction: {
    $type: "devvit.ui.events.v1alpha.UserAction";
    encode(message: UserAction, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserAction;
    fromJSON(object: any): UserAction;
    toJSON(message: UserAction): unknown;
    create(base?: DeepPartial<UserAction>): UserAction;
    fromPartial(object: DeepPartial<UserAction>): UserAction;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=event.d.ts.map