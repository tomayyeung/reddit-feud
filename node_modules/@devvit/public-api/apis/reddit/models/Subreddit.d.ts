import type { AboutLocationRequest, Metadata } from '@devvit/protos';
import type { Prettify } from '@devvit/shared-types/Prettify.js';
import type { T5ID } from '@devvit/shared-types/tid.js';
import { Comment } from './Comment.js';
import type { CreateFlairTemplateOptions, GetUserFlairBySubredditResponse, UserFlairPageOptions } from './Flair.js';
import { FlairTemplate } from './Flair.js';
import { Listing } from './Listing.js';
import type { GetModerationLogOptions as _GetModerationLogOptions, ModAction } from './ModAction.js';
import type { GetPostsOptionsWithTimeframe, SubmitLinkOptions, SubmitSelfPostOptions } from './Post.js';
import { Post } from './Post.js';
import type { BanUserOptions, BanWikiContributorOptions, GetSubredditUsersByTypeOptions, ModeratorPermission } from './User.js';
import { User } from './User.js';
type GetModerationLogOptions = Omit<_GetModerationLogOptions, 'subredditName'>;
type GetUsersOptions = Omit<GetSubredditUsersByTypeOptions, 'subredditName' | 'type'>;
export type SubredditType = 'public' | 'private' | 'restricted' | 'employees_only' | 'gold_only' | 'gold_restricted' | 'archived' | 'user';
export declare enum AboutLocations {
    Reports = "reports",
    Spam = "spam",
    Modqueue = "modqueue",
    Unmoderated = "unmoderated",
    Edited = "edited"
}
export type AboutSubredditTypes = 'comment' | 'post' | 'all';
type AboutSubredditOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location' | 'subreddit'>;
export type ModLogOptions<T extends AboutSubredditTypes> = Omit<AboutSubredditHelperOptions<T>, 'location'>;
type AboutSubredditHelperOptions<T extends AboutSubredditTypes> = Prettify<{
    type: T;
} & AboutLocationRequest>;
export type CommentMediaTypes = 'giphy' | 'static' | 'animated' | 'expression';
export type FlairSettings = {
    enabled: boolean;
    usersCanAssign: boolean;
    userFlairBackgroundColor?: string;
    userFlairTextColor?: string;
};
export type GetUserFlairOptions = UserFlairPageOptions & {
    /** If provide the method will return the flairs for the provided users, if not provided
     * it will return a list of all users assigned flairs in the subreddit */
    usernames?: string[];
};
/**
 * An individual Removal Reason object.
 */
export type RemovalReason = {
    /**
     * The ID of the removal reason.
     */
    id: string;
    /**
     * The message associated with the removal reason.
     */
    message: string;
    /**
     * The title of the removal reason.
     */
    title: string;
};
export type SubredditSettings = {
    /**
     * Whether the subreddit accepts followers or not.
     */
    acceptFollowers: boolean;
    /**
     * Whether all content posted on the subreddit is original.
     */
    allOriginalContent: boolean;
    /**
     * Whether users are allowed to create chat posts on the subreddit.
     */
    allowChatPostCreation: boolean;
    /**
     * Whether the subreddit can be discovered through search.
     */
    allowDiscovery: boolean;
    /**
     * Whether the subreddit allows galleries.
     */
    allowGalleries: boolean;
    /**
     * Whether the subreddit allows images.
     */
    allowImages: boolean;
    /**
     * Whether the subreddit allows polls.
     */
    allowPolls: boolean;
    /**
     * Whether contributors are allowed to make predictions on the subreddit.
     */
    allowPredictionContributors: boolean;
    /**
     * Whether predictions are allowed on the subreddit.
     */
    allowPredictions: boolean;
    /**
     * Whether prediction tournaments are allowed on the subreddit.
     */
    allowPredictionsTournament: boolean;
    /**
     * Whether talks are allowed on the subreddit.
     */
    allowTalks: boolean;
    /**
     * Whether video GIFs are allowed on the subreddit.
     */
    allowVideoGifs: boolean;
    /**
     * Whether videos are allowed on the subreddit.
     */
    allowVideos: boolean;
    /**
     * Whether chat posts are enabled on the subreddit.
     */
    chatPostEnabled: boolean;
    /**
     * Whether collections are enabled on the subreddit.
     */
    collectionsEnabled: boolean;
    /**
     * Whether crossposts can be made to this subreddit.
     */
    crosspostable: boolean;
    /**
     * Whether emojis are enabled on the subreddit.
     */
    emojisEnabled: boolean;
    /**
     * Whether event posts are enabled on the subreddit.
     */
    eventPostsEnabled: boolean;
    /**
     * Whether link flairs are enabled on the subreddit.
     */
    linkFlairEnabled: boolean;
    /**
     * Whether the Original Content tag is enabled.
     */
    originalContentTagEnabled: boolean;
    /**
     * Whether commenting is restricted in the subreddit.
     */
    restrictCommenting: boolean;
    /**
     * Whether posting is restricted in the subreddit.
     */
    restrictPosting: boolean;
    /**
     * Whether posts in the subreddit should be automatically archived after 6 months.
     */
    shouldArchivePosts: boolean;
    /**
     * Whether the Spoiler tag is enabled.
     */
    spoilersEnabled: boolean;
    /**
     * Whether the wiki is enabled for the subreddit.
     */
    wikiEnabled: boolean;
    /**
     * The types of post allowed in this subreddit. Either "any", "link", or "self".
     */
    allowedPostType: 'any' | 'link' | 'self';
    /**
     * List of allowed media types in the comments made in the subreddit.
     */
    allowedMediaInComments: CommentMediaTypes[];
    /**
     * a 6-digit rgb hex color of the banner e.g. `#AABBCC`,
     */
    bannerBackgroundColor?: string;
    /**
     * The background image of the banner.
     */
    bannerBackgroundImage?: string;
    /**
     * The URL of the banner image.
     */
    bannerImage?: string;
    /**
     * The URL of the community icon.
     */
    communityIcon?: string;
    /**
     * The header title.
     */
    headerTitle?: string;
    /**
     * The 6-digit rgb hex color of the subreddit's key color, e.g. `#AABBCC`,
     */
    keyColor?: string;
    /**
     * Banner image used on mobile apps.
     */
    mobileBannerImage?: string;
    /**
     * The 6-digit rgb hex color of the subreddit's primary color, e.g. `#AABBCC`,
     */
    primaryColor?: string;
    /**
     * The user flair settings for the subreddit.
     */
    userFlairs: FlairSettings;
    /**
     * The post flair settings for the subreddit.
     */
    postFlairs: FlairSettings;
    /**
     * HTTP URL to the subreddit
     */
    url: string;
};
export type SubredditLeaderboardSummaryRow = {
    title: string;
    key: string;
    value: number;
};
export type SubredditLeaderboardSummary = {
    data: SubredditLeaderboardSummaryRow[];
};
/**
 * An individual Leaderboard object.
 */
export type SubredditLeaderboard = {
    id: string;
    summary: SubredditLeaderboardSummary;
};
export type BackgroundImagePosition = 'cover' | 'tiled' | 'centered';
export type BannerHeight = 'small' | 'medium' | 'large';
export type CommunityNameFormat = 'slashtag' | 'pretty' | 'hide';
export type CustomizationFlag = 'default' | 'custom';
export type ImagePosition = 'cover' | 'tiled';
export type MenuPosition = 'default' | 'overlay';
export type PositionedImagePosition = 'left' | 'right' | 'centered';
export type Visibility = 'show' | 'hide';
/**
 * A class representing the styles of a Subreddit.
 */
export type SubredditStyles = {
    backgroundColor?: string;
    backgroundImage?: string;
    backgroundImagePosition?: BackgroundImagePosition;
    bannerBackgroundColor?: string;
    bannerBackgroundImage?: string;
    bannerBackgroundImagePosition?: ImagePosition;
    bannerCommunityName?: string;
    bannerCommunityNameFormat?: CommunityNameFormat;
    bannerHeight?: BannerHeight;
    bannerOverlayColor?: string;
    bannerPositionedImage?: string;
    bannerPositionedImagePosition?: PositionedImagePosition;
    bannerShowCommunityIcon?: Visibility;
    highlightColor?: string;
    icon?: string;
    legacyBannerBackgroundImage?: string;
    legacyPrimaryColor?: string;
    menuBackgroundBlur?: number;
    menuBackgroundColor?: string;
    menuBackgroundImage?: string;
    menuBackgroundOpacity?: number;
    menuLinkColorActive?: string;
    menuLinkColorHover?: string;
    menuLinkColorInactive?: string;
    menuPosition?: MenuPosition;
    mobileBannerImage?: string;
    mobileKeyColor?: string;
    postBackgroundColor?: string;
    postBackgroundImage?: string;
    postBackgroundImagePosition?: ImagePosition;
    postDownvoteCountColor?: string;
    postDownvoteIconActive?: string;
    postDownvoteIconInactive?: string;
    postPlaceholderImage?: string;
    postPlaceholderImagePosition?: ImagePosition;
    postTitleColor?: string;
    postUpvoteCountColor?: string;
    postUpvoteIconActive?: string;
    postUpvoteIconInactive?: string;
    postVoteIcons?: CustomizationFlag;
    primaryColor?: string;
    secondaryBannerPositionedImage?: string;
    sidebarWidgetBackgroundColor?: string;
    sidebarWidgetHeaderColor?: string;
    submenuBackgroundColor?: string;
    submenuBackgroundStyle?: CustomizationFlag;
};
export declare class SubredditDescription {
    markdown?: string;
}
export declare class SubredditWikiSettings {
    wikiEditMode?: WikiEditMode;
}
export type WikiEditMode = 'disabled' | 'modonly' | 'anyone';
export type PostType = 'link' | 'image' | 'video' | 'text' | 'spoiler' | 'poll' | 'gallery' | 'talk' | 'prediction' | 'videogif' | 'streaming' | 'crosspost';
export type PostCapabilities = 'ama';
export declare class AuthorFlairSettings {
    isEnabled?: boolean;
    isSelfAssignabled?: boolean;
}
export declare class PostFlairSettings {
    isEnabled?: boolean;
    isSelfAssignabled?: boolean;
}
/**
 * A class representing information about a Subreddit.
 */
export type SubredditInfo = {
    id?: T5ID;
    name?: string;
    createdAt?: Date;
    type?: SubredditType;
    title?: string;
    description?: SubredditDescription;
    detectedLanguage?: string;
    subscribersCount?: number;
    activeCount?: number;
    isNsfw?: boolean;
    isQuarantined?: boolean;
    isDiscoveryAllowed?: boolean;
    isPredictionContributorsAllowed?: boolean;
    isPredictionAllowed?: boolean;
    isPredictionsTournamentAllowed?: boolean;
    isChatPostCreationAllowed?: boolean;
    isChatPostFeatureEnabled?: boolean;
    isCrosspostingAllowed?: boolean;
    isEmojisEnabled?: boolean;
    isCommentingRestricted?: boolean;
    isPostingRestricted?: boolean;
    isArchivePostsEnabled?: boolean;
    isSpoilerAvailable?: boolean;
    allAllowedPostTypes?: PostType[];
    allowedPostCapabilities?: PostCapabilities[];
    allowedMediaInComments?: CommentMediaTypes[];
    authorFlairSettings?: AuthorFlairSettings;
    postFlairSettings?: PostFlairSettings;
    wikiSettings?: SubredditWikiSettings;
};
/**
 * A class representing a subreddit.
 */
export declare class Subreddit {
    #private;
    /**
     * The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
     */
    get id(): T5ID;
    /**
     * The name of a subreddit omitting the r/.
     */
    get name(): string;
    /**
     * The creation date of the subreddit.
     */
    get createdAt(): Date;
    /**
     * The type of subreddit (public, private, etc.).
     */
    get type(): SubredditType;
    /**
     * The title of the subreddit.
     */
    get title(): string | undefined;
    /**
     * The description of the subreddit.
     */
    get description(): string | undefined;
    /**
     * The language of the subreddit.
     */
    get language(): string;
    /**
     * The number of subscribers of the subreddit.
     */
    get numberOfSubscribers(): number;
    /**
     * The number of active users of the subreddit.
     */
    get numberOfActiveUsers(): number;
    /**
     * Whether the subreddit is marked as NSFW (Not Safe For Work).
     */
    get nsfw(): boolean;
    /**
     * The settings of the subreddit.
     */
    get settings(): SubredditSettings;
    /**
     * Whether the user flairs are enabled for this subreddit.
     */
    get userFlairsEnabled(): boolean;
    /**
     * Whether the post flairs are enabled for this subreddit.
     */
    get postFlairsEnabled(): boolean;
    /**
     * Whether the user can assign user flairs.
     * This is only true if the user flairs are enabled.
     */
    get usersCanAssignUserFlairs(): boolean;
    /**
     * Whether the user can assign post flairs.
     * This is only true if the post flairs are enabled.
     */
    get usersCanAssignPostFlairs(): boolean;
    /**
     * Returns the HTTP URL for the subreddit.
     * (R2 bug: subreddit.url is a permalink path and does not return a fully qualified URL in subreddit.url)
     */
    get url(): string;
    /**
     * Returns a permalink path
     * (R2 bug: subreddit.url is a permalink, and does not have a subreddit.permalink field)
     */
    get permalink(): string;
    toJSON(): Pick<Subreddit, 'id' | 'name' | 'createdAt' | 'type' | 'title' | 'description' | 'language' | 'nsfw' | 'numberOfSubscribers' | 'numberOfActiveUsers' | 'settings'>;
    submitPost(options: SubmitLinkOptions | SubmitSelfPostOptions): Promise<Post>;
    getControversialPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getTopPosts(options?: Omit<GetPostsOptionsWithTimeframe, 'subredditName'>): Listing<Post>;
    getApprovedUsers(options?: GetUsersOptions): Listing<User>;
    approveUser(username: string): Promise<void>;
    removeUser(username: string): Promise<void>;
    getWikiContributors(options?: GetUsersOptions): Listing<User>;
    addWikiContributor(username: string): Promise<void>;
    removeWikiContributor(username: string): Promise<void>;
    getBannedUsers(options?: GetUsersOptions): Listing<User>;
    banUser(options: Omit<BanUserOptions, 'subredditName'>): Promise<void>;
    unbanUser(username: string): Promise<void>;
    getBannedWikiContributors(options?: GetUsersOptions): Listing<User>;
    banWikiContributor(options: Omit<BanWikiContributorOptions, 'subredditName'>): Promise<void>;
    unbanWikiContributor(username: string): Promise<void>;
    getModerators(options?: GetUsersOptions): Listing<User>;
    inviteModerator(username: string, permissions?: ModeratorPermission[]): Promise<void>;
    revokeModeratorInvite(username: string): Promise<void>;
    removeModerator(username: string): Promise<void>;
    setModeratorPermissions(username: string, permissions: ModeratorPermission[]): Promise<void>;
    getMutedUsers(options?: GetUsersOptions): Listing<User>;
    muteUser(username: string, note?: string): Promise<void>;
    unmuteUser(username: string): Promise<void>;
    getModerationLog(options: GetModerationLogOptions): Listing<ModAction>;
    getUserFlairTemplates(): Promise<FlairTemplate[]>;
    getPostFlairTemplates(): Promise<FlairTemplate[]>;
    createPostFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    createUserFlairTemplate(options: Omit<CreateFlairTemplateOptions, 'subredditName'>): Promise<FlairTemplate>;
    /**
     * Get the user flair for the given subreddit. If `usernames` is provided then it will return only the
     * flair for the specified users. If retrieving the list of flair for a given subreddit and the list is long
     * then this method will return a `next` field which can be passed into the `after` field on the next call to
     * retrieve the next slice of data. To retrieve the previous slice of data pass the `prev` field into the `before` field
     * during the subsequent call.
     *
     * @param options See interface
     * @param metadata See interface
     *
     * @example
     * ```ts
     * const subredditName = "mysubreddit"
     * const subreddit = await reddit.getSubredditByName(subredditName)
     * const response = await subreddit.getUserFlair();
     * const userFlairList = response.users
     * ```
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ after: "t2_awefae"});
     * const userFlairList = response.users
     * ```
     *
     * @example
     * ```ts
     * const response = await subreddit.getUserFlair({ usernames: ['toxictoad', 'badapple']});
     * const userFlairList = response.users
     * ```
     */
    getUserFlair(options?: GetUserFlairOptions): Promise<GetUserFlairBySubredditResponse>;
    /**
     * Return a listing of things requiring moderator review, such as reported things and items.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getModQueue();
     * console.log("Posts and Comments: ",  await listing.all())
     * listing = await subreddit.getModQueue({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getModQueue(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getModQueue(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getModQueue(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been reported.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getReports();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getReports({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getReports(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getReports(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getReports(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been marked as spam or otherwise removed.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getSpam();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getSpam({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getSpam(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getSpam(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getSpam(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have yet to be approved/removed by a mod.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getUnmoderated();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getUnmoderated({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getUnmoderated(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getUnmoderated(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getUnmoderated(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things that have been edited recently.
     *
     * @param options
     *
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName("mysubreddit")
     * let listing = await subreddit.getEdited();
     * console.log("Posts and Comments: ", await listing.all())
     * listing = await subreddit.getEdited({ type: "post"});
     * console.log("Posts: ", await listing.all())
     * ```
     */
    getEdited(options: AboutSubredditOptions<'comment'>): Listing<Comment>;
    getEdited(options: AboutSubredditOptions<'post'>): Listing<Post>;
    getEdited(options?: AboutSubredditOptions<'all'>): Listing<Post | Comment>;
    /**
     * Return a listing of things specified by their fullnames.
     *
     * @param ids Array of thing full ids (e.g. t3_abc123)
     * @example
     * ```ts
     * const subreddit = await reddit.getSubredditByName('askReddit');
     * const listing = subreddit.getCommentsAndPostsByIds(['t3_abc123', 't1_xyz123']);
     * const items = await listing.all();
     * console.log(items) // [Post, Comment]
     * ```
     */
    getCommentsAndPostsByIds(ids: string[]): Listing<Post | Comment>;
}
/**
 * Gets a {@link SubredditInfo} object by ID
 *
 * @param {string} id - The ID (starting with t5_) of the subreddit to retrieve. e.g. t5_2qjpg
 * @param metadata - Optional RPC metadata passed with every request.
 * @returns {Promise<SubredditInfo>} A Promise that resolves a SubredditInfo object.
 */
export declare function getSubredditInfoById(subredditId: string, metadata: Metadata | undefined): Promise<SubredditInfo>;
/**
 * Gets a {@link SubredditInfo} object by name
 *
 * @param {string} name The name of a subreddit omitting the r/. This is case insensitive.
 * @param metadata - Optional RPC metadata passed with every request.
 * @returns {Promise<SubredditInfo>} A Promise that resolves a SubredditInfo object.
 */
export declare function getSubredditInfoByName(subredditName: string, metadata: Metadata | undefined): Promise<SubredditInfo>;
export declare function getSubredditLeaderboard(subredditId: string, metadata: Metadata | undefined): Promise<SubredditLeaderboard>;
export declare function getSubredditStyles(subredditId: string, metadata: Metadata | undefined): Promise<SubredditStyles>;
export {};
//# sourceMappingURL=Subreddit.d.ts.map