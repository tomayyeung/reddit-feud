var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UIClient_effects, _UIClient_reconciler, _UIClient_webViewClient, _UIClient_postMessage;
import { EffectType, Form, ToastAppearance, } from '@devvit/protos';
import { Devvit } from '../../devvit/Devvit.js';
import { assertValidFormFields } from './helpers/assertValidFormFields.js';
import { transformFormFields } from './helpers/transformForm.js';
export class UIClient {
    constructor(reconciler) {
        _UIClient_effects.set(this, []);
        _UIClient_reconciler.set(this, void 0);
        _UIClient_webViewClient.set(this, void 0);
        _UIClient_postMessage.set(this, (webViewId, message) => {
            __classPrivateFieldGet(this, _UIClient_effects, "f").push({
                type: EffectType.EFFECT_WEB_VIEW,
                webView: {
                    postMessage: {
                        webViewId,
                        app: { message },
                    },
                },
            });
        });
        __classPrivateFieldSet(this, _UIClient_reconciler, reconciler, "f");
        __classPrivateFieldSet(this, _UIClient_webViewClient, {
            postMessage: __classPrivateFieldGet(this, _UIClient_postMessage, "f"),
        }, "f");
    }
    get webView() {
        return __classPrivateFieldGet(this, _UIClient_webViewClient, "f");
    }
    showForm(formKey, data) {
        let formDefinition = Devvit.formDefinitions.get(formKey);
        if (!formDefinition && __classPrivateFieldGet(this, _UIClient_reconciler, "f")) {
            const hookForm = __classPrivateFieldGet(this, _UIClient_reconciler, "f").forms.get(formKey);
            if (hookForm) {
                formDefinition = {
                    form: hookForm,
                    onSubmit: () => { }, // no-op
                };
            }
        }
        if (!formDefinition) {
            throw new Error('Form does not exist. Make sure you have added it using Devvit.createForm at the root of your app.');
        }
        const formData = formDefinition.form instanceof Function
            ? formDefinition.form(data ?? {})
            : formDefinition.form;
        const form = {
            fields: [],
            id: formKey,
            title: formData.title,
            acceptLabel: formData.acceptLabel,
            cancelLabel: formData.cancelLabel,
            shortDescription: formData.description,
        };
        assertValidFormFields(formData.fields);
        form.fields = transformFormFields(formData.fields);
        __classPrivateFieldGet(this, _UIClient_effects, "f").push({
            type: EffectType.EFFECT_SHOW_FORM,
            showForm: {
                form,
            },
        });
    }
    showToast(textOrToast) {
        let toast;
        if (textOrToast instanceof Object) {
            toast = {
                text: textOrToast.text,
                appearance: textOrToast.appearance === 'success' ? ToastAppearance.SUCCESS : ToastAppearance.NEUTRAL,
            };
        }
        else {
            toast = {
                text: textOrToast,
            };
        }
        __classPrivateFieldGet(this, _UIClient_effects, "f").push({
            type: EffectType.EFFECT_SHOW_TOAST,
            showToast: {
                toast,
            },
        });
    }
    navigateTo(thingOrUrl) {
        let url;
        if (typeof thingOrUrl === 'string') {
            // Validate URL
            url = new URL(thingOrUrl).toString();
        }
        else {
            url = new URL(thingOrUrl.permalink, 'https://www.reddit.com').toString();
        }
        __classPrivateFieldGet(this, _UIClient_effects, "f").push({
            type: EffectType.EFFECT_NAVIGATE_TO_URL,
            navigateToUrl: {
                url,
            },
        });
    }
    /** @internal */
    get __effects() {
        return __classPrivateFieldGet(this, _UIClient_effects, "f");
    }
}
_UIClient_effects = new WeakMap(), _UIClient_reconciler = new WeakMap(), _UIClient_webViewClient = new WeakMap(), _UIClient_postMessage = new WeakMap();
