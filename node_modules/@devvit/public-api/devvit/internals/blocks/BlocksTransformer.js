var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BlocksTransformer_assetsClient;
import { BlockActionType, BlockAvatarBackground, BlockAvatarFacing, BlockAvatarSize, BlockBorderWidth, BlockButtonAppearance, BlockButtonSize, BlockGap, BlockHorizontalAlignment, BlockIconSize, BlockImageResizeMode, BlockPadding, BlockRadius, BlockSpacerShape, BlockSpacerSize, BlockStackDirection, BlockTextOutline, BlockTextOverflow, BlockTextSize, BlockTextStyle, BlockTextWeight, BlockType, BlockVerticalAlignment, } from '@devvit/protos';
import { Devvit } from '../../Devvit.js';
import { getHexFromNamedHTMLColor, getHexFromRgbaColor, getHexFromRPLColor, isHexColor, isHslColor, isNamedHTMLColor, isRgbaColor, isRPLColor, } from '../helpers/color.js';
import { makeStackDimensionsDetails, ROOT_STACK_TRANSFORM_CONTEXT } from './transformContext.js';
import { makeBlockSizes } from './transformerUtils.js';
const DATA_PREFIX = 'data-';
const ACTION_HANDLERS = new Set(['onPress', 'onMessage']);
const ACTION_TYPES = new Map([
    ['onPress', BlockActionType.ACTION_CLICK],
    ['onMessage', BlockActionType.ACTION_WEBVIEW],
]);
export class BlocksTransformer {
    constructor(getAssetsClient = () => undefined) {
        _BlocksTransformer_assetsClient.set(this, void 0);
        __classPrivateFieldSet(this, _BlocksTransformer_assetsClient, getAssetsClient, "f");
    }
    createBlocksElementOrThrow({ type, props, children }) {
        const block = this.createBlocksElement({ type, props, children }, ROOT_STACK_TRANSFORM_CONTEXT);
        if (!block) {
            throw new Error(`Could not create block of type ${type}`);
        }
        return block;
    }
    createBlocksElement({ type, props, children }, transformContext) {
        switch (type) {
            case 'blocks':
                return this.makeRoot(props, ...children);
            case 'hstack':
                return this.makeHStack(props, transformContext, ...children);
            case 'vstack':
                return this.makeVStack(props, transformContext, ...children);
            case 'zstack':
                return this.makeZStack(props, transformContext, ...children);
            case 'text':
                return this.makeText(props, transformContext, ...children);
            case 'button':
                return this.makeButton(props, transformContext, ...children);
            case 'image':
                return this.makeImage(props, transformContext);
            case 'spacer':
                return this.makeSpacer(props, transformContext);
            case 'icon':
                return this.makeIcon(props, transformContext);
            case 'avatar':
                return this.makeAvatar(props, transformContext);
            case 'webview':
                return this.makeWebView(props, transformContext);
            case '__fragment':
                throw new Error("root fragment is not supported - use 'blocks' instead");
        }
        return undefined;
    }
    makeRootHeight(height) {
        switch (height) {
            case 'regular':
                return 320;
            case 'tall':
                return 512;
        }
    }
    makeBlockPadding(padding) {
        switch (padding) {
            case 'none':
                return BlockPadding.PADDING_NONE;
            case 'xsmall':
                return BlockPadding.PADDING_XSMALL;
            case 'small':
                return BlockPadding.PADDING_SMALL;
            case 'medium':
                return BlockPadding.PADDING_MEDIUM;
            case 'large':
                return BlockPadding.PADDING_LARGE;
        }
        return undefined;
    }
    makeBlockRadius(radius) {
        switch (radius) {
            case 'none':
                return BlockRadius.RADIUS_NONE;
            case 'small':
                return BlockRadius.RADIUS_SMALL;
            case 'medium':
                return BlockRadius.RADIUS_MEDIUM;
            case 'large':
                return BlockRadius.RADIUS_LARGE;
            case 'full':
                return BlockRadius.RADIUS_FULL;
        }
        return undefined;
    }
    makeBlockGap(gap) {
        switch (gap) {
            case 'none':
                return BlockGap.GAP_NONE;
            case 'small':
                return BlockGap.GAP_SMALL;
            case 'medium':
                return BlockGap.GAP_MEDIUM;
            case 'large':
                return BlockGap.GAP_LARGE;
        }
        return undefined;
    }
    makeBlockAlignment(alignment) {
        if (alignment === undefined)
            return undefined;
        let vertical = undefined;
        let horizontal = undefined;
        if (alignment.includes('top')) {
            vertical = BlockVerticalAlignment.ALIGN_TOP;
        }
        else if (alignment.includes('middle')) {
            vertical = BlockVerticalAlignment.ALIGN_MIDDLE;
        }
        else if (alignment.includes('bottom')) {
            vertical = BlockVerticalAlignment.ALIGN_BOTTOM;
        }
        if (alignment.includes('start')) {
            horizontal = BlockHorizontalAlignment.ALIGN_START;
        }
        else if (alignment.includes('center')) {
            horizontal = BlockHorizontalAlignment.ALIGN_CENTER;
        }
        else if (alignment.includes('end')) {
            horizontal = BlockHorizontalAlignment.ALIGN_END;
        }
        if (vertical !== undefined || horizontal !== undefined) {
            return {
                vertical,
                horizontal,
            };
        }
        return undefined;
    }
    makeBlockBorder(borderWidth, color, lightColor, darkColor) {
        if (!borderWidth && !color)
            return undefined;
        let width = undefined;
        switch (borderWidth) {
            case 'none':
                width = BlockBorderWidth.BORDER_WIDTH_NONE;
                break;
            case 'thin':
                width = BlockBorderWidth.BORDER_WIDTH_THIN;
                break;
            case 'thick':
                width = BlockBorderWidth.BORDER_WIDTH_THICK;
                break;
            default:
                // Default to a thin border when a color was set, but no borderWidth.
                width = BlockBorderWidth.BORDER_WIDTH_THIN;
                break;
        }
        // Default to #00000019 when a border was set, but no color.
        const borderColor = color ?? 'neutral-border-weak';
        const colors = this.getThemedColors(borderColor, lightColor, darkColor);
        return {
            width,
            color: colors?.light,
            colors,
        };
    }
    makeBlockTextSize(textSize) {
        switch (textSize) {
            case 'xsmall':
                return BlockTextSize.TEXT_SIZE_XSMALL;
            case 'small':
                return BlockTextSize.TEXT_SIZE_SMALL;
            case 'medium':
                return BlockTextSize.TEXT_SIZE_MEDIUM;
            case 'large':
                return BlockTextSize.TEXT_SIZE_LARGE;
            case 'xlarge':
                return BlockTextSize.TEXT_SIZE_XLARGE;
            case 'xxlarge':
                return BlockTextSize.TEXT_SIZE_XXLARGE;
        }
        return undefined;
    }
    makeBlockTextStyle(style) {
        switch (style) {
            case 'body':
                return BlockTextStyle.TEXT_STYLE_BODY;
            case 'metadata':
                return BlockTextStyle.TEXT_STYLE_METADATA;
            case 'heading':
                return BlockTextStyle.TEXT_STYLE_HEADING;
        }
        return undefined;
    }
    makeBlockTextOutline(outline) {
        switch (outline) {
            case 'none':
                return BlockTextOutline.TEXT_OUTLINE_NONE;
            case 'thin':
                return BlockTextOutline.TEXT_OUTLINE_THIN;
            case 'thick':
                return BlockTextOutline.TEXT_OUTLINE_THICK;
        }
        return undefined;
    }
    makeBlockTextWeight(weight) {
        switch (weight) {
            case 'regular':
                return BlockTextWeight.TEXT_WEIGHT_REGULAR;
            case 'bold':
                return BlockTextWeight.TEXT_WEIGHT_BOLD;
        }
        return undefined;
    }
    makeBlockTextOverflow(overflow) {
        switch (overflow) {
            case 'clip':
                return BlockTextOverflow.TEXT_OVERFLOW_CLIP;
            case 'ellipsis':
                return BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE;
        }
        return BlockTextOverflow.TEXT_OVERFLOW_ELLIPSE;
    }
    makeBlockButtonAppearance(appearance) {
        switch (appearance) {
            case 'secondary':
                return BlockButtonAppearance.BUTTON_APPEARANCE_SECONDARY;
            case 'primary':
                return BlockButtonAppearance.BUTTON_APPEARANCE_PRIMARY;
            case 'plain':
                return BlockButtonAppearance.BUTTON_APPEARANCE_PLAIN;
            case 'bordered':
                return BlockButtonAppearance.BUTTON_APPEARANCE_BORDERED;
            case 'media':
                return BlockButtonAppearance.BUTTON_APPEARANCE_MEDIA;
            case 'destructive':
                return BlockButtonAppearance.BUTTON_APPEARANCE_DESTRUCTIVE;
            case 'caution':
                return BlockButtonAppearance.BUTTON_APPEARANCE_CAUTION;
            case 'success':
                return BlockButtonAppearance.BUTTON_APPEARANCE_SUCCESS;
        }
        return undefined;
    }
    makeBlockButtonSize(size) {
        switch (size) {
            case 'small':
                return BlockButtonSize.BUTTON_SIZE_SMALL;
            case 'medium':
                return BlockButtonSize.BUTTON_SIZE_MEDIUM;
            case 'large':
                return BlockButtonSize.BUTTON_SIZE_LARGE;
        }
        return undefined;
    }
    makeBlockImageResizeMode(resize) {
        switch (resize) {
            case 'none':
                return BlockImageResizeMode.IMAGE_RESIZE_NONE;
            case 'fit':
                return BlockImageResizeMode.IMAGE_RESIZE_FIT;
            case 'fill':
                return BlockImageResizeMode.IMAGE_RESIZE_FILL;
            case 'cover':
                return BlockImageResizeMode.IMAGE_RESIZE_COVER;
            case 'scale-down':
                return BlockImageResizeMode.IMAGE_RESIZE_SCALE_DOWN;
        }
        return undefined;
    }
    makeBlockSpacerSize(size) {
        switch (size) {
            case 'xsmall':
                return BlockSpacerSize.SPACER_XSMALL;
            case 'small':
                return BlockSpacerSize.SPACER_SMALL;
            case 'medium':
                return BlockSpacerSize.SPACER_MEDIUM;
            case 'large':
                return BlockSpacerSize.SPACER_LARGE;
        }
        return undefined;
    }
    makeBlockSpacerShape(size) {
        switch (size) {
            case 'invisible':
                return BlockSpacerShape.SPACER_INVISIBLE;
            case 'thin':
                return BlockSpacerShape.SPACER_THIN;
            case 'square':
                return BlockSpacerShape.SPACER_SQUARE;
        }
        return undefined;
    }
    makeBlockIconSize(size) {
        switch (size) {
            case 'xsmall':
                return BlockIconSize.ICON_SIZE_XSMALL;
            case 'small':
                return BlockIconSize.ICON_SIZE_SMALL;
            case 'medium':
                return BlockIconSize.ICON_SIZE_MEDIUM;
            case 'large':
                return BlockIconSize.ICON_SIZE_LARGE;
        }
        return undefined;
    }
    makeBlockAvatarSize(size) {
        switch (size) {
            case 'xxsmall':
                return BlockAvatarSize.AVATAR_SIZE_XXSMALL;
            case 'xsmall':
                return BlockAvatarSize.AVATAR_SIZE_XSMALL;
            case 'small':
                return BlockAvatarSize.AVATAR_SIZE_SMALL;
            case 'medium':
                return BlockAvatarSize.AVATAR_SIZE_MEDIUM;
            case 'large':
                return BlockAvatarSize.AVATAR_SIZE_LARGE;
            case 'xlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
            case 'xxlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXLARGE;
            case 'xxxlarge':
                return BlockAvatarSize.AVATAR_SIZE_XXXLARGE;
        }
        return undefined;
    }
    makeBlockAvatarFacing(facing) {
        switch (facing) {
            case 'left':
                return BlockAvatarFacing.AVATAR_FACING_LEFT;
            case 'right':
                return BlockAvatarFacing.AVATAR_FACING_RIGHT;
        }
        return undefined;
    }
    makeBlockAvatarBackground(background) {
        switch (background) {
            case 'dark':
                return BlockAvatarBackground.AVATAR_BG_DARK;
            case 'light':
                return BlockAvatarBackground.AVATAR_BG_LIGHT;
        }
        return undefined;
    }
    getDataSet(props) {
        return Object.keys(props)
            .filter((key) => key.startsWith(DATA_PREFIX))
            .reduce((p, c) => {
            p[c.substring(DATA_PREFIX.length)] = props[c];
            return p;
        }, {});
    }
    makeActions(_type, props) {
        const actions = [];
        const dataSet = this.getDataSet(props);
        ACTION_HANDLERS.forEach((action) => {
            if (action in props) {
                const id = props[action];
                actions.push({
                    type: ACTION_TYPES.get(action) ?? BlockActionType.UNRECOGNIZED,
                    id: id.toString(),
                    data: dataSet,
                });
            }
        });
        return actions;
    }
    blockColorToHex(color, theme = 'light') {
        if (!color)
            return undefined;
        color = color.toLowerCase();
        if (isHexColor(color)) {
            return color;
        }
        else if (isRPLColor(color)) {
            return getHexFromRPLColor(color, theme);
        }
        else if (isNamedHTMLColor(color)) {
            return getHexFromNamedHTMLColor(color);
        }
        else if (isRgbaColor(color)) {
            return getHexFromRgbaColor(color);
        }
        else if (isHslColor(color)) {
            return color;
        }
        // Color could not be parsed, return red as fallback.
        console.warn(`Could not parse color: ${color}.`);
        return getHexFromNamedHTMLColor('red');
    }
    childrenToBlocks(children, transformContext) {
        return children.flatMap((child) => (typeof child !== 'string'
            ? this.createBlocksElement(child, transformContext)
            : undefined) ?? []);
    }
    getThemedColors(color, light, dark) {
        let lightColor = this.blockColorToHex(light, 'light');
        let darkColor = this.blockColorToHex(dark, 'dark');
        const tokens = [];
        // don't spend time parsing color if light/dark are already provided
        if (color && (!lightColor || !darkColor)) {
            // split color string, preserving color functions with spaces, such as rgb(r, g, b)
            // eslint-disable-next-line security/detect-unsafe-regex
            const matches = Array.from(color?.matchAll(/[\w#-]+(?:\([\w\t ,.#-]+\))?/g) ?? []);
            tokens.push(...matches.map((group) => group[0]));
        }
        if (!lightColor) {
            lightColor = this.blockColorToHex(tokens?.at(0), 'light');
        }
        if (!darkColor) {
            // if only one color was provided, use it for both light and dark colors
            darkColor = this.blockColorToHex(tokens?.at(1) ?? tokens?.at(0), 'dark');
        }
        return lightColor || darkColor
            ? {
                light: lightColor,
                dark: darkColor,
            }
            : undefined;
    }
    parsePixels(input) {
        if (typeof input === 'string') {
            return Number(input.slice(0, -2));
        }
        return input;
    }
    resolveAssetUrl(url, options) {
        // try and resolve the URL but allow the client to decide if unknown URLs are allowed
        return __classPrivateFieldGet(this, _BlocksTransformer_assetsClient, "f").call(this)?.getURL(url, options) ?? url;
    }
    childrenToString(children) {
        return children.map((c) => c.toString()).join('');
    }
    makeRoot(props, ...children) {
        return this.wrapRoot(props, this.childrenToBlocks(children, ROOT_STACK_TRANSFORM_CONTEXT));
    }
    wrapRoot(props, children) {
        return this.makeBlock(BlockType.BLOCK_ROOT, {}, {}, {
            rootConfig: {
                children: children,
                height: this.makeRootHeight(Devvit.customPostType?.height ??
                    props?.height ??
                    'regular'),
            },
        });
    }
    makeStackBlock(direction, props, transformContext, children) {
        const backgroundColors = this.getThemedColors(props?.backgroundColor, props?.lightBackgroundColor, props?.darkBackgroundColor);
        const alignment = this.makeBlockAlignment(props?.alignment);
        const blockSizes = makeBlockSizes(props, transformContext);
        const blockDimensionsDetails = makeStackDimensionsDetails(props, transformContext.stackParentLayout, blockSizes);
        return this.makeBlock(BlockType.BLOCK_STACK, props, transformContext, {
            stackConfig: {
                alignment,
                backgroundColor: backgroundColors?.light,
                backgroundColors,
                border: this.makeBlockBorder(props?.border, props?.borderColor, props?.lightBorderColor, props?.darkBorderColor),
                children: this.childrenToBlocks(children, {
                    stackParentLayout: { ...blockDimensionsDetails, direction, alignment },
                }),
                cornerRadius: this.makeBlockRadius(props?.cornerRadius),
                direction: direction,
                gap: this.makeBlockGap(props?.gap),
                padding: this.makeBlockPadding(props?.padding),
                reverse: props?.reverse,
            },
        });
    }
    makeHStack(props, transformContext, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_HORIZONTAL, props, transformContext, children);
    }
    makeVStack(props, transformContext, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_VERTICAL, props, transformContext, children);
    }
    makeZStack(props, transformContext, ...children) {
        return this.makeStackBlock(BlockStackDirection.STACK_DEPTH, props, transformContext, children);
    }
    makeText(props, transformContext, ...children) {
        const colors = this.getThemedColors(props?.color, props?.lightColor, props?.darkColor);
        return this.makeBlock(BlockType.BLOCK_TEXT, props, transformContext, {
            textConfig: {
                alignment: this.makeBlockAlignment(props?.alignment),
                color: colors?.light,
                colors,
                outline: this.makeBlockTextOutline(props?.outline),
                size: this.makeBlockTextSize(props?.size),
                style: this.makeBlockTextStyle(props?.style),
                text: this.childrenToString(children),
                weight: this.makeBlockTextWeight(props?.weight),
                selectable: props?.selectable,
                wrap: props?.wrap,
                overflow: this.makeBlockTextOverflow(props?.overflow),
            },
        });
    }
    makeButton(props, transformContext, ...children) {
        const textColors = this.getThemedColors(props?.textColor, props?.lightTextColor, props?.darkTextColor);
        return this.makeBlock(BlockType.BLOCK_BUTTON, props, transformContext, {
            buttonConfig: {
                buttonAppearance: this.makeBlockButtonAppearance(props?.appearance),
                // not available in all platforms yet
                // backgroundColor: props?.backgroundColor,
                icon: props?.icon,
                buttonSize: this.makeBlockButtonSize(props?.size),
                text: this.childrenToString(children),
                textColor: textColors?.light,
                textColors,
                disabled: props?.disabled,
            },
        });
    }
    makeImage(props, transformContext) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_IMAGE, props, transformContext, {
                imageConfig: {
                    description: props?.description,
                    resizeMode: this.makeBlockImageResizeMode(props.resizeMode),
                    url: this.resolveAssetUrl(props.url),
                    width: this.parsePixels(props.imageWidth),
                    height: this.parsePixels(props.imageHeight),
                },
            }));
    }
    makeSpacer(props, transformContext) {
        return this.makeBlock(BlockType.BLOCK_SPACER, props, transformContext, {
            spacerConfig: {
                size: this.makeBlockSpacerSize(props?.size),
                shape: this.makeBlockSpacerShape(props?.shape),
            },
        });
    }
    makeIcon(props, transformContext) {
        const colors = this.getThemedColors(props?.color, props?.lightColor, props?.darkColor);
        return (props &&
            this.makeBlock(BlockType.BLOCK_ICON, props, transformContext, {
                iconConfig: {
                    icon: props.name,
                    color: colors?.light,
                    colors,
                    size: this.makeBlockIconSize(props.size),
                },
            }));
    }
    makeAvatar(props, transformContext) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_AVATAR, props, transformContext, {
                avatarConfig: {
                    thingId: props.thingId,
                    size: this.makeBlockAvatarSize(props.size),
                    facing: this.makeBlockAvatarFacing(props.facing),
                    background: this.makeBlockAvatarBackground(props.background),
                },
            }));
    }
    makeWebView(props, transformContext) {
        return (props &&
            this.makeBlock(BlockType.BLOCK_WEBVIEW, props, transformContext, {
                webviewConfig: {
                    url: this.resolveAssetUrl(props.url, { webView: true }),
                    state: props.state,
                },
            }));
    }
    makeBlock(type, props, transformContext, config) {
        return {
            type,
            sizes: makeBlockSizes(props, transformContext),
            config: config,
            actions: (props && this.makeActions(type, props)) ?? [],
            id: props?.id,
            key: props?.key,
        };
    }
    ensureRootBlock(block) {
        let root;
        if (block.type === BlockType.BLOCK_ROOT) {
            if (block.config?.rootConfig && Devvit.customPostType?.height) {
                block.config.rootConfig.height = this.makeRootHeight(Devvit.customPostType?.height);
            }
            root = block;
        }
        else {
            root = this.wrapRoot(undefined, [block]);
        }
        if (!root) {
            throw new Error('Could not create root block');
        }
        return root;
    }
}
_BlocksTransformer_assetsClient = new WeakMap();
