import type { Effect, Metadata, UIEvent, UIRequest } from '@devvit/protos';
import type { Devvit } from '../../../Devvit.js';
import type { ReifiedBlockElement } from '../BlocksReconciler.js';
import type { EffectEmitter } from '../EffectEmitter.js';
import type { BlocksState, EventHandler, Hook, HookRef, HookSegment } from './types.js';
/**
 * The RenderContext is a class that holds the state of the rendering process.
 *
 * There are many properties that start with an underscore, which is a convention we use to
 * indicate that they are private and should not be accessed directly.  They are used internally
 * in tests and in the implementation of the BlocksHandler.
 *
 * DO your best to avoid adding new properties to this class to support new features.  It will be tempting
 * to add special cases for new features, but we should strive to work within the existing framework.
 */
export declare class RenderContext implements EffectEmitter {
    #private;
    readonly request: Readonly<UIRequest>;
    readonly meta: Readonly<Metadata>;
    _segments: (HookSegment & {
        next: number;
    })[];
    _prevHooks: {
        [hookID: string]: Hook;
    };
    _prevHookId: string;
    _effects: {
        [key: string]: Effect;
    };
    /**
     * While processing events, we do some renders to load hooks.  If those renders produce valid content, then
     * we won't have to render at the end of the event processing, rather we can hang onto the last render and
     * reuse it.
     */
    _latestRenderContent: ReifiedBlockElement | undefined;
    /**
     * Has this state been mutated since initially loaded?
     *
     * _changed is used to determine the state deltas to report in the response
     * of the handle function inside of BlocksHandler. It's very important
     * that this list contains a comprehensive list of all hooks that have
     * changed during the entire invocation of BlocksHandler.handle.
     *
     * It may be tempting to clear the state deltas on every iteration via the
     * loop, but in doing so you'll create many roundtrips from the client to
     * the runtime resulting in the UI flickering.
     */
    _changed: {
        [hookID: string]: true;
    };
    /** Does this hook still exist in the most recent render? */
    _touched: {
        [hookID: string]: true;
    };
    /** Events that will re-enter the dispatcher queue */
    _requeueEvents: UIEvent[];
    _rootProps: {
        [key: string]: any;
    };
    _generated: {
        [key: string]: boolean;
    };
    static _staticUndeliveredHandlers: {
        [key: string]: EventHandler;
    };
    _undeliveredHandlers: {
        [key: string]: EventHandler;
    };
    _devvitContext?: Devvit.Context;
    get devvitContext(): Devvit.Context;
    set devvitContext(context: Devvit.Context);
    constructor(request: UIRequest, meta: Metadata);
    /** The state delta new to this render. */
    get _changedState(): BlocksState;
    get _hooks(): {
        [hookID: string]: Hook;
    };
    set _hooks(hooks: {
        [hookID: string]: Hook;
    });
    /** The complete render state. */
    get _state(): BlocksState;
    /** Replacing state resets the delta for the next render. */
    set _state(state: BlocksState);
    push(options: HookSegment): void;
    pop(): void;
    addUndeliveredEventHandler(id: string, handler: EventHandler): void;
    addGlobalUndeliveredEventHandler(id: string, handler: EventHandler): void;
    getHook(ref: HookRef): Hook;
    /** Catches events with no active handler and routes to the corresponding hook to detach/unsubscribe/etc **/
    static addGlobalUndeliveredEventHandler(id: string, handler: EventHandler): void;
    handleUndeliveredEvent(ev: UIEvent): Promise<Effect[] | void>;
    emitEffect(dedupeKey: string, effect: Effect): void;
    /**
     * Adds event that will re-enter the dispatcher queue.
     */
    addToRequeueEvents(...events: UIEvent[]): void;
    get effects(): Effect[];
    nextHookId(options: HookSegment): string;
}
//# sourceMappingURL=RenderContext.d.ts.map