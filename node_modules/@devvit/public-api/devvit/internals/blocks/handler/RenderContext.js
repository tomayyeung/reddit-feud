var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RenderContext_state, _RenderContext_hooks;
/** @internal */
export function _isTombstone(value) {
    return typeof value === 'object' && value !== null && '__deleted' in value;
}
/**
 * The RenderContext is a class that holds the state of the rendering process.
 *
 * There are many properties that start with an underscore, which is a convention we use to
 * indicate that they are private and should not be accessed directly.  They are used internally
 * in tests and in the implementation of the BlocksHandler.
 *
 * DO your best to avoid adding new properties to this class to support new features.  It will be tempting
 * to add special cases for new features, but we should strive to work within the existing framework.
 */
export class RenderContext {
    get devvitContext() {
        if (!this._devvitContext) {
            throw new Error('Devvit context not available');
        }
        return this._devvitContext;
    }
    set devvitContext(context) {
        this._devvitContext = context;
    }
    constructor(request, meta) {
        _RenderContext_state.set(this, void 0);
        this._segments = [];
        _RenderContext_hooks.set(this, {});
        this._prevHooks = {};
        this._prevHookId = '';
        this._effects = {};
        /**
         * Has this state been mutated since initially loaded?
         *
         * _changed is used to determine the state deltas to report in the response
         * of the handle function inside of BlocksHandler. It's very important
         * that this list contains a comprehensive list of all hooks that have
         * changed during the entire invocation of BlocksHandler.handle.
         *
         * It may be tempting to clear the state deltas on every iteration via the
         * loop, but in doing so you'll create many roundtrips from the client to
         * the runtime resulting in the UI flickering.
         */
        this._changed = {};
        /** Does this hook still exist in the most recent render? */
        this._touched = {};
        /** Events that will re-enter the dispatcher queue */
        this._requeueEvents = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._rootProps = {};
        this._generated = {};
        this._undeliveredHandlers = {};
        this.request = request;
        this.meta = meta;
        __classPrivateFieldSet(this, _RenderContext_state, request.state ?? {
            __cache: {},
        }, "f");
        this._rootProps = request.props ?? {};
    }
    /** The state delta new to this render. */
    get _changedState() {
        const changed = {
            __cache: __classPrivateFieldGet(this, _RenderContext_state, "f").__cache ?? {},
        };
        for (const key in this._changed)
            changed[key] = this._state[key];
        const unmounted = new Set(Object.keys(this._state));
        Object.keys(__classPrivateFieldGet(this, _RenderContext_hooks, "f")).forEach((key) => {
            if (key === '__cache') {
                return;
            }
            unmounted.delete(key);
        });
        unmounted.forEach((key) => {
            if (key === '__cache') {
                return;
            }
            const t = { __deleted: true };
            this._state[key] = changed[key] = t;
        });
        return changed;
    }
    get _hooks() {
        return __classPrivateFieldGet(this, _RenderContext_hooks, "f");
    }
    set _hooks(hooks) {
        this._prevHooks = __classPrivateFieldGet(this, _RenderContext_hooks, "f");
        __classPrivateFieldSet(this, _RenderContext_hooks, hooks, "f");
    }
    /** The complete render state. */
    get _state() {
        return __classPrivateFieldGet(this, _RenderContext_state, "f");
    }
    /** Replacing state resets the delta for the next render. */
    set _state(state) {
        // You may be tempted to put `this._changed = {}` here, please DON'T!
        // There are many times we may choose to reset the state while processing
        // events. Remember that the BlocksHandler can do N number of passes before
        // it determines it is time to send a response back to the client. _changed
        // needs to encompass all of those changes.
        // You may also be tempted to put `this._hooks = {}` here, please DON'T!
        // Some hooks (useState) may rely on values held on the previous hook. If you
        // set this._hooks = {} and then call #loadHooks from BlocksHandler, you will
        // accidentally remove all state held in prevHooks since the first step of
        // #loadHooks is to set hooks values to {}. Setting hooks to {} is a concern that
        // should live outside of RenderContext and inside of BlocksHandler on a case
        // by case basis.
        __classPrivateFieldSet(this, _RenderContext_state, state, "f");
    }
    push(options) {
        this._segments.push({ ...options, next: 0 });
    }
    pop() {
        this._segments.pop();
    }
    addUndeliveredEventHandler(id, handler) {
        this._undeliveredHandlers[id] = handler;
    }
    addGlobalUndeliveredEventHandler(id, handler) {
        RenderContext.addGlobalUndeliveredEventHandler(id, handler);
    }
    getHook(ref) {
        return __classPrivateFieldGet(this, _RenderContext_hooks, "f")[ref.id];
    }
    /** Catches events with no active handler and routes to the corresponding hook to detach/unsubscribe/etc **/
    static addGlobalUndeliveredEventHandler(id, handler) {
        RenderContext._staticUndeliveredHandlers[id] = handler;
    }
    async handleUndeliveredEvent(ev) {
        const allHandlers = {
            ...RenderContext._staticUndeliveredHandlers,
            ...this._undeliveredHandlers,
        };
        for (const [_, handler] of Object.entries(allHandlers)) {
            await handler(ev, this);
        }
    }
    emitEffect(dedupeKey, effect) {
        this._effects[dedupeKey] = effect;
    }
    /**
     * Adds event that will re-enter the dispatcher queue.
     */
    addToRequeueEvents(...events) {
        if (this._devvitContext?.debug.blocks)
            console.debug('[blocks] requeueing events', events);
        const grouped = events.reduce((acc, event) => {
            if (event.retry) {
                acc.retry.push(event);
            }
            else {
                acc.normal.push(event);
            }
            return acc;
        }, { retry: [], normal: [] });
        // We need to maintain the order of the events, so we need to add the retry events first
        this._requeueEvents = [...grouped.retry, ...this._requeueEvents, ...grouped.normal];
    }
    get effects() {
        return Object.values(this._effects);
    }
    nextHookId(options) {
        if (options.key === undefined) {
            options.key = this._segments[this._segments.length - 1].next++ + '';
        }
        this.push(options);
        try {
            const builder = [];
            /**
             * We need to build the hook id from the segments in reverse order, because an explicit id
             * overrides parent path info.
             */
            for (let i = this._segments.length - 1; i >= 0; i--) {
                const segment = this._segments[i];
                if (segment.id) {
                    builder.unshift(segment.id);
                    break;
                }
                const tag = [];
                if (segment.namespace) {
                    tag.push(segment.namespace);
                }
                if (segment.key !== undefined && segment.key !== false) {
                    tag.push(segment.key);
                }
                builder.unshift(tag.join('-'));
            }
            const id = builder.join('.');
            if (this._generated[id] && !options.shared) {
                throw new Error(`Hook id ${id} already used, cannot register another hook with the same id`);
            }
            this._generated[id] = true;
            this._prevHookId = id;
            return id;
        }
        finally {
            this.pop();
        }
    }
}
_RenderContext_state = new WeakMap(), _RenderContext_hooks = new WeakMap();
RenderContext._staticUndeliveredHandlers = {};
