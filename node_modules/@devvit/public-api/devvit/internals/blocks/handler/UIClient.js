var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UIClient_renderContext, _UIClient_webViewMessageCount, _UIClient_webViewClient, _UIClient_webViewPostMessage;
import { EffectType, Form, ToastAppearance } from '@devvit/protos';
import { assertValidFormFields } from '../../../../apis/ui/helpers/assertValidFormFields.js';
import { transformFormFields } from '../../../../apis/ui/helpers/transformForm.js';
import { _activeRenderContext } from './BlocksHandler.js';
import { getFormDefinition } from './useForm.js';
export function useUI() {
    const renderContext = _activeRenderContext;
    if (!renderContext) {
        throw new Error('useUI can only be called from within the top level of a component.');
    }
    return new UIClient(renderContext);
}
export class UIClient {
    constructor(renderContext) {
        _UIClient_renderContext.set(this, void 0);
        // Auto-incrementing count of the number of WebviewMessage effects called this frame.
        // Used as part of the dedup key for emitEvent to prevent messages from being dedup'd.
        _UIClient_webViewMessageCount.set(this, 0);
        _UIClient_webViewClient.set(this, void 0);
        _UIClient_webViewPostMessage.set(this, (webViewId, message) => {
            var _a, _b;
            __classPrivateFieldGet(this, _UIClient_renderContext, "f").emitEffect(`postMessage${__classPrivateFieldSet(this, _UIClient_webViewMessageCount, (_b = __classPrivateFieldGet(this, _UIClient_webViewMessageCount, "f"), _a = _b++, _b), "f"), _a}`, {
                type: EffectType.EFFECT_WEB_VIEW,
                webView: {
                    postMessage: {
                        webViewId,
                        app: { message },
                    },
                },
            });
        });
        __classPrivateFieldSet(this, _UIClient_renderContext, renderContext, "f");
        __classPrivateFieldSet(this, _UIClient_webViewClient, {
            postMessage: __classPrivateFieldGet(this, _UIClient_webViewPostMessage, "f"),
        }, "f");
    }
    get webView() {
        return __classPrivateFieldGet(this, _UIClient_webViewClient, "f");
    }
    showForm(formKey, data) {
        const formDefinition = getFormDefinition(__classPrivateFieldGet(this, _UIClient_renderContext, "f"), formKey);
        if (!formDefinition) {
            throw new Error('Form does not exist. Make sure you have added it using useForm.');
        }
        const formData = formDefinition.form instanceof Function
            ? formDefinition.form(data ?? {})
            : formDefinition.form;
        const form = {
            fields: [],
            id: formKey,
            title: formData.title,
            acceptLabel: formData.acceptLabel,
            cancelLabel: formData.cancelLabel,
            shortDescription: formData.description,
        };
        assertValidFormFields(formData.fields);
        form.fields = transformFormFields(formData.fields);
        __classPrivateFieldGet(this, _UIClient_renderContext, "f").emitEffect(formKey, {
            type: EffectType.EFFECT_SHOW_FORM,
            showForm: {
                form,
            },
        });
    }
    showToast(textOrToast) {
        let toast;
        if (textOrToast instanceof Object) {
            toast = {
                text: textOrToast.text,
                appearance: textOrToast.appearance === 'success' ? ToastAppearance.SUCCESS : ToastAppearance.NEUTRAL,
            };
        }
        else {
            toast = {
                text: textOrToast,
            };
        }
        __classPrivateFieldGet(this, _UIClient_renderContext, "f").emitEffect(textOrToast.toString(), {
            type: EffectType.EFFECT_SHOW_TOAST,
            showToast: {
                toast,
            },
        });
    }
    navigateTo(thingOrUrl) {
        let url;
        if (typeof thingOrUrl === 'string') {
            // Validate URL
            url = new URL(thingOrUrl).toString();
        }
        else {
            url = new URL(thingOrUrl.permalink, 'https://www.reddit.com').toString();
        }
        __classPrivateFieldGet(this, _UIClient_renderContext, "f").emitEffect(url, {
            type: EffectType.EFFECT_NAVIGATE_TO_URL,
            navigateToUrl: {
                url,
            },
        });
    }
}
_UIClient_renderContext = new WeakMap(), _UIClient_webViewMessageCount = new WeakMap(), _UIClient_webViewClient = new WeakMap(), _UIClient_webViewPostMessage = new WeakMap();
