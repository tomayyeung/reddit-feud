var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChannelHook_instances, _a, _ChannelHook_context, _ChannelHook_debug, _ChannelHook_invalidate, _ChannelHook_opts, _ChannelHook_emitSubscribed;
import { EffectType, RealtimeSubscriptionStatus } from '@devvit/protos';
import { Header } from '@devvit/shared-types/Header.js';
import { ChannelStatus } from '../../../../types/realtime.js';
import { registerHook } from './BlocksHandler.js';
class ChannelHook {
    constructor(opts, params) {
        _ChannelHook_instances.add(this);
        _ChannelHook_context.set(this, void 0);
        _ChannelHook_debug.set(this, void 0);
        /** Record state in BlocksHandler. */
        _ChannelHook_invalidate.set(this, void 0);
        _ChannelHook_opts.set(this, void 0);
        __classPrivateFieldSet(this, _ChannelHook_context, params.context, "f");
        __classPrivateFieldSet(this, _ChannelHook_debug, !!params.context._devvitContext?.debug.realtime, "f");
        __classPrivateFieldSet(this, _ChannelHook_opts, opts, "f");
        __classPrivateFieldSet(this, _ChannelHook_invalidate, params.invalidate, "f");
        const appID = params.context.meta[Header.App]?.values[0];
        if (!appID)
            throw Error('useChannel missing app ID metadata');
        const installID = params.context.meta[Header.Installation]?.values[0];
        if (!installID)
            throw Error('useChannel missing install ID from metadata');
        const channel = `${appID}:${installID}:${opts.name}`;
        const duplicate = Object.values(__classPrivateFieldGet(this, _ChannelHook_context, "f")._hooks)
            .filter((hook) => hook instanceof _a)
            .some((hook) => hook.state.channel === channel);
        if (duplicate)
            throw Error(`useChannel channel names must be unique; "${channel}" duplicated`);
        this.state = {
            channel,
            connected: false,
            subscribed: false,
        };
    }
    async onUIEvent(ev) {
        const realtime = ev.realtimeEvent;
        if (!realtime || !this.state.subscribed)
            return;
        switch (realtime.status) {
            case RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED:
                if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
                    console.debug(`[realtime] "${this.state.channel}" connected`);
                this.state.connected = true;
                __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
                await __classPrivateFieldGet(this, _ChannelHook_opts, "f").onSubscribed?.();
                break;
            case RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED:
                if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
                    console.debug(`[realtime] "${this.state.channel}" disconnected`);
                this.state.connected = false;
                __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
                await __classPrivateFieldGet(this, _ChannelHook_opts, "f").onUnsubscribed?.();
                break;
            default:
                if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
                    console.debug(`[realtime] "${this.state.channel}" received message: ${JSON.stringify(ev, undefined, 2)}`);
                // to-do: define a RealtimeSubscriptionStatus.MESSAGE. this could have
                //        been a oneOf but the current approach allows for status + data
                //        and this default case will break if another new type is added.
                // expect msg. this must align to RealtimeClient.send().
                __classPrivateFieldGet(this, _ChannelHook_opts, "f").onMessage(realtime.event?.data?.msg);
                break;
        }
    }
    async send(msg) {
        if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
            console.debug(`[realtime] "${this.state.channel}" send message: ${JSON.stringify(msg, undefined, 2)}`);
        if (!this.state.subscribed || !this.state.connected) {
            console.debug(`[realtime] "${this.state.channel}" send failed; channel not connected`);
            throw Error(`useChannel send failed; "${this.state.channel}" channel not connected`);
        }
        await __classPrivateFieldGet(this, _ChannelHook_context, "f").devvitContext.realtime.send(this.state.channel, msg);
    }
    get status() {
        if (this.state.subscribed && this.state.connected)
            return ChannelStatus.Connected;
        else if (this.state.subscribed && !this.state.connected)
            return ChannelStatus.Connecting;
        else if (!this.state.subscribed && this.state.connected)
            return ChannelStatus.Disconnecting;
        return ChannelStatus.Disconnected;
    }
    subscribe() {
        if (this.state.subscribed)
            return;
        if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
            console.debug(`[realtime] "${this.state.channel}" subscribed`);
        this.state.subscribed = true;
        __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
        __classPrivateFieldGet(this, _ChannelHook_instances, "m", _ChannelHook_emitSubscribed).call(this);
    }
    unsubscribe() {
        if (!this.state.subscribed)
            return;
        if (__classPrivateFieldGet(this, _ChannelHook_debug, "f"))
            console.debug(`[realtime] "${this.state.channel}" unsubscribed`);
        this.state.subscribed = false;
        __classPrivateFieldGet(this, _ChannelHook_invalidate, "f").call(this);
        __classPrivateFieldGet(this, _ChannelHook_instances, "m", _ChannelHook_emitSubscribed).call(this);
    }
}
_a = ChannelHook, _ChannelHook_context = new WeakMap(), _ChannelHook_debug = new WeakMap(), _ChannelHook_invalidate = new WeakMap(), _ChannelHook_opts = new WeakMap(), _ChannelHook_instances = new WeakSet(), _ChannelHook_emitSubscribed = function _ChannelHook_emitSubscribed() {
    const channels = Object.values(__classPrivateFieldGet(this, _ChannelHook_context, "f")._hooks)
        .filter((hook) => hook instanceof _a && hook.state.subscribed)
        .map((hook) => hook.state.channel);
    __classPrivateFieldGet(this, _ChannelHook_context, "f").emitEffect(this.state.channel, {
        type: EffectType.EFFECT_REALTIME_SUB,
        realtimeSubscriptions: { subscriptionIds: channels },
    });
};
export function useChannel(opts) {
    if (!opts.name || /[^a-zA-Z0-9_]/.test(opts.name))
        throw Error(`useChannel error: The name "${opts.name}" you provided for the hook is invalid. Valid names can only contain letters, numbers, and underscores (_).`);
    // allow RealtimeEffectHandler to compute hook ID. maintain compatibility with
    // realtimeChannelToHookID().
    const id = `useChannel:${opts.name}`;
    return registerHook({
        id,
        namespace: id,
        initializer: (params) => new ChannelHook(opts, params),
    });
}
