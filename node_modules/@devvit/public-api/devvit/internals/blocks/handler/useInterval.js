var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IntervalHook_hookId, _IntervalHook_invalidate, _IntervalHook_callback, _IntervalHook_context;
import { EffectType } from '@devvit/protos';
import { registerHook } from './BlocksHandler.js';
import { RenderContext } from './RenderContext.js';
/**
 * Keeps track of all the intervals that are currently running in a convenient global.
 */
const intervals = {};
RenderContext.addGlobalUndeliveredEventHandler('intervals', async (event, context) => {
    if (event.timer && event.hook) {
        delete intervals[event.hook];
        context.emitEffect('timers', {
            type: EffectType.EFFECT_SET_INTERVALS,
            interval: { intervals },
        });
    }
});
class IntervalHook {
    constructor(callback, requestedDelayMs, params) {
        _IntervalHook_hookId.set(this, void 0);
        _IntervalHook_invalidate.set(this, void 0);
        _IntervalHook_callback.set(this, void 0);
        _IntervalHook_context.set(this, void 0);
        this.state = { duration: { seconds: 0, nanos: 0 }, running: false };
        __classPrivateFieldSet(this, _IntervalHook_invalidate, params.invalidate, "f");
        __classPrivateFieldSet(this, _IntervalHook_hookId, params.hookId, "f");
        __classPrivateFieldSet(this, _IntervalHook_callback, callback, "f");
        __classPrivateFieldSet(this, _IntervalHook_context, params.context, "f");
        const seconds = Math.floor(requestedDelayMs / 1000);
        const nanos = (requestedDelayMs % 1000) * 1000000;
        this.state.duration = { seconds, nanos };
    }
    onStateLoaded() {
        if (this.state.running) {
            intervals[__classPrivateFieldGet(this, _IntervalHook_hookId, "f")] = { duration: this.state.duration };
        }
        else {
            delete intervals[__classPrivateFieldGet(this, _IntervalHook_hookId, "f")];
        }
    }
    async onUIEvent(_event) {
        await __classPrivateFieldGet(this, _IntervalHook_callback, "f").call(this);
    }
    start() {
        intervals[__classPrivateFieldGet(this, _IntervalHook_hookId, "f")] = { duration: this.state.duration };
        this.state.running = true;
        __classPrivateFieldGet(this, _IntervalHook_invalidate, "f").call(this);
        __classPrivateFieldGet(this, _IntervalHook_context, "f").emitEffect('timers', {
            type: EffectType.EFFECT_SET_INTERVALS,
            interval: { intervals },
        });
    }
    stop() {
        delete intervals[__classPrivateFieldGet(this, _IntervalHook_hookId, "f")];
        this.state.running = false;
        __classPrivateFieldGet(this, _IntervalHook_invalidate, "f").call(this);
        __classPrivateFieldGet(this, _IntervalHook_context, "f").emitEffect('timers', {
            type: EffectType.EFFECT_SET_INTERVALS,
            interval: { intervals },
        });
    }
}
_IntervalHook_hookId = new WeakMap(), _IntervalHook_invalidate = new WeakMap(), _IntervalHook_callback = new WeakMap(), _IntervalHook_context = new WeakMap();
export function useInterval(callback, requestedDelayMs) {
    const hook = registerHook({
        namespace: 'useInterval',
        initializer: (params) => {
            return new IntervalHook(callback, requestedDelayMs, params);
        },
    });
    return {
        start: () => hook.start(),
        stop: () => hook.stop(),
    };
}
