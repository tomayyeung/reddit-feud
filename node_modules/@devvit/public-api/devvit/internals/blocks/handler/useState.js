var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UseStateHook_changed, _UseStateHook_ctx, _UseStateHook_initializer, _UseStateHook_hookId;
import { UIEventScope } from '@devvit/protos';
import { registerHook } from './BlocksHandler.js';
import { RenderInterruptError } from './types.js';
import { toSerializableErrorOrCircuitBreak } from './useAsync.js';
/**
 * Implementation of the useState hook.
 */
class UseStateHook {
    constructor(initializer, params) {
        this.state = { value: null, load_state: 'initial', error: null };
        _UseStateHook_changed.set(this, void 0);
        _UseStateHook_ctx.set(this, void 0);
        _UseStateHook_initializer.set(this, void 0);
        _UseStateHook_hookId.set(this, void 0);
        __classPrivateFieldSet(this, _UseStateHook_initializer, initializer, "f");
        __classPrivateFieldSet(this, _UseStateHook_hookId, params.hookId, "f");
        __classPrivateFieldSet(this, _UseStateHook_changed, params.invalidate, "f");
        __classPrivateFieldSet(this, _UseStateHook_ctx, params.context, "f");
    }
    /**
     * For state initialized with a promise, this function is called when the promise resolves.  This should
     * happen inside the same event loop as the original call to useState, assuming circuit-breaking didn't happen.
     *
     * If circuit-breaking did happen, this function will be called on the server and the state will propagate to
     * the client.
     *
     * This is intended to be synchronous in the event loop, so will block and waterfall.  useAsync is the non-waterfalling
     * version, but this version is provided for backwards compatibility.
     */
    async onUIEvent() {
        if (this.state.load_state === 'loading' && this._promise) {
            try {
                this.state.value = await this._promise;
                this.state.load_state = 'loaded';
            }
            catch (e) {
                this.state.load_state = 'error';
                this.state.error = toSerializableErrorOrCircuitBreak(e);
            }
            __classPrivateFieldGet(this, _UseStateHook_changed, "f").call(this);
        }
        else {
            /**
             * This would probably be some sort of concurrent access bug.  It's not clear what would put us
             * in this state, but it's worth logging so we can investigate.
             */
            console.warn('Invalid state: ', this.state.load_state, this._promise);
        }
    }
    setter(action) {
        this.state.value = action instanceof Function ? action(this.state.value) : action;
        this.state.load_state = 'loaded';
        __classPrivateFieldGet(this, _UseStateHook_changed, "f").call(this);
    }
    /**
     * After the existing state is loaded, we need to run the initializer if there was no state found.
     */
    onStateLoaded() {
        this._promise = __classPrivateFieldGet(this, _UseStateHook_ctx, "f")._prevHooks[__classPrivateFieldGet(this, _UseStateHook_hookId, "f")]?._promise;
        /**
         * If the state is still loading, we need to throw an error to prevent using the null state.
         */
        if (this.state.load_state === 'loading') {
            throw new RenderInterruptError();
        }
        if (this.state.load_state === 'error') {
            throw new Error(this.state.error?.message ?? 'Unknown error');
        }
        if (this.state.load_state === 'initial') {
            let initialValue;
            try {
                initialValue =
                    __classPrivateFieldGet(this, _UseStateHook_initializer, "f") instanceof Function ? __classPrivateFieldGet(this, _UseStateHook_initializer, "f").call(this) : __classPrivateFieldGet(this, _UseStateHook_initializer, "f");
            }
            catch (e) {
                console.log('error in loading async', e);
                this.state.load_state = 'error';
                __classPrivateFieldGet(this, _UseStateHook_changed, "f").call(this);
                return;
            }
            if (initialValue instanceof Promise) {
                this._promise = initialValue;
                this.state.load_state = 'loading';
                const requeueEvent = {
                    scope: UIEventScope.ALL,
                    asyncRequest: { requestId: __classPrivateFieldGet(this, _UseStateHook_hookId, "f") },
                    hook: __classPrivateFieldGet(this, _UseStateHook_hookId, "f"),
                };
                __classPrivateFieldGet(this, _UseStateHook_ctx, "f").addToRequeueEvents(requeueEvent);
                __classPrivateFieldGet(this, _UseStateHook_changed, "f").call(this);
                throw new RenderInterruptError();
            }
            else {
                this.state.value = initialValue;
                this.state.load_state = 'loaded';
            }
            __classPrivateFieldGet(this, _UseStateHook_changed, "f").call(this);
        }
    }
}
_UseStateHook_changed = new WeakMap(), _UseStateHook_ctx = new WeakMap(), _UseStateHook_initializer = new WeakMap(), _UseStateHook_hookId = new WeakMap();
export function useState(initialState) {
    const hook = registerHook({
        namespace: 'useState',
        initializer: (params) => new UseStateHook(initialState, params),
    });
    return [hook.state.value, hook.setter.bind(hook)];
}
