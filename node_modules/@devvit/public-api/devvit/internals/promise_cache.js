var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PromiseCache_instances, _PromiseCache_redis, _PromiseCache_localCache, _PromiseCache_clock, _PromiseCache_state, _PromiseCache_localCachedAnswer, _PromiseCache_maybeRefreshCache, _PromiseCache_refreshCache, _PromiseCache_pollForCache, _PromiseCache_updateCache, _PromiseCache_calculateRamp, _PromiseCache_redisEntry, _PromiseCache_enforceTTL;
export const SystemClock = {
    now() {
        return new Date();
    },
};
export function _namespaced(key) {
    return `__autocache__${key}`;
}
export function _lock(key) {
    return `__lock__${key}`;
}
const pollEvery = 300; // milli
const maxPollingTimeout = 1000; // milli
const minTtlValue = 5000;
export const retryLimit = 3;
const errorRetryProbability = 0.1;
export const clientRetryDelay = 1000;
export const allowStaleFor = 30000;
function _unwrap(entry) {
    if (entry.error) {
        throw new Error(entry.error);
    }
    return entry.value;
}
/**
 * Refactored out into a class to allow for easier testing and clarity of purpose.
 *
 * This class is responsible for managing the caching of promises. It is a layered cache, meaning it will first check
 * the local cache, then the redis cache, and finally the source of truth. It will also handle refreshing the cache according
 * to the TTL and error handling.
 *
 * Please note that in order to prevent a stampede of requests to the source of truth, we use a lock in redis to ensure only one
 * request is made to the source of truth at a time.  If the lock is obtained, the cache will be updated and the lock will be released.
 *
 * Additionally, we use a polling mechanism to fetch the cache if the lock is not obtained.  This is to prevent unnecessary errors.
 *
 * Finally, we also want to prevent stampedes against redis for the lock election and the retries.  We use a ramping probability to ease in the
 * attempts to get the lock, and not every error will trigger a retry.
 *
 * This means that the cache will be eventually consistent, but will not be immediately consistent. This is a tradeoff we are willing to make.
 * Additionally, this means that the TTL is not precice.  The cache may be updated a bit more often than the TTL, but it will not be updated less often.
 *
 */
export class PromiseCache {
    constructor(redis, state, clock = SystemClock) {
        _PromiseCache_instances.add(this);
        _PromiseCache_redis.set(this, void 0);
        _PromiseCache_localCache.set(this, {});
        _PromiseCache_clock.set(this, void 0);
        _PromiseCache_state.set(this, void 0);
        __classPrivateFieldSet(this, _PromiseCache_redis, redis, "f");
        __classPrivateFieldSet(this, _PromiseCache_state, state, "f");
        __classPrivateFieldSet(this, _PromiseCache_clock, clock, "f");
    }
    /**
     * This is the public API for the cache.  Call this method to cache a promise.
     *
     * @param closure
     * @param options
     * @returns
     */
    async cache(closure, options) {
        __classPrivateFieldSet(this, _PromiseCache_localCache, __classPrivateFieldGet(this, _PromiseCache_state, "f").__cache = __classPrivateFieldGet(this, _PromiseCache_state, "f").__cache ?? {}, "f");
        __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_enforceTTL).call(this, options);
        const localCachedAnswer = __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_localCachedAnswer).call(this, options.key);
        if (localCachedAnswer !== undefined) {
            return localCachedAnswer;
        }
        const existing = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_redisEntry).call(this, options.key);
        const entry = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_maybeRefreshCache).call(this, options, existing, closure);
        return _unwrap(entry);
    }
}
_PromiseCache_redis = new WeakMap(), _PromiseCache_localCache = new WeakMap(), _PromiseCache_clock = new WeakMap(), _PromiseCache_state = new WeakMap(), _PromiseCache_instances = new WeakSet(), _PromiseCache_localCachedAnswer = function _PromiseCache_localCachedAnswer(key) {
    const val = __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key];
    if (val) {
        const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        const hasRetryableError = val?.error &&
            val?.errorTime &&
            val.errorCount < retryLimit &&
            Math.random() < errorRetryProbability &&
            val.errorTime + clientRetryDelay < now;
        const expired = val?.expires && val.expires < now && val.checkedAt + clientRetryDelay < now;
        if (expired || hasRetryableError) {
            delete __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key];
            return undefined;
        }
        else {
            return _unwrap(val);
        }
    }
    return undefined;
}, _PromiseCache_maybeRefreshCache = 
/**
 * If we've bothered to check redis, we're already on the backend.  Let's see if the cache either (1) contains an error, (2)
 * is expired, (3) is missing, or (4) is about to expire.  If any of these are true, we'll refresh the cache based on heuristics.
 *
 * We'll always refresh if missing or expired, but its probabilistic if we'll refresh if about to expire or if we have an error.
 */
async function _PromiseCache_maybeRefreshCache(options, entry, closure) {
    const expires = entry?.expires;
    const rampProbability = expires ? __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_calculateRamp).call(this, expires) : 1;
    if (!entry ||
        (entry?.error && entry.errorCount < retryLimit && errorRetryProbability > Math.random()) ||
        rampProbability > Math.random()) {
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_refreshCache).call(this, options, entry, closure);
    }
    else {
        return entry;
    }
}, _PromiseCache_refreshCache = 
/**
 * The conditions for refreshing the cache are handled in the calling method, which should be
 * #maybeRefreshCache.
 *
 * If you don't win the lock, you'll poll for the cache.  If you don't get the cache within maxPollingTimeout, you'll throw an error.
 */
async function _PromiseCache_refreshCache(options, entry, closure) {
    const lockKey = _lock(options.key);
    const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
    /**
     * The write lock should last for a while, but not the full TTL.  Hopefully write attempts settle down after a while.
     */
    const lockExpiration = new Date(now + options.ttl / 2);
    const lockObtained = await __classPrivateFieldGet(this, _PromiseCache_redis, "f").set(lockKey, '1', {
        expiration: lockExpiration,
        nx: true,
    });
    if (lockObtained) {
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_updateCache).call(this, options.key, entry, closure, options.ttl);
    }
    else if (entry) {
        // This entry is still valid, return it
        return entry;
    }
    else {
        const start = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now();
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_pollForCache).call(this, start, options.key, options.ttl);
    }
}, _PromiseCache_pollForCache = async function _PromiseCache_pollForCache(start, key, ttl) {
    const pollingTimeout = Math.min(ttl, maxPollingTimeout);
    const existing = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_redisEntry).call(this, key);
    if (existing) {
        return existing;
    }
    if (__classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime() - start.getTime() >= pollingTimeout) {
        throw new Error(`Cache request timed out trying to get data at key: ${key}`);
    }
    await new Promise((resolve) => setTimeout(resolve, pollEvery));
    return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_pollForCache).call(this, start, key, ttl);
}, _PromiseCache_updateCache = 
/**
 * Actually update the cache.  This is the method that will be called if we have the lock.
 */
async function _PromiseCache_updateCache(key, entry, closure, ttl) {
    const expires = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime() + ttl;
    entry = entry ?? {
        value: null,
        expires,
        errorCount: 0,
        error: null,
        errorTime: null,
        checkedAt: 0,
    };
    try {
        entry.value = await closure();
        entry.error = null;
        entry.errorCount = 0;
        entry.errorTime = null;
    }
    catch (e) {
        entry.value = null;
        entry.error = e.message ?? 'Unknown error';
        entry.errorTime = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        entry.errorCount++;
    }
    __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key] = entry;
    await __classPrivateFieldGet(this, _PromiseCache_redis, "f").set(_namespaced(key), JSON.stringify(entry), {
        expiration: new Date(expires + allowStaleFor),
    });
    /**
     * Unlocking will allow retries to happen if there was an error.  Otherwise we don't unlock, because the lock
     * will expire on its own.
     */
    if (entry.error && entry.errorCount < retryLimit) {
        await __classPrivateFieldGet(this, _PromiseCache_redis, "f").del(_lock(key));
    }
    return entry;
}, _PromiseCache_calculateRamp = function _PromiseCache_calculateRamp(expiry) {
    const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
    const remaining = expiry - now;
    if (remaining < 0) {
        return 1;
    }
    else if (remaining < 1000) {
        return 0.1;
    }
    else if (remaining < 2000) {
        return 0.01;
    }
    else if (remaining < 3000) {
        return 0.001;
    }
    else {
        return 0;
    }
}, _PromiseCache_redisEntry = async function _PromiseCache_redisEntry(key) {
    const val = await __classPrivateFieldGet(this, _PromiseCache_redis, "f").get(_namespaced(key));
    if (val) {
        const entry = JSON.parse(val);
        entry.checkedAt = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key] = entry;
        return entry;
    }
    return undefined;
}, _PromiseCache_enforceTTL = function _PromiseCache_enforceTTL(options) {
    if (options.ttl < minTtlValue) {
        console.warn(`Cache TTL cannot be less than ${minTtlValue} milliseconds! Updating ttl value of ${options.ttl} to ${minTtlValue}.`);
        options.ttl = minTtlValue;
    }
};
