export var StringUtil;
(function (StringUtil) {
    /**
     * Returns a string, truncated as needed, of length limit or less. When
     * truncated, appends "…".
     */
    function ellipsize(str, limit) {
        return str.length <= limit ? str : `${str.slice(0, limit - 1)}…`;
    }
    StringUtil.ellipsize = ellipsize;
    /** Converts the first character of str to uppercase. */
    function capitalize(str) {
        if (str[0] == null)
            return str;
        return `${str[0].toLocaleUpperCase()}${str.slice(1)}`;
    }
    StringUtil.capitalize = capitalize;
    /** Returns true if string is nullish, empty, or whitespace-only. */
    function isBlank(str) {
        return str == null || /^\s*$/.test(str);
    }
    StringUtil.isBlank = isBlank;
    /**
     * Converts an unknown type to a verbose stacktrace if an error or string form
     * otherwise.
     */
    function caughtToString(val, preferredErrorProperty = 'stack') {
        return val instanceof Error
            ? `${val[preferredErrorProperty] || val.stack || val.message || val.name}`
            : String(val);
    }
    StringUtil.caughtToString = caughtToString;
    /**
     * Converts an unknown type to a verbose stacktrace if an error or string form
     * otherwise. Prefer caughtToString where possible for typing reasons.
     */
    function caughtToStringUntyped(val, preferredErrorProperty = 'stack') {
        return val instanceof Error
            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                `${val[preferredErrorProperty] || val.stack || val.message || val.name}`
            : String(val);
    }
    StringUtil.caughtToStringUntyped = caughtToStringUntyped;
})(StringUtil || (StringUtil = {}));
